<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משחק המשמעת הפיננסית</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* ייבוא פונט Rubik לעברית */
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;600;700&display=swap');
        
        /* הגדרות גלובליות לדיאלוגים */
        .dialog-box, #obstacle-dialog, #powerup-dialog, #job-offer, #job-offer-followup {
            position: absolute;
            z-index: 9999 !important; /* z-index גבוה במיוחד */
            pointer-events: auto !important; /* וידוא שאירועי עכבר יתפסו */
        }
    
        /* שכבת אפלה גלובלית */
        .dialog-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 9998 !important; /* מתחת לדיאלוגים אך מעל לכל היתר */
            pointer-events: auto !important; /* לחסימת אירועים */
        }
    
        :root {
            --primary-color: #2a6496;
            --secondary-color: #4a4a4a;
            --success-color: #3a7a5f;
            --warning-color: #d3873e;
            --danger-color: #d45b5b;
            --background-color: #f8f9fa;
            --card-color: rgba(255, 255, 255, 0.95);
            --text-color: #333333;
            --text-light: #ffffff;
            --day-sky-color-start: #87CEEB;
            --day-sky-color-end: #ADD8E6;
            --night-sky-color-start: #1a2238;
            --night-sky-color-end: #283655;
            --sunset-sky-color-start: #FF7F50;
            --sunset-sky-color-end: #FFD700;
            --sunrise-sky-color-start: #FF7F50;
            --sunrise-sky-color-end: #ADD8E6;
        }
        
        body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: var(--background-color);
    font-family: 'Rubik', 'Open Sans', 'Segoe UI', sans-serif;
    color: var(--text-color);
    transition: background-color 0.5s ease;
    user-select: none; /* מניעת סימון טקסט */
    -webkit-user-select: none; /* עבור ספארי */
    -moz-user-select: none; /* עבור פיירפוקס */
    -ms-user-select: none; /* עבור אקספלורר/אדג' */
    -webkit-tap-highlight-color: transparent; /* מניעת הבהוב בלחיצה במכשירי מגע */
}
        
        #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

/* לוח מחוונים מאוחד */
.dashboard-container {
    position: absolute;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
    z-index: 20;
    width: 320px;
    text-align: center;
    transition: all 0.3s ease;
    overflow: hidden;
    direction: rtl;
    display: none; /* הסתרת הדשבורד בתחילת המשחק */
}

@media (max-width: 768px) {
    .dashboard-container {
        width: 85%; /* רוחב יחסי למסך במקום רוחב קבוע */
        max-width: 280px; /* הגבלת רוחב מקסימלי */
        font-size: 90%; /* הקטנת פונט */
        top: 60px; /* הזזה למעלה יותר */
    }
}

.dashboard-header {
    background-color: var(--primary-color);
    color: white;
    padding: 12px 15px;
    font-weight: 600;
    font-size: 18px;
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    position: relative;
}

.dashboard-header:after {
    content: '▼';
    position: absolute;
    right: 15px;
    transition: transform 0.3s;
}

.dashboard-collapsed .dashboard-header:after {
    transform: rotate(180deg);
}

.dashboard-collapsed .dashboard-content {
    display: none;
}

@media (max-width: 768px) {
    .dashboard-header {
        padding: 8px 12px;
        font-size: 16px;
    }
}

.dashboard-content {
    padding: 15px;
}

.dashboard-section {
    margin-bottom: 15px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding-bottom: 12px;
}

@media (max-width: 768px) {
    .dashboard-content {
        padding: 10px 8px;
    }
    
    .dashboard-section {
        margin-bottom: 8px;
        padding-bottom: 8px;
    }
}

.dashboard-section:last-child {
    margin-bottom: 0;
    border-bottom: none;
    padding-bottom: 0;
}

.section-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--secondary-color);
    font-size: 16px;
}

.finance-info {
    display: flex;
    flex-direction: column;
    gap: 5px;
    font-size: 14px;
}

.finance-row {
    display: flex;
    justify-content: space-between;
    width: 100%;
}

.finance-col {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.health-info {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

@media (max-width: 768px) {
    .section-title {
        font-size: 14px;
        margin-bottom: 5px;
    }
    
    .finance-info {
        gap: 3px;
        font-size: 12px;
    }
    
    .health-info {
        gap: 5px;
    }
    
    .finance-row {
        flex-direction: column;
        gap: 8px;
    }
}

.health-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
}

.health-bar .label {
    width: 60px;
    text-align: right;
    font-size: 14px;
}

.health-bar .bar {
    flex-grow: 1;
    height: 10px;
    background-color: #e9ecef;
    border-radius: 5px;
    overflow: hidden;
}

@media (max-width: 768px) {
    .health-bar .bar {
        height: 8px;
        border-radius: 4px;
    }
}

.clock-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.day-clock-container {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.speed-indicator-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-right: 10px;
}

#dashboard-speed-indicator {
    font-size: 16px;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 4px;
    background-color: rgba(58, 122, 95, 0.8);
    color: white;
}

#dashboard-speed-indicator.medium {
    background-color: rgba(214, 177, 45, 0.9);
}

#dashboard-speed-indicator.slow {
    background-color: rgba(211, 135, 62, 0.9);
}

#dashboard-speed-indicator.very-slow {
    background-color: rgba(212, 91, 91, 0.9);
}

@media (max-width: 768px) {
    .clock-section {
        flex-direction: column;
        gap: 10px;
    }
    
    .speed-indicator-container {
        margin-right: 0;
    }
    
    #dashboard-speed-indicator {
        font-size: 14px;
        padding: 2px 6px;
    }
}

#day-clock {
    font-size: 28px;
    font-weight: bold;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 5px 15px;
    border-radius: 5px;
    margin-top: 5px;
}

@media (max-width: 768px) {
    #day-clock {
        font-size: 20px;
        padding: 3px 10px;
        margin-top: 3px;
    }
}

#game-canvas {
    position: absolute;
    top: 0;
    left: 0;
    touch-action: none;
    transition: filter 2s ease; /* Smooth transition for day/night filter */
}
        
.game-display {
    position: absolute;
    padding: 10px 15px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    font-size: 16px;
    font-weight: 600;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
}
        
#score-display {
    position: static;
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    color: white;
    font-size: 18px;
    text-align: center;
}
        
#date-display {
    top: 15px;
    left: 15px;
    color: var(--secondary-color);
}
        
#monthly-stats {
    display: none; /* הסתרת התיבה המקורית */
}

/* הסתרת תיבת הבריאות המקורית */
.health-bars {
    display: none;
}
        
        #monthly-stats div {
            margin-bottom: 5px;
        }
        
        #tutorial-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 35px; /* הגדלנו את הפדינג מ-25px ל-35px */
    background-color: var(--card-color);
    border-radius: 12px; /* הגדלנו את עיגול הפינות מ-8px ל-12px */
    text-align: center;
    z-index: 100;
    max-width: 90%; /* הגדלנו את הרוחב המקסימלי מ-80% ל-90% */
    min-width: 350px; /* הוספנו רוחב מינימלי חדש */
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2); /* הגדלנו את הצל */
    line-height: 1.7; /* הגדלנו את המרווח בין השורות מ-1.6 ל-1.7 */
    font-size: 18px; /* הוספנו גודל טקסט גדול יותר */
}

.tutorial-screen {
    animation: fade-in 0.5s ease;
}

.next-btn {
    margin-top: 25px; /* הגדלנו מ-15px ל-25px */
    padding: 12px 30px; /* הגדלנו מ-8px 20px ל-12px 30px */
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 6px; /* הגדלנו מ-4px ל-6px */
    cursor: pointer;
    font-size: 18px; /* הגדלנו מ-16px ל-18px */
    font-weight: 600;
    transition: background-color 0.3s, transform 0.1s;
    min-width: 140px; /* הוספנו רוחב מינימלי */
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1); /* הוספנו צל */
}

/* סגנון נפרד לכפתור "התחל" */
#start-btn {
    padding: 14px 35px; /* הגדלנו את הפדינג */
    font-size: 20px; /* הגדלנו את גודל הטקסט */
    min-width: 160px; /* הגדלנו את הרוחב המינימלי */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* צל חזק יותר */
}

.next-btn:hover {
    background-color: #1e5180;
    transform: translateY(-3px); /* הגדלנו אפקט הריחוף מ-2px ל-3px */
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); /* הגדלנו את הצל בריחוף */
}

.gender-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 25px;
}

.gender-btn {
    padding: 12px 30px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: background-color 0.3s, transform 0.1s;
    min-width: 140px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
}

.gender-btn:hover {
    background-color: #1e5180;
    transform: translateY(-3px);
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
}

@keyframes fade-in {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}
        
.dialog-box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--card-color);
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 25px;
    text-align: center;
    z-index: 100;
    display: none;
    width: 80%;
    max-width: 450px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
    line-height: 1.6;
    animation: dialog-appear 0.3s ease-out forwards;
    font-family: 'Rubik', sans-serif;
    direction: rtl;
}

/* הגדרת יישור לכותרות בדיאלוגים */
.dialog-box h3 {
    text-align: center;
}

/* הגדרת יישור לטקסט בדיאלוגים */
.dialog-box p {
    text-align: right;
}
        
@keyframes dialog-appear {
    from {
        opacity: 0;
        transform: translate(-50%, -40%) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}
        
        .dialog-box h3 {
    margin-top: 0;
    color: var(--primary-color);
    font-weight: 700;
    font-size: 22px;
    margin-bottom: 18px;
}

.dialog-box p {
    margin: 16px 0;
    font-size: 18px;
    line-height: 1.6;
}
        
.dialog-box button {
    margin: 12px 8px;
    padding: 12px 24px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: background-color 0.3s, transform 0.15s, box-shadow 0.3s;
    min-width: 120px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.dialog-box button:hover {
    background-color: #1e5180;
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(42, 100, 150, 0.2);
}

/* הסרת סגנונות שונים לכפתורי 'לא' */
/* 
.dialog-box button.no-btn {
    background-color: var(--danger-color);
}

.dialog-box button.no-btn:hover {
    background-color: #c04848;
}
*/

/* מיכל לכפתורים בדיאלוגים - הוסף זאת כהגדרה חדשה */
.dialog-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
}

/* התאמות למיכל הכפתורים במובייל */
@media (max-width: 768px) {
    .dialog-buttons {
        gap: 10px;
        margin-top: 15px;
    }
}
        
#obstacle-dialog {
    position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            animation: bounce-in 0.5s ease-out forwards;
        }
        
        @keyframes bounce-in {
            0% {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -48%);
            }
            100% {
                transform: translate(-50%, -50%);
            }
        }
        
        #obstacle-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #obstacle-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #obstacle-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }
        
        #ignore-btn, #accept-btn {
    background-color: var(--primary-color);
    color: white;
}

#ignore-btn:hover, #accept-btn:hover {
    background-color: #1e5180;
    transform: translateY(-2px);
}
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(50, 50, 50, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: fade-in 0.7s ease-out forwards;
        }
        
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #game-over h2,
        #win-screen h2 {
            font-size: 24px;
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        #game-over button,
        #win-screen button {
            margin-top: 25px;
            padding: 12px 28px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
        }
        
        #game-over button:hover,
        #win-screen button:hover {
            background-color: #1e5180;
            transform: translateY(-2px);
        }
        
        #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 100, 150, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: scale-in 0.6s ease-out forwards;
        }
        
        @keyframes scale-in {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .popup-message {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: rgba(50, 50, 50, 0.9);
            color: white;
            border-radius: 25px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 20;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .power-meter {
            position: absolute;
            bottom: 25px;
            left: 20px;
            width: 200px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            overflow: hidden;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .power-meter-fill {
            height: 100%;
            background-color: var(--success-color);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .status-effect {
            position: absolute;
            top: 50%;  /* Center vertically */
            left: 50%;  /* Center horizontally */
            transform: translate(-50%, 150px);  /* Adjust vertical position */
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
            margin: 0 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 15;
            animation: status-effect-appear 0.4s ease forwards;
        }
        
        @keyframes status-effect-appear {
            from {
                opacity: 0;
                transform: translate(-50%, 170px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 150px);
            }
        }
        
        #status-negative {
            background-color: rgba(212, 91, 91, 0.9);
        }
        
        #status-weight {
            background-color: rgba(211, 135, 62, 0.9);
        }
        
        #speed-indicator {
    position: absolute;
    bottom: 25px;
    right: 20px;
    padding: 8px 15px;
    background-color: rgba(50, 50, 50, 0.8);
    color: white;
    border-radius: 5px;
    font-size: 14px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    transition: background-color 0.3s ease;
    display: none; /* הסתרת המחוון המקורי */
}
        
        #movement-instruction {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            display: none;
            z-index: 25;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 80%;
            animation: pulse 1.5s infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Health indicators in center */
        .health-bars {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            width: 260px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .health-bar {
            margin-bottom: 15px;
        }
        
        .health-bar .label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--secondary-color);
        }
        
        .health-bar .bar {
            width: 100%;
            height: 12px;
            background-color: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .health-bar .fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #physical-health-fill {
            background-color: var(--success-color);
        }
        
        #mental-health-fill {
            background-color: var(--primary-color);
        }
        
        .day-clock-container {
            margin-top: 15px;
            text-align: center;
        }
        
        #day-clock {
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            display: inline-block;
            margin-top: 5px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        #day-clock:hover {
            transform: scale(1.05);
        }
        
        .clock-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 18px;
        }
        .finance-tip {
    position: absolute;
    bottom: 25px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    background-color: rgba(42, 100, 150, 0.85);
    color: white;
    border-radius: 5px;
    font-size: 14px;
    max-width: 80%;
    text-align: center;
    line-height: 1.4;
    opacity: 0;
    transition: opacity 0.5s;
    z-index: 15;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
}

/* סגנון לכפתור החץ להתקדמות */
#forward-arrow-button {
    position: absolute;
    right: 30px;
    top: 70%; /* שינוי מ-50% ל-70% כדי להוריד את הכפתור למטה */
    transform: translateY(-50%);
    width: 65px; /* הגדלת הכפתור מעט */
    height: 65px;
    cursor: pointer;
    z-index: 50;
    filter: drop-shadow(0 0 10px rgba(42, 100, 150, 0.8)); /* צל חזק יותר */
    touch-action: manipulation;
    transition: transform 0.3s, filter 0.3s; /* הוספת אפקט מעבר חלק */
    display: none; /* הסתרת כפתור החץ בתחילת המשחק */
    user-select: none; /* מניעת בחירת טקסט */
    -webkit-user-select: none; /* עבור ספארי */
    -moz-user-select: none; /* עבור פיירפוקס */
    -ms-user-select: none; /* עבור אקספלורר/אדג' */
}

/* אנימציה מושכת יותר לכפתור */
@keyframes pulse-attention {
    0% { transform: translateY(-50%) scale(1); filter: drop-shadow(0 0 10px rgba(42, 100, 150, 0.8)); }
    50% { transform: translateY(-50%) scale(1.15); filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8)); }
    100% { transform: translateY(-50%) scale(1); filter: drop-shadow(0 0 10px rgba(42, 100, 150, 0.8)); }
}

/* אנימציה חדשה עבור פעולת "לחץ והחזק" */
@keyframes press-and-hold {
    0% { transform: translateY(-50%) scale(1); }
    50% { transform: translateY(-50%) scale(0.92); }
    100% { transform: translateY(-50%) scale(1); }
}

/* כאשר הכפתור נלחץ */
#forward-arrow-button:active {
    animation: press-and-hold 2s infinite;
}

/* אנימציה חדשה שתופעל כאשר השחקן לא זז */
.attention-needed {
    animation: pulse-attention 1.5s infinite;
}

/* עיצוב חדש לכפתור עצמו */
#forward-arrow-button svg {
    width: 100%;
    height: 100%;
}

#forward-arrow-button circle {
    fill: rgba(42, 100, 150, 0.9); /* רקע כהה יותר */
    stroke: rgba(255, 255, 255, 0.7); /* הוספת קו מתאר */
    stroke-width: 2px;
}

#forward-arrow-button path {
    fill: white;
    transform: scale(1.2); /* הגדלת החץ עצמו */
}

@media (max-width: 768px) {
    #forward-arrow-button {
        right: 20px;
        width: 70px;
        height: 70px;
    }
}

#powerup-dialog {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--card-color);
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 25px;
    text-align: center;
    z-index: 100;
    display: none;
    width: 80%;
    max-width: 450px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
    animation: slide-in 0.4s ease forwards;
}
        
        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #powerup-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #powerup-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #powerup-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 80px;
        }
        
        #powerup-yes-btn, #powerup-no-btn {
    background-color: var(--primary-color);
    color: white;
}

#powerup-yes-btn:hover, #powerup-no-btn:hover {
    background-color: #1e5180;
    transform: translateY(-2px);
}
        
        /* Sun and Moon */
        #sun {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #FFD700 40%, rgba(255, 215, 0, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            z-index: 5;
            opacity: 1;
            transition: all 2s ease;
        }
        
        #moon {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #E6E6FA 40%, rgba(230, 230, 250, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(230, 230, 250, 0.5);
            z-index: 5;
            opacity: 0;
            transition: all 2s ease;
        }
        
        /* Moon shadow effect */
        #moon::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            width: 45px;
            height: 45px;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.1) 40%, rgba(0, 0, 0, 0) 70%);
            border-radius: 50%;
        }
        
        /* Stars in night sky */
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 2s ease;
            animation: twinkle 3s infinite alternate;
            z-index: 4;
        }
        
        @keyframes twinkle {
            from { opacity: 0.2; }
            to { opacity: 0.8; }
        }
        
        /* Weather effects */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            z-index: 6;
            transition: all 1s ease;
            opacity: 0;
        }
        
        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
        }
        
        .bird {
            position: absolute;
            z-index: 6;
            transition: all 0.5s ease;
            opacity: 0;
        }
        
        /* Day/Night cycle overlay */
        #day-night-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 30, 0);
            z-index: 3;
            pointer-events: none;
            transition: background-color 2s ease;
        }
        
        @media (max-width: 768px) {
    .game-display {
        font-size: 14px;
        padding: 8px 12px;
    }
    
    .dialog-box {
        width: 90%;
        max-width: 420px;
        padding: 25px;
    }
    
    .dialog-box h3 {
        font-size: 20px;
        margin-bottom: 15px;
    }
    
    .dialog-box p {
        font-size: 16px;
        line-height: 1.5;
        margin: 12px 0;
    }
    
    .dialog-box button {
        padding: 10px 20px;
        font-size: 16px;
        margin: 10px 6px;
        min-width: 110px;
    }
    
    #tutorial-message {
        font-size: 16px; /* הגדלנו מ-14px ל-16px */
        max-width: 95%;
        padding: 25px; /* הגדלנו מ-20px ל-25px */
        min-width: 300px; /* הוספנו רוחב מינימלי */
    }
    
    .tutorial-screen h3 {
        font-size: 20px; /* הגדלנו מ-18px ל-20px */
    }
    
    .tutorial-screen p {
        font-size: 16px; /* הגדלנו מ-14px ל-16px */
    }
    
    .next-btn {
        padding: 10px 20px; /* הגדלנו מ-8px 16px ל-10px 20px */
        font-size: 16px; /* הגדלנו מ-14px ל-16px */
        min-width: 120px; /* הוספנו רוחב מינימלי */
    }
    
    .power-meter {
        width: 150px;
        height: 10px;
    }
    
    #obstacle-dialog {
        width: 90%;
        max-width: 400px;
        padding: 20px;
    }
    
    #obstacle-dialog p {
        font-size: 14px;
    }
    
    .health-bars {
        width: 220px;
        padding: 12px;
        top: 100px;
    }
    
    .finance-tip {
        font-size: 12px;
        padding: 8px 16px;
    }
    
    #day-clock {
        font-size: 20px;
        padding: 4px 12px;
    }
    
    #sun, #moon {
        width: 40px;
        height: 40px;
        right: 60px;
        top: 40px;
    }
    
    /* הוספת הגדרות עבור מקטע השעון ומחוון הקצב במובייל */
    .clock-section {
        flex-direction: row; /* תמיד להציג במאוזן */
        justify-content: space-between;
        gap: 5px; /* מרווח קטן יותר במובייל */
    }
    
    .speed-indicator-container {
        margin-right: 0;
    }
    
    /* הקטנת גודל הטקסט במובייל */
    .clock-section .label {
        font-size: 12px;
    }
}
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <!-- Day/Night cycle overlay -->
        <div id="day-night-overlay"></div>
        
        <!-- Sun and Moon -->
        <div id="sun"></div>
        <div id="moon"></div>
        
        <div id="date-display" class="game-display">מרץ 2025</div>
        
        <!-- תיבת לוח המחוונים המאוחדת -->
        <div class="dashboard-container">
            <!-- כותרת הלוח -->
            <div class="dashboard-header">
                <div id="score-display">סך נכסים פיננסיים: <span id="score-value">0</span> ש"ח</div>
            </div>
            
            <div class="dashboard-content">
                <!-- מידע פיננסי -->
<div class="dashboard-section finance-section">
    <div class="section-title">מידע פיננסי</div>
    <div class="finance-info">
        <div class="finance-row">
            <div class="finance-col">
                <div>נכסים פיננסיים: <span id="assets">0</span> ש"ח</div>
            </div>
            <div class="finance-col">
                <div>הוצאות חודשיות: <span id="expenses">0</span> ש"ח</div>
                <div>הכנסה חודשית: <span id="income">5,000</span> ש"ח</div>
            </div>
        </div>
    </div>
</div>
                
                <!-- מידע בריאותי -->
                <div class="dashboard-section health-section">
                    <div class="section-title">בריאות</div>
                    <div class="health-info">
                        <div class="health-bar">
                            <div class="label">פיזית</div>
                            <div class="bar">
                                <div id="physical-health-fill" class="fill" style="width: 100%;"></div>
                            </div>
                        </div>
                        <div class="health-bar">
                            <div class="label">מנטלית</div>
                            <div class="bar">
                                <div id="mental-health-fill" class="fill" style="width: 100%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- שעון יומי וקצב התקדמות -->
<div class="dashboard-section clock-section">
    <div class="day-clock-container">
        <div class="label">ימים שנותרו <span class="clock-icon">📅</span></div>
        <div id="day-clock">30</div>
    </div>
    <div class="speed-indicator-container">
        <div class="label">קצב התקדמות</div>
        <div id="dashboard-speed-indicator">אופטימלית</div>
    </div>
</div>
            </div>
        </div>
        
        <div id="power-meter" class="power-meter">
            <div id="power-meter-fill" class="power-meter-fill"></div>
        </div>
        
        <div id="popup-message" class="popup-message"></div>
        <div id="finance-tip" class="finance-tip"></div>
        
        <div id="status-negative" class="status-effect">השפעה מנטלית: חלש</div>
<div id="status-weight" class="status-effect">מצב גופני: כבד</div>
<div id="speed-indicator">מהירות: רגילה</div>

<!-- כפתור התקדמות -->
<div id="forward-arrow-button">
    <svg width="65" height="65" viewBox="0 0 65 65">
        <circle cx="32.5" cy="32.5" r="30" fill="rgba(42, 100, 150, 0.9)" stroke="rgba(255, 255, 255, 0.7)" stroke-width="2" />
        <text x="32.5" y="28" fill="rgba(255, 255, 255, 0.9)" font-size="11" text-anchor="middle" dominant-baseline="middle" style="pointer-events: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;">לחץ</text>
<text x="32.5" y="40" fill="rgba(255, 255, 255, 0.9)" font-size="10" text-anchor="middle" dominant-baseline="middle" style="pointer-events: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;">והחזק</text>
    </svg>
</div>

<!-- דיאלוג הפאוור-אפים -->
<div id="powerup-dialog" class="dialog-box">
    <h3 id="powerup-title">⚡ נתקלת בהזדמנות לשיפור!</h3>
    <p id="powerup-text">האם עשית אימון כבר היום?</p>
    <div class="dialog-buttons">
        <button id="powerup-yes-btn">כן</button>
        <button id="powerup-no-btn">לא</button>
    </div>
</div>
        
<!-- דיאלוג המכשול -->
<div id="obstacle-dialog" class="dialog-box">
    <h3 id="obstacle-title">⚖️ התמודדות עם דילמה פיננסית</h3>
    <p id="obstacle-text">האם לבחור בהוצאה מיידית או להמשיך בתוכנית החיסכון?</p>
    <div class="dialog-buttons">
        <button id="ignore-btn">סירוב</button>
        <button id="accept-btn">הסכמה</button>
    </div>
</div>
        
<div id="tutorial-message">
    <!-- בכל פעם יוצג רק אחד מהמסכים הבאים -->
    <div class="tutorial-screen" id="tutorial-screen-1">
        <h3>🎮 ברוכים הבאים למשחק המשמעת הפיננסית</h3>
        <button class="next-btn">הבא</button>
    </div>
    
    <div class="tutorial-screen" id="tutorial-screen-2" style="display: none;">
        <h3>מה המין שלך?</h3>
        <div class="gender-buttons">
            <button class="gender-btn" id="male-btn">גבר</button>
            <button class="gender-btn" id="female-btn">אישה</button>
        </div>
    </div>
    
    <div class="tutorial-screen" id="tutorial-screen-3" style="display: none;">
        <p>🎯 המטרה שלך היא לצבור 100,000 ש"ח באמצעות התמדה והחלטות פיננסיות חכמות.</p>
        <button class="next-btn">הבא</button>
    </div>
            
            <div class="tutorial-screen" id="tutorial-screen-3" style="display: none;">
                <p>👉 לחץ על כפתור החץ שבצד ימין כדי להתקדם בדרך הפיננסית. ככל שתתקדם, הימים יחלפו ובסוף החודש תקבל משכורת.</p>
                <button class="next-btn">הבא</button>
            </div>
            
            <div class="tutorial-screen" id="tutorial-screen-4" style="display: none;">
                <p>💰 אתה מרוויח 5,000 ש"ח בחודש מהעבודה היציבה שלך, אך תיתקל בדילמות ופיתויים לאורך הדרך.</p>
                <button class="next-btn">הבא</button>
            </div>
            
            <div class="tutorial-screen" id="tutorial-screen-5" style="display: none;">
                <p>🏃‍♂️ קצב ההתקדמות שלך מושפע מהמצב הפיזי והמנטלי.</p>
                <button class="next-btn">הבא</button>
            </div>
            
            <div class="tutorial-screen" id="tutorial-screen-6" style="display: none;">
                <p>🏁 זכור - יציבות פיננסית היא מרתון, לא ספרינט. נדרשת משמעת והתמדה לאורך זמן.</p>
                <button id="start-btn">התחל</button>
            </div>
        </div>
        
        <div id="job-offer" class="dialog-box">
            <h3>💼 הזדמנות קריירה חדשה</h3>
            <p>האם לבחור בקריירה עם שכר גבוה יותר אך פחות יציבות?</p>
            <div class="dialog-buttons">
                <button id="yes-btn">👍 כן</button>
                <button id="no-btn">👎 לא</button>
            </div>
        </div>
        
        <div id="job-offer-followup" class="dialog-box">
            <h3>🤔 שקול שוב את החלטתך</h3>
            <p id="followup-text">האם אתה בטוח שברצונך לדחות הזדמנות זו?</p>
            <div class="dialog-buttons">
                <button id="followup-yes-btn">👍 כן</button>
                <button id="followup-no-btn">👎 לא</button>
            </div>
        </div>
        
        <div id="game-over">
            <h2>😓 ניהול פיננסי כושל</h2>
            <p id="game-over-reason"></p>
            <p>💸 צברת סך של <span id="final-score">0</span> ש"ח בנכסים פיננסיים</p>
            <div id="game-stats">
                <p>📅 תקופה שנוהלה: <span id="months-played">0</span> חודשים</p>
                <p>💪 הרגלים פיננסיים חיוביים: <span id="powerups-collected">0</span></p>
                <p>🛡️ דילמות פיננסיות שנפתרו: <span id="obstacles-avoided">0</span></p>
            </div>
            <p class="lesson">💡 לקח: יציבות פיננסית דורשת משמעת, תכנון ארוך טווח והחלטות מושכלות.</p>
            <button id="restart-btn">🔄 ניסיון חדש</button>
        </div>
        
        <div id="win-screen">
            <h2>🏆 יציבות פיננסית הושגה!</h2>
            <p>🎉 הצלחת לצבור 100,000 ש"ח בנכסים פיננסיים!</p>
            <p>👏 כל הכבוד על המשמעת העצמית, ההתמדה וקבלת ההחלטות הנכונות.</p>
            <div id="win-stats">
                <p>⏱️ תקופת צבירת הנכסים: <span id="win-months">0</span> חודשים</p>
                <p>💪 הרגלים פיננסיים חיוביים: <span id="win-powerups">0</span></p>
                <p>🛡️ דילמות פיננסיות שנפתרו: <span id="win-obstacles">0</span></p>
            </div>
            <p class="lesson">💡 זכור: יציבות פיננסית היא תהליך מתמשך הדורש התמדה והחלטות מושכלות.</p>
            <button id="play-again-btn">🔄 ניסיון נוסף</button>
        </div>
    </div>
    <script>
        
        // Canvas and context setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to cover the window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game variables
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let currentMonth = 0;
        let tutorialShown = true;
        let isMoving = false; // Movement control
        let moveTimer = null; // For instruction display timing
        let financeMessageTimer = null; // For finance tips display
        
        // Day/Night cycle variables
        let currentHour = 5; // Starting at 5:00 AM
        let currentMinute = 0;
        let dayProgress = 0; // 0 to 1 for day cycle
        let isDayTime = true;
        let timeMultiplier = 2.4; // 2.4 hours per real second (24h in 10 seconds)
        let lastTimeUpdate = Date.now();
        let stars = [];
        let clouds = [];
        let birds = [];

        // משתני יום - יממה = 10 שניות במצב אופטימלי
const dayMilliseconds = {
    perfect: 10000, // 10 שניות ליממה במצב אופטימלי
    current: 10000   // יכול להשתנות בהתאם לבריאות
};
        
        // Create stars
        function createStars() {
            stars = [];
            const starCount = Math.min(50, Math.floor(window.innerWidth * window.innerHeight / 10000)); // Adjust based on screen size
            
            for (let i = 0; i < starCount; i++) {
                const star = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * 0.7), // Only in the sky area
                    size: Math.random() * 2 + 1, // 1-3px
                    twinkleSpeed: Math.random() * 2 + 1 // Variation in twinkle speed
                };
                stars.push(star);
            }
        }
        
        // Create clouds
        function createClouds() {
            clouds = [];
            const cloudCount = Math.min(5, Math.floor(window.innerWidth / 400)); // Adjust based on screen width
            
            for (let i = 0; i < cloudCount; i++) {
                createCloud();
            }
        }
        
        // Create a single cloud
        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            // Random cloud size and position
            const size = Math.random() * 40 + 60; // 60-100px
            const top = Math.random() * (canvas.height * 0.3) + 50; // Top half of sky
            const left = Math.random() * canvas.width;
            
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size / 2}px`;
            cloud.style.top = `${top}px`;
            cloud.style.left = `${left}px`;
            
            // Create cloud shape with pseudo-elements
            cloud.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3)';
            
            // Speed will determine how fast the cloud moves across the screen
            const speed = Math.random() * 0.05 + 0.01; // pixels per millisecond
            cloud.dataset.speed = speed;
            cloud.dataset.position = left;
            
            document.getElementById('game-container').appendChild(cloud);
            clouds.push(cloud);
            
            // Set initial opacity based on time of day
            updateCloudVisibility();
        }
        
        // Create birds
        function createBirds() {
            birds = [];
            const birdCount = Math.min(3, Math.floor(window.innerWidth / 500)); // Adjust based on screen width
            
            for (let i = 0; i < birdCount; i++) {
                if (Math.random() < 0.7) { // 70% chance to create a bird
                    createBird();
                }
            }
        }
        
        // Create a single bird
        function createBird() {
            const bird = document.createElement('div');
            bird.className = 'bird';
            
            // Create SVG for bird
            const birdSize = Math.random() * 10 + 15; // 15-25px
            bird.innerHTML = `
                <svg width="${birdSize}" height="${birdSize}" viewBox="0 0 100 100">
                    <path d="M10,50 Q30,30 50,50 Q70,30 90,50" stroke="#333" fill="transparent" stroke-width="5"/>
                </svg>
            `;
            
            // Random position
            const top = Math.random() * (canvas.height * 0.4) + 50; // Upper half of sky
            const left = -birdSize;
            
            bird.style.top = `${top}px`;
            bird.style.left = `${left}px`;
            
            // Speed will determine how fast the bird moves across the screen
            const speed = Math.random() * 0.08 + 0.05; // pixels per millisecond
            bird.dataset.speed = speed;
            bird.dataset.position = left;
            
            document.getElementById('game-container').appendChild(bird);
            birds.push(bird);
            
            // Only show birds during the day
            bird.style.opacity = isDayTime ? '1' : '0';
        }
        
        // Update clouds position
        function updateClouds(deltaTime) {
            clouds.forEach((cloud, index) => {
                let position = parseFloat(cloud.dataset.position);
                const speed = parseFloat(cloud.dataset.speed);
                
                position += speed * deltaTime;
                
                // Reset cloud when it goes off screen
                if (position > canvas.width + parseFloat(cloud.style.width)) {
                    position = -parseFloat(cloud.style.width);
                }
                
                cloud.dataset.position = position;
                cloud.style.left = `${position}px`;
            });
        }
        
        // Update birds position
        function updateBirds(deltaTime) {
            birds.forEach((bird, index) => {
                let position = parseFloat(bird.dataset.position);
                const speed = parseFloat(bird.dataset.speed);
                
                position += speed * deltaTime;
                
                // Remove bird when it goes off screen
                if (position > canvas.width + 50) {
                    document.getElementById('game-container').removeChild(bird);
                    birds.splice(index, 1);
                    
                    // Maybe create a new bird
                    if (Math.random() < 0.3 && isDayTime) {
                        setTimeout(createBird, Math.random() * 5000 + 2000);
                    }
                } else {
                    bird.dataset.position = position;
                    bird.style.left = `${position}px`;
                    
                    // Make bird flap by changing the SVG occasionally
                    if (Math.random() < 0.05) {
                        const path = bird.querySelector('path');
                        if (path) {
                            const flap = Math.random() < 0.5 ? 
                                "M10,50 Q30,20 50,50 Q70,20 90,50" : 
                                "M10,50 Q30,40 50,50 Q70,40 90,50";
                            path.setAttribute('d', flap);
                        }
                    }
                }
            });
            
            // Occasionally add new birds during the day
            if (birds.length < 3 && Math.random() < 0.001 && isDayTime) {
                createBird();
            }
        }
        
        // Update cloud visibility based on time of day
        function updateCloudVisibility() {
            const cloudOpacity = isDayTime ? 0.8 : 0.3; // Less visible at night
            
            clouds.forEach(cloud => {
                cloud.style.opacity = cloudOpacity;
                // Change cloud color for night
                if (isDayTime) {
                    cloud.style.background = "rgba(255, 255, 255, 0.7)";
                } else {
                    cloud.style.background = "rgba(200, 200, 220, 0.5)";
                }
            });
        }
        
        // Update birds visibility based on time of day
        function updateBirdsVisibility() {
            birds.forEach(bird => {
                // Birds only appear during day
                bird.style.opacity = isDayTime ? '1' : '0';
                
                // Remove birds at night
                if (!isDayTime) {
                    setTimeout(() => {
                        if (birds.includes(bird)) {
                            document.getElementById('game-container').removeChild(bird);
                            birds.splice(birds.indexOf(bird), 1);
                        }
                    }, 2000);
                }
            });
        }
        
        // Update day/night cycle
function updateDayNightCycle() {
    // בדיקה מקיפה יותר של מצב המשחק
    if (!gameRunning || gamePaused) {
        return;
    }
    
    // בדיקה אם השחקן זז - אם לא, אין התקדמות בזמן
    if (!isMoving) {
        // עדיין נעדכן את תצוגת הימים גם אם השחקן לא זז
        updateClockDisplay();
        return;
    }
    
    // בדיקה מורחבת של lastTimeUpdate
    if (!lastTimeUpdate || isNaN(lastTimeUpdate)) {
        console.log("Resetting lastTimeUpdate");
        lastTimeUpdate = Date.now();
        return;
    }

    const now = Date.now();
    const deltaTime = now - lastTimeUpdate;
    
    // בדיקה מחמירה יותר של deltaTime
    if (deltaTime <= 0 || deltaTime > 1000) {
        console.log(`Invalid deltaTime: ${deltaTime}ms, resetting timer`);
        lastTimeUpdate = now;
        return;
    }
    
    lastTimeUpdate = now; // עדכון הזמן האחרון אחרי הבדיקות

    try {
        // בדיקת תקינות של dayMilliseconds
        if (!dayMilliseconds || !dayMilliseconds.current || dayMilliseconds.current <= 0) {
            console.error("Invalid dayMilliseconds:", dayMilliseconds);
            return;
        }

        // חישוב זמן בהתאם למהירות היום הנוכחית
        const secondsElapsed = deltaTime / 1000;
        const totalDayTimeInSeconds = dayMilliseconds.current / 1000;
        const hoursElapsed = secondsElapsed * (24 / totalDayTimeInSeconds);

        // בדיקה מורחבת של תקינות החישוב
        if (isNaN(hoursElapsed) || !isFinite(hoursElapsed) || hoursElapsed < 0) {
            console.error("Invalid hoursElapsed calculation:", {
                secondsElapsed,
                totalDayTimeInSeconds,
                hoursElapsed
            });
            return;
        }

        // Update minutes first
        currentMinute += hoursElapsed * 60;

        // If minutes exceed 60, increment hour
        while (currentMinute >= 60) {
            currentMinute -= 60;
            currentHour++;

            // Reset hour after 24
            if (currentHour >= 24) {
                currentHour = 0;
                // הורדת 5% מהבריאות הפיזית והמנטלית בסוף כל יממה
                decreaseHealthPerDay();
            }

            // Check for day/night transition
            if (currentHour === 18) {
                transitionToNight();
            } else if (currentHour === 5) {
                transitionToDay();
            }
        }

        // Format days remaining display
        updateClockDisplay();
        
        // Update day progress (0-1 for full day)
        dayProgress = (currentHour + (currentMinute / 60)) / 24;

        // Update sky color based on time
        updateSkyColor();
        
        // Update sun/moon position
        updateCelestialBodies();
        
        // Update environment elements
        updateClouds(deltaTime);
        updateBirds(deltaTime);
    } catch (error) {
        console.error("Error in updateDayNightCycle:", error, {
            currentHour,
            currentMinute,
            dayProgress,
            deltaTime
        });
    }
}

// ערכים לשמירת מצב הבריאות הקודם
let lastPhysicalHealthTier = 100;
let lastMentalHealthTier = 100;

// פונקציה להורדת הבריאות הפיזית והמנטלית בכל יממה
function decreaseHealthPerDay() {
    // שמור את הערכים הנוכחיים לפני השינוי
    const prevPhysical = stats.physicalHealth;
    const prevMental = stats.mentalHealth;
    
    // הורדת 5% מהבריאות הפיזית והמנטלית
    stats.physicalHealth = Math.max(0, stats.physicalHealth - 5);
    stats.mentalHealth = Math.max(0, stats.mentalHealth - 5);
    
    // עדכון מצב השחקן בהתאם לשינויים בבריאות
    updatePlayerCondition();
    
    // בדוק אם הבריאות ירדה מתחת לסף משמעותי (80%, 60%, 40%, 20%)
    // ורק אז הצג הודעה
    const checkHealthTier = (value) => {
        if (value <= 20) return 1;
        if (value <= 40) return 2;
        if (value <= 60) return 3;
        if (value <= 80) return 4;
        return 5;
    };
    
    const newPhysicalTier = checkHealthTier(stats.physicalHealth);
    const newMentalTier = checkHealthTier(stats.mentalHealth);
    
    // הצג הודעה והדיאלוג רק אם ירד לרמה חדשה של בריאות
    let physicalHealthDegraded = false;
    
    if (newPhysicalTier < checkHealthTier(prevPhysical) || newMentalTier < checkHealthTier(prevMental)) {
        let message = "";
        
        if (newPhysicalTier < checkHealthTier(prevPhysical) && newPhysicalTier <= 3) {
            message = "הבריאות הפיזית שלך מתדרדרת. מומלץ לפעול לשיפור!";
            physicalHealthDegraded = true;
        }
        
        if (newMentalTier < checkHealthTier(prevMental) && newMentalTier <= 3) {
            message = message ? "הבריאות שלך מתדרדרת. שים לב לטפל בעצמך!" : 
                               "הבריאות המנטלית שלך מתדרדרת. מומלץ לפעול לשיפור!";
        }
        
        if (message) {
            showPopupMessage(message, 3000);
            
            // הצג תיבת דו-שיח לגבי בריאות פיזית אם היא זו שהתדרדרה
            if (physicalHealthDegraded) {
                setTimeout(() => {
                    showHealthDialog();
                }, 3500); // הצג את הדיאלוג אחרי שההודעה הקודמת נעלמת
            }
        }
    }
}

// פונקציה להצגת תיבת דו-שיח לשיפור הבריאות
function showHealthDialog() {
    // השהה את המשחק בזמן הצגת תיבת הדו-שיח
    gamePaused = true;
    isMoving = false; // עצירת התנועה באופן מוחלט
    
    // יצירת שכבת האפלה מאחורי הדיאלוג
    const dialogOverlay = createDialogOverlay();
    
    // יצירת תיבת הדו-שיח
    const healthDialog = document.createElement('div');
    healthDialog.className = 'dialog-box';
    healthDialog.id = 'health-dialog';
    healthDialog.style.zIndex = '100';
    
    // תוכן תיבת הדו-שיח
    healthDialog.innerHTML = `
        <h3>💪 בריאות ואיזון פיננסי</h3>
        <p>האם אתה דואג לשמור על הבריאות הפיזית שלך?</p>
        <div class="dialog-buttons">
            <button id="health-priority-no">קודם כל נעשה כסף, אחרי זה נדאג לבריאות</button>
            <button id="health-priority-yes">בריאות וכסף – הולכות ביחד</button>
        </div>
    `;
    
    // הוספת תיבת הדו-שיח למשחק
    document.getElementById('game-container').appendChild(healthDialog);
    
    // הוספת מאזיני אירועים לכפתורי תיבת הדו-שיח
    document.getElementById('health-priority-no').addEventListener('click', function() {
        // בחירה באפשרות 1: לא לשפר את הבריאות
        closeHealthDialog(dialogOverlay, healthDialog);
        showPopupMessage("החלטת להתמקד בכסף. הבריאות שלך לא השתפרה.", 3000);
    });
    
    document.getElementById('health-priority-yes').addEventListener('click', function() {
        // בחירה באפשרות 2: לשפר את הבריאות
        closeHealthDialog(dialogOverlay, healthDialog);
        
        // שיפור הבריאות הפיזית ב-20%
        stats.physicalHealth = Math.min(100, stats.physicalHealth + 20);
        
        // עדכון מצב השחקן
        updatePlayerCondition();
        
        // הצגת הודעה על שיפור הבריאות
        showPopupMessage("החלטת לשלב בריאות וכסף. הבריאות הפיזית שלך השתפרה ב-20%!", 3000);
        
        // אפקט ויזואלי לשיפור בריאות
        showPhysicalBoostEffect();
    });
}

// פונקציה לסגירת תיבת הדו-שיח של הבריאות
function closeHealthDialog(overlay, dialog) {
    // הסרת תיבת הדו-שיח והשכבה השקופה
    if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
    }
    
    if (dialog && dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
    }
    
    // המשך המשחק
    gamePaused = false;
}

// Format and update days remaining display
function updateClockDisplay() {
    // חישוב ימים שנותרו על פי התקדמות החודש
    const totalDaysInMonth = 30; // מספר קבוע של ימים בחודש
    const progress = currentMonthTimer / framesPerMonth; // התקדמות החודש (0-1)
    const daysElapsed = Math.floor(progress * totalDaysInMonth); // מספר ימים שעברו
    const daysRemaining = totalDaysInMonth - daysElapsed; // ימים שנותרו
    
    document.getElementById('day-clock').textContent = daysRemaining;
    
    // Visual effect on day change
    if (daysRemaining < (lastDaysRemaining || totalDaysInMonth)) {
        document.getElementById('day-clock').style.transform = 'scale(1.1)';
        setTimeout(() => {
            document.getElementById('day-clock').style.transform = 'scale(1)';
        }, 300);
        lastDaysRemaining = daysRemaining;
    }
}

// משתנה גלובלי לשמירת מספר הימים האחרון שהוצג
let lastDaysRemaining = 30;
        
        // Update sky color based on time
        function updateSkyColor() {
            let skyColor;
            const hour = currentHour + (currentMinute / 60);
            
            // Day sky (6-17)
            if (hour >= 6 && hour < 17) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start');
            }
            // Sunset (17-19)
            else if (hour >= 17 && hour < 19) {
                const progress = (hour - 17) / 2; // 0-1 for sunset
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--sunset-sky-color-start'),
                    progress
                );
            }
            // Night (19-5)
            else if (hour >= 19 || hour < 5) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--night-sky-color-start');
            }
            // Sunrise (5-6)
            else {
                const progress = (hour - 5); // 0-1 for sunrise
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--sunrise-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    progress
                );
            }
            
            // Apply sky color in draw background
            ctx.fillStyle = skyColor;
        }
        
        // Helper for color mixing
        function mixColors(color1, color2, ratio) {
            color1 = color1.trim();
            color2 = color2.trim();
            
            // Simple mixing for hex or rgb colors
            if (color1.startsWith('#')) {
                // Convert hex to rgb
                const r1 = parseInt(color1.substr(1, 2), 16);
                const g1 = parseInt(color1.substr(3, 2), 16);
                const b1 = parseInt(color1.substr(5, 2), 16);
                
                const r2 = parseInt(color2.substr(1, 2), 16);
                const g2 = parseInt(color2.substr(3, 2), 16);
                const b2 = parseInt(color2.substr(5, 2), 16);
                
                const r = Math.round(r1 * (1 - ratio) + r2 * ratio);
                const g = Math.round(g1 * (1 - ratio) + g2 * ratio);
                const b = Math.round(b1 * (1 - ratio) + b2 * ratio);
                
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Assume rgb format
                return color1; // Simplified - would need regex for proper rgb mixing
            }
        }
        
        // Update sun and moon positions
        function updateCelestialBodies() {
            const sunElement = document.getElementById('sun');
            const moonElement = document.getElementById('moon');
            
            // Calculate positions - circular path in sky
            const skyWidth = canvas.width;
            const skyHeight = canvas.height * 0.6; // Top 60% is sky
            
            // Sun moves from left to right during day (5-19)
            if (currentHour >= 5 && currentHour < 19) {
                const sunProgress = (currentHour - 5) / 14; // 0-1 for sun path
                
                // Circular path for sun - moves in an arc
                const sunX = skyWidth * sunProgress;
                const sunY = skyHeight * 0.5 * Math.sin(Math.PI * sunProgress) + 50;
                
                sunElement.style.left = `${sunX}px`;
                sunElement.style.top = `${sunY}px`;
                
                // Set sun opacity based on time (fade during sunset/sunrise)
                if (currentHour >= 17) { // Sunset
                    const fadeProgress = (currentHour + currentMinute/60 - 17) / 2;
                    sunElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else if (currentHour < 6) { // Sunrise
                    const fadeProgress = (currentHour + currentMinute/60 - 5);
                    sunElement.style.opacity = Math.min(1, fadeProgress);
                } else {
                    sunElement.style.opacity = '1';
                }
                
                // Hide moon during day
                moonElement.style.opacity = '0';
                
                // Stars invisible during day
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
            } 
            // Moon moves from left to right during night (19-5)
            else {
                const moonProgress = (currentHour >= 19) ? 
                    (currentHour - 19) / 10 : // Evening (19-24)
                    (currentHour + 5) / 10;  // Morning (0-5)
                
                // Circular path for moon
                const moonX = skyWidth * moonProgress;
                const moonY = skyHeight * 0.3 * Math.sin(Math.PI * moonProgress) + 50;
                
                moonElement.style.left = `${moonX}px`;
                moonElement.style.top = `${moonY}px`;
                
                // Set moon opacity (fade during transitions)
                if (currentHour >= 19 && currentHour < 20) { // Dusk
                    const fadeProgress = (currentHour + currentMinute/60 - 19);
                    moonElement.style.opacity = Math.min(1, fadeProgress);
                } else if (currentHour >= 4 && currentHour < 5) { // Dawn
                    const fadeProgress = (currentHour + currentMinute/60 - 4);
                    moonElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else {
                    moonElement.style.opacity = '1';
                }
                
                // Hide sun during night
                sunElement.style.opacity = '0';
                
                // Stars visible at night
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
            }
        }
        
        // Transition to night
        function transitionToNight() {
            if (isDayTime) {
                isDayTime = false;
                
                // Fade in night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0.3)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Create stars if they don't exist
                if (document.querySelectorAll('.star').length === 0) {
                    createStarsElements();
                }
                
                // Show stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(0.8)';
                
                // Update UI elements for night
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.25)';
                });
            }
        }
        
        // Transition to day
        function transitionToDay() {
            if (!isDayTime) {
                isDayTime = true;
                
                // Fade out night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Hide stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(1)';
                
                // Update UI elements for day
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                });
                
                // Maybe create some birds for the new day
                if (birds.length < 2 && Math.random() < 0.5) {
                    createBird();
                }
            }
        }
        
        // Create star elements in DOM
        function createStarsElements() {
            createStars(); // Generate star data
            
            stars.forEach(star => {
                const starElement = document.createElement('div');
                starElement.className = 'star';
                starElement.style.width = `${star.size}px`;
                starElement.style.height = `${star.size}px`;
                starElement.style.left = `${star.x}px`;
                starElement.style.top = `${star.y}px`;
                
                // Custom twinkle animation
                starElement.style.animationDuration = `${star.twinkleSpeed}s`;
                
                document.getElementById('game-container').appendChild(starElement);
            });
        }
        // Game statistics
        let stats = {
            monthsPlayed: 0,
            powerupsCollected: 0,
            obstaclesAvoided: 0,
            obstaclesFaced: 0,
            expenses: 0,
            income: 5000,  // Starting monthly income
            mentalHealth: 100, // Mental state affects progress speed
            physicalHealth: 100 // Physical state affects progress speed
        };
        
        // Financial questions and answers as obstacles
const financialQuestions = [
    {
        question: "🍔 כמה כסף בשנה יוציא אדם שמקצה 50 ש\"ח ליום לארוחות חוץ?",
        correctAnswer: "כ-18,000 ש\"ח בשנה",
        wrongAnswer: "כ-10,000 ש\"ח בשנה",
        explanation: "50 ש\"ח כפול 365 ימים שווה 18,250 ש\"ח בשנה"
    },
    {
        question: "💰 איזה אחוז מהצעירים שחוסכים 20% מהכנסתם מגיעים ליציבות פיננסית תוך 5 שנים?",
        correctAnswer: "70% מהצעירים",
        wrongAnswer: "30% מהצעירים",
        explanation: "חיסכון עקבי של 20% מההכנסה מוביל ליציבות פיננסית"
    },
    {
        question: "📈 השקעה של 500 ש\"ח בחודש החל מגיל 23 יכולה להגיע לכמה בגיל פרישה?",
        correctAnswer: "כמיליון ש\"ח",
        wrongAnswer: "כ-500,000 ש\"ח",
        explanation: "כוח הריבית דריבית לאורך שנים רבות"
    },
    {
        question: "🛡️ קרן חירום אידיאלית צריכה לכסות כמה חודשי הוצאות?",
        correctAnswer: "3-6 חודשים",
        wrongAnswer: "חודש אחד בלבד",
        explanation: "3-6 חודשים מאפשרים התמודדות עם משברים פיננסיים"
    },
    {
        question: "📊 הוצאות קבועות לא צריכות לעלות על איזה אחוז מההכנסה החודשית נטו?",
        correctAnswer: "50%",
        wrongAnswer: "70%",
        explanation: "מגבלת 50% מאפשרת גמישות כלכלית וחיסכון"
    },
    {
        question: "🔑 מה מהבאים הוא מפתח ליציבות פיננסית?",
        correctAnswer: "הימנעות מהלוואות צרכניות בריבית גבוהה",
        wrongAnswer: "לקיחת הלוואות לצורך השקעות מהירות",
        explanation: "הלוואות בריבית גבוהה שוחקות את ההכנסה הפנויה"
    },
    {
        question: "🏷️ רכישת מוצרים משומשים יכולה לחסוך עד כמה אחוזים מעלותם החדשה?",
        correctAnswer: "עד 70%",
        wrongAnswer: "עד 40%",
        explanation: "מוצרים משומשים במצב טוב יכולים לחסוך עד 70% מהעלות"
    },
    {
        question: "🚗 מה נכון לגבי ליסינג תפעולי לרכב בהשוואה לרכישה ישירה?",
        correctAnswer: "לרוב יקר יותר בטווח הארוך",
        wrongAnswer: "תמיד משתלם יותר מרכישה ישירה",
        explanation: "עלות הליסינג המצטברת לאורך זמן גבוהה מרכישה"
    },
    {
        question: "👵 מה נכון לגבי הפרשה לפנסיה?",
        correctAnswer: "הפרשה בגיל מוקדם מגדילה משמעותית את החיסכון הסופי",
        wrongAnswer: "עדיף להתחיל להפריש לפנסיה רק אחרי גיל 40",
        explanation: "ככל שמתחילים מוקדם יותר, כך גדל החיסכון הסופי"
    },
    {
        question: "📝 בדיקה של ההוצאות החודשיות אחת לרבעון יכולה לחסוך כמה כסף?",
        correctAnswer: "מאות שקלים",
        wrongAnswer: "עשרות שקלים בלבד",
        explanation: "זיהוי הוצאות מיותרות וחיסכון בהוצאות קבועות"
    }
];
        
        // Total months of simulation - extended game time
        const totalMonths = 24; // March 2025 to March 2027
        const monthNames = [
            "מרץ 2025", "אפריל 2025", "מאי 2025", "יוני 2025", "יולי 2025", 
            "אוגוסט 2025", "ספטמבר 2025", "אוקטובר 2025", "נובמבר 2025", "דצמבר 2025",
            "ינואר 2026", "פברואר 2026", "מרץ 2026", "אפריל 2026", "מאי 2026", 
            "יוני 2026", "יולי 2026", "אוגוסט 2026", "ספטמבר 2026", "אוקטובר 2026", 
            "נובמבר 2026", "דצמבר 2026", "ינואר 2027", "פברואר 2027", "מרץ 2027"
        ];
        
        // Month duration increased to 5 minutes per month (300 seconds)
        const monthDuration = 300; // 5 minutes (300 seconds) per month
        const framesPerSecond = 60;
        const frameTime = 1000 / framesPerSecond;
        const framesPerMonth = monthDuration * framesPerSecond;
        let currentMonthTimer = 0;

        // Monthly counters to limit obstacle and powerup appearances
let monthlyObstacleCounter = {
    person: 0,
    ad: 0,
    food: 0,
    thought: 0,
    companion_msg: 0,
    financial_question: 0
};

let monthlyPowerupCounter = {
    money: 0,
    earlyRise: 0,
    earlySleep: 0,
    healthyFood: 0,
    exercise: 0,
    companion: 0
};
      
        // Power-up variables
        const maxPowerUpTime = 900; // 15 seconds at 60fps
        let gameMessage = '';
        let gameMessageTime = 0;
        
        // Player variables
        const player = {
    x: canvas.width * 0.2,
    y: canvas.height * 0.7,
    width: 50,
    height: 80,
    baseSpeed: 5, // Base speed
    currentSpeed: 5, // Current speed affected by player condition
    powerUp: false,
    powerUpTime: 0,
    powerUpType: '',
    companion: false,
    weight: 1, // Increases with unhealthy food, affects speed
    mentalStrength: 1, // Decreases with negative mental effects, affects speed
    emojiChar: '🙂', // Default player emoji
    companionEmojiChar: null, // Will be set when companion is active
    lastHealthCheck: 0 // To track health changes for emoji updates
};
        
        // Ground variables
        const ground = {
            y: canvas.height * 0.8,
            width: canvas.width,
            height: canvas.height * 0.2
        };
        
        // Current powerup in dialog
        let currentPowerup = null;
        let powerupFollowupQuestions = [];
        let powerupFollowupIndex = 0;
        
        // Arrays for game objects
        let obstacles = [];
        let powerups = [];
        let pendingObstacles = [];  // For delayed creation
        
        // Obstacle dialog variables
        let currentObstacle = null;
        let lastObstacleTime = 0;
        const minObstacleInterval = 5000; // Minimum time between obstacle dialogs (5 seconds)
        let persuasionStage = 0; // Current persuasion stage
        let persuasionTexts = []; // Persuasion texts per obstacle
        
        // Job offer variables
        let jobOfferStage = 0;
        const jobOfferTexts = [
            "האם אתה בטוח שברצונך לדחות הזדמנות זו?",
            "השכר גבוה ב-25% ותנאי הסוציאליים משופרים",
            "ההזדמנות להתפתחות מקצועית משמעותית יותר",
            "העבודה מציעה גמישות רבה יותר בשעות העבודה"
        ];
        
        // Bonus questions for financial bonus powerup
const bonusQuestions = [
    { 
        question: "⏰ האם הגעת לעבודה בזמן כל השבוע?", 
        positiveEffect: "✅ אמינות ודייקנות הם ערכים חשובים למעסיק",
        negativeEffect: "❌ איחורים פוגעים בתדמית המקצועית שלך"
    },
    { 
        question: "📋 האם סיימת את כל המשימות שלך לפני הדדליין?", 
        positiveEffect: "✅ עמידה ביעדים מוכיחה יעילות ומקצועיות",
        negativeEffect: "❌ אי עמידה בזמנים פוגעת בהערכת הביצועים שלך"
    },
    { 
        question: "🤝 האם עזרת לעמיתים לעבודה השבוע?", 
        positiveEffect: "✅ עבודת צוות טובה נלקחת בחשבון בהערכת עובדים",
        negativeEffect: "❌ שיתוף פעולה מוגבל מקטין את הערך שלך לארגון"
    },
    { 
        question: "💡 האם הבאת רעיון חדש או הצעת ייעול לעבודה?", 
        positiveEffect: "✅ יוזמה ויצירתיות מובילות לקידום מקצועי",
        negativeEffect: "❌ פסיביות בעבודה מגבילה את פוטנציאל הקידום שלך"
    },
    { 
        question: "📚 האם השקעת זמן בהרחבת הידע המקצועי שלך?", 
        positiveEffect: "✅ התפתחות אישית מגדילה את ערכך בשוק העבודה",
        negativeEffect: "❌ קיבעון מקצועי מגביל את האפשרויות העתידיות שלך"
    }
];
        
        // Helper for random number generation
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // Show popup message with enhanced visuals
function showPopupMessage(message, duration = 2000) {
    const popup = document.getElementById('popup-message');
    
    // בדיקה אם כבר יש אימוג'י בתחילת ההודעה
    if (!/^\p{Emoji}/u.test(message)) {
        // בחירת אימוג'י אקראי מתאים לפי תוכן ההודעה
        let emoji = "";
        
        if (message.includes("בונוס") || message.includes("תגמול")) {
            emoji = "💰 ";
        } else if (message.includes("עידוד") || message.includes("חבר")) {
            emoji = "👍 ";
        } else if (message.includes("חיזוק פעיל") || message.includes("חיזוק")) {
            emoji = "⚡ ";
        } else if (message.includes("החלטה פיננסית")) {
            emoji = "🧠 ";
        } else if (message.includes("תשובה נכונה")) {
            emoji = "✅ ";
        } else if (message.includes("תשובה שגויה")) {
            emoji = "❌ ";
        } else if (message.includes("השפעת החיזוק הסתיימה")) {
            emoji = "⏱️ ";
        } else if (message.includes("אימצת") || message.includes("אימוץ")) {
            emoji = "💭 ";
        } else {
            // אימוג'ים כלליים למקרה שאין התאמה ספציפית
            const generalEmojis = ["📌", "ℹ️", "🔔", "💬", "📣"];
            emoji = generalEmojis[Math.floor(Math.random() * generalEmojis.length)] + " ";
        }
        
        // הוספת האימוג'י בתחילת ההודעה
        message = emoji + message;
    }
    
    popup.textContent = message;
    popup.style.opacity = '1';
    popup.style.transform = 'translateX(-50%) translateY(-10px)';
    
    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateX(-50%) translateY(0px)';
    }, duration);
}
        
        // Update player's speed based on mental and physical health
        function updatePlayerCondition() {
    // Calculate weight effect (physical health)
    let weightEffect = 1;
    if (stats.physicalHealth < 80) {
        weightEffect = 0.9;
        document.getElementById('status-weight').style.display = 'block';
        document.getElementById('status-weight').textContent = "מצב גופני: ירוד";
    } else if (stats.physicalHealth < 60) {
        weightEffect = 0.7;
        document.getElementById('status-weight').style.display = 'block';
        document.getElementById('status-weight').textContent = "מצב גופני: לקוי";
    } else if (stats.physicalHealth < 40) {
        weightEffect = 0.5;
        document.getElementById('status-weight').style.display = 'block';
        document.getElementById('status-weight').textContent = "מצב גופני: חמור";
    } else {
        document.getElementById('status-weight').style.display = 'none';
    }
    
    // Calculate mental effect
    let mentalEffect = 1;
    if (stats.mentalHealth < 80) {
        mentalEffect = 0.9;
        document.getElementById('status-negative').style.display = 'block';
        document.getElementById('status-negative').textContent = "מצב מנטלי: ירוד";
    } else if (stats.mentalHealth < 60) {
        mentalEffect = 0.7;
        document.getElementById('status-negative').style.display = 'block';
        document.getElementById('status-negative').textContent = "מצב מנטלי: לקוי";
    } else if (stats.mentalHealth < 40) {
        mentalEffect = 0.5;
        document.getElementById('status-negative').style.display = 'block';
        document.getElementById('status-negative').textContent = "מצב מנטלי: חמור";
    } else {
        document.getElementById('status-negative').style.display = 'none';
    }
    
    // Update player speed
player.currentSpeed = player.baseSpeed * weightEffect * mentalEffect;

// Update dashboard speed indicator only
const dashboardSpeedIndicator = document.getElementById('dashboard-speed-indicator');

let speedText, speedClass;

if (player.currentSpeed < player.baseSpeed * 0.6) {
    speedText = 'איטית מאוד';
    speedClass = 'very-slow';
} else if (player.currentSpeed < player.baseSpeed * 0.8) {
    speedText = 'איטית';
    speedClass = 'slow';
} else if (player.currentSpeed < player.baseSpeed * 0.95) {
    speedText = 'בינונית';
    speedClass = 'medium';
} else {
    speedText = 'אופטימלית';
    speedClass = '';
}

// Update dashboard speed indicator
if (dashboardSpeedIndicator) {
    dashboardSpeedIndicator.textContent = speedText;
    
    // Reset classes
    dashboardSpeedIndicator.classList.remove('very-slow', 'slow', 'medium');
    
    // Add appropriate class if needed
    if (speedClass) {
        dashboardSpeedIndicator.classList.add(speedClass);
    }
}
            
            // Update health bars with animation
            const physicalFill = document.getElementById('physical-health-fill');
            const mentalFill = document.getElementById('mental-health-fill');
            
            // Save current width for transition
            const currentPhysicalWidth = parseFloat(physicalFill.style.width) || 100;
            const currentMentalWidth = parseFloat(mentalFill.style.width) || 100;
            
            // Apply smooth transition if significant change
            if (Math.abs(currentPhysicalWidth - stats.physicalHealth) > 5) {
                physicalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { physicalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            if (Math.abs(currentMentalWidth - stats.mentalHealth) > 5) {
                mentalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { mentalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            // Set new values
            physicalFill.style.width = `${stats.physicalHealth}%`;
            mentalFill.style.width = `${stats.mentalHealth}%`;
            
            // Update color based on health level
            if (stats.physicalHealth < 40) {
                physicalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.physicalHealth < 70) {
                physicalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                physicalFill.style.backgroundColor = 'var(--success-color)';
            }
            
            if (stats.mentalHealth < 40) {
                mentalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.mentalHealth < 70) {
                mentalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                mentalFill.style.backgroundColor = 'var(--primary-color)';
            }

            // עדכון מהירות היום בהתאם לבריאות
            updateDaySpeed();
        }

// פונקציה לעדכון האימוג'י של השחקן בהתאם למצב התנועה והבריאות
function updatePlayerEmoji() {
    const healthFactor = stats.physicalHealth / 100;
    const mentalFactor = stats.mentalHealth / 100;
    
    if (!isMoving) {
        // When player isn't moving, always show standing emoji
        const standingEmojis = ["🧍‍♂️", "🧍‍♀️"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    } else if (healthFactor > 0.7 && mentalFactor > 0.7) {
        // Excellent health - running
        const runningEmojis = ["🏃‍♂️", "🏃‍♀️"];
        player.emojiChar = runningEmojis[Math.floor(Math.random() * runningEmojis.length)];
    } else if (healthFactor > 0.4 && mentalFactor > 0.4) {
        // Good health - walking
        const walkingEmojis = ["🚶‍♂️", "🚶‍♀️"];
        player.emojiChar = walkingEmojis[Math.floor(Math.random() * walkingEmojis.length)];
    } else {
        // Poor health - standing
        const standingEmojis = ["🧍‍♂️", "🧍‍♀️"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    }
}

        // עדכון מהירות היום בהתאם לבריאות
function updateDaySpeed() {
    // חישוב תוספת שניות בהתאם לירידה בבריאות
    // בריאות פיזית: כל נקודה מתחת ל-90 מוסיפה 1000 מילישניות (שנייה אחת)
    const physicalHealthPenalty = Math.max(0, 90 - stats.physicalHealth);
    
    // בריאות מנטלית: כל נקודה מתחת ל-90 מוסיפה 1000 מילישניות (שנייה אחת)
    const mentalHealthPenalty = Math.max(0, 90 - stats.mentalHealth);
    
    // חישוב זמן יום נוכחי
    dayMilliseconds.current = dayMilliseconds.perfect + (physicalHealthPenalty + mentalHealthPenalty) * 1000;
}
        
        // Create obstacle with improved visuals
function createObstacle() {
    const types = ['person', 'ad', 'food', 'financial_question'];
    // Filter types that already appeared twice this month
    const availableTypes = types.filter(type => monthlyObstacleCounter[type] < 2);
    
    // If no available types, exit function
    if (availableTypes.length === 0) return;
    
    const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
    
    // Update counter for the selected type
    monthlyObstacleCounter[type]++;
    
    let obstacle;
    
    if (type === 'person') {
        const negativeComments = [
            "קשה לחסוך עם משכורת כמו שלך",
            "אתה לא תצליח להגיע ליציבות פיננסית",
            "רוב האנשים לא מצליחים לחסוך",
            "אתה מפספס הנאות בגלל הקמצנות שלך",
            "חיסכון זה למעמד סוציו-אקונומי גבוה",
            "אף פעם לא תגיע ליעד של 100,000",
            "חיים רק פעם אחת, אל תחסוך ליום סגריר"
        ];
        
        // Persuasive texts for negative people with updated options
        const persuasiveTexts = [
            {
                text: "זה לא אפשרי לחסוך עם משכורת כמו שיש לך",
                acceptOption: "אתה צודק, אחסוך כשארוויח יותר",
                ignoreOption: "חיסכון זה עניין של משמעת, לא רק משכורת"
            },
            {
                text: "נו, ומה תעשה שתגיע ל-100,000 ש״ח?",
                acceptOption: "אין לי באמת תכנית, זה סתם מספר",
                ignoreOption: "אהפוך אותו להשקעה שתבטיח לי חופש כלכלי"
            },
            {
                text: "אף פעם לא תגיע ליעד של 100,000 בחיסכון",
                acceptOption: "ניסיתי בעבר ולא הצלחתי, קשה מדי",
                ignoreOption: "כל חיסכון מקרב אותי ליעד, אתעלם מקולות שליליים"
            }
        ];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 80,
            width: 50,
            height: 80,
            type: type,
            speed: 4 + (currentMonth * 0.1),
            text: negativeComments[getRandomInt(0, negativeComments.length - 1)],
            value: getRandomInt(500, 1000), // Cost if hit
            mentalEffect: getRandomInt(5, 15), // How much it will reduce mental health
            persuasiveTexts: persuasiveTexts,
            obstacleTitle: "בינינו...",
            initialText: "אתה מפספס את החיים בגלל הקמצנות שלך.",
            acceptOption: "אתה צודק, אולי אני באמת מגזים",
            ignoreOption: "אני בונה את העתיד שלי, לא מפספס",
            // Visual properties
            color: "#6c757d",
            animationOffset: Math.random() * Math.PI * 2, // For bobbing animation
            bobSpeed: 0.05 + Math.random() * 0.03
        };
    } else if (type === 'ad') {
        // Persuasive texts for ads - updated for "easy money" theme
        const persuasiveTexts = [
            {
                text: "💸 ההזדמנות הזאת עומדת להיעלם!",
                ignoreOption: "לא תצליח להלחיץ אותי.",
                acceptOption: "אסור לי לפספס את זה!"
            },
            {
                text: "🚀 תיהיה חכם, זה כסף על הרצפה",
                ignoreOption: "אני לא מתרגש",
                acceptOption: "אני חייב את זה!"
            },
            {
                text: "⚠ זאת ההזדמנות שלך לשנות את החיים שלך",
                ignoreOption: "החלטה סופית: אני דוחה את ההצעה",
                acceptOption: "סוף סוף החיים שלי יראו אחרת!"
            }
        ];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 70,
            width: 60,
            height: 70,
            type: type,
            speed: 5 + (currentMonth * 0.15),
            text: "אל תפספס! הזדמנות חייך לייצר הכנסה מכל מקום, בכל זמן, וללא מאמץ!",
            value: getRandomInt(1000, 3000),
            persuasiveTexts: persuasiveTexts,
            obstacleTitle: "📢 רוצה להרוויח כסף קל?",
            initialText: "אל תפספס! הזדמנות חייך לייצר הכנסה מכל מקום, בכל זמן, וללא מאמץ!",
            ignoreOption: "אני לא מתפתה",
            acceptOption: "מעניין אותי!",
            // Visual properties
            color: "#495057",
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.08 + Math.random() * 0.04, // Ads move more erratically
            pulseRate: 0.03 + Math.random() * 0.02 // For pulsing effect
        };
    } else if (type === 'food') {
        const foodTypes = [
            "הזמנת משלוח מול בישול ביתי",
            "קפה ומאפה על הדרך",
            "מזון מהיר לעומת סופר זול",
            "בילוי חברתי שדורש הוצאה כספית"
        ];
        
        // Persuasive texts for food - updated to be more tempting
        const persuasiveTexts = [
            {
                text: "🍕 אתה עובד קשה. מה שווה הכסף שאתה חוסך אם לא תהנה ממנו?",
                ignoreOption: "שליטה עצמית חשובה יותר מפינוק רגעי",
                acceptOption: "אתה צודק, אני צריך ליהנות קצת..."
            },
            {
                text: "🥳 אסור לפספס חוויות בחיים!",
                ignoreOption: "ההנאה שלי היא החוזקה שלי",
                acceptOption: "חוויה שווה את ההוצאה!"
            },
            {
                text: "🍩 זו רק פעם אחת. מחר תחזור לחסוך כרגיל.",
                ignoreOption: "ה'פעם האחת' הזו מצטברת לסכומים גדולים",
                acceptOption: "נכון, פעם אחת לא תשנה כלום"
            }
        ];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 60,
            width: 50,
            height: 60,
            type: type,
            speed: 3 + (currentMonth * 0.1),
            text: foodTypes[getRandomInt(0, foodTypes.length - 1)],
            value: getRandomInt(300, 1200),
            weightEffect: getRandomInt(5, 15), // How much it will reduce physical health
            persuasiveTexts: persuasiveTexts,
            obstacleTitle: "🍔 פינוק קטן לא יפיל אותך, נכון?",
            initialText: "יום ארוך ומתיש עבר עליך, ואין לך כוח לבשל.",
            ignoreOption: "אני נשאר חזק – מבשל ואוכל בבית", 
            acceptOption: "יאללה, מגיע לי פינוק – מזמין משלוח",
            // Visual properties
            color: "#6c757d",
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.04 + Math.random() * 0.02, // Food moves more slowly
            rotationSpeed: Math.random() * 0.01 // Slight rotation
        };
    } else if (type === 'financial_question') {
        // בחר שאלה אקראית מהמאגר
        const questionIndex = getRandomInt(0, financialQuestions.length - 1);
        const question = financialQuestions[questionIndex];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 70,
            width: 60,
            height: 70,
            type: type,
            speed: 4 + (currentMonth * 0.1),
            text: question.question,
            value: 1000, // תגמול כספי עבור תשובה נכונה
            questionData: question,
            obstacleTitle: "שאלה פיננסית",
            initialText: question.question,
            // Visual properties
            color: "#3a7a5f", // ירוק
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.05 + Math.random() * 0.03
        };
    }
    
    // בדיקה אם המכשול החדש מתנגש עם אובייקטים קיימים
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // במידת הצורך, שנה את מיקום ה-Y של המכשול
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 100; // שינוי אקראי בגובה בטווח +-50 פיקסלים
            obstacle.y = ground.y - obstacle.height - Math.abs(yOffset);
        }
        
        // בדוק אם המיקום החדש פנוי
        validPosition = !isPositionOccupied(obstacle);
        attempts++;
    }
    
    obstacles.push(obstacle);
    
    // Add floating question mark above new financial question obstacle
    if (type === 'financial_question') {
        const questionMark = document.createElement('div');
        questionMark.className = 'floating-question-mark';
        questionMark.style.position = 'absolute';
        questionMark.style.fontSize = '24px';
        questionMark.style.fontWeight = 'bold';
        questionMark.style.color = '#3a7a5f';
        questionMark.style.textShadow = '0 0 8px rgba(58, 122, 95, 0.6)';
        questionMark.style.top = `${obstacle.y - 25}px`;
        questionMark.style.left = `${obstacle.x + obstacle.width/2}px`;
        questionMark.style.transform = 'translateX(-50%)';
        questionMark.style.zIndex = '20';
        questionMark.style.opacity = '0';
        questionMark.textContent = '?';
        
        document.getElementById('game-container').appendChild(questionMark);
        
        // Define animation
        const animStyle = document.createElement('style');
        animStyle.textContent = `
            @keyframes float-question-${Date.now()} {
                0% { transform: translateX(-50%) translateY(0); opacity: 0; }
                20% { transform: translateX(-50%) translateY(-10px); opacity: 1; }
                80% { transform: translateX(-50%) translateY(-10px); opacity: 1; }
                100% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            }
        `;
        document.head.appendChild(animStyle);
        
        // Apply animation
        questionMark.style.animation = `float-question-${Date.now()} 3s ease-out forwards`;
        
        // Remove after animation
        setTimeout(() => {
            if (questionMark.parentNode) {
                questionMark.parentNode.removeChild(questionMark);
            }
            if (animStyle.parentNode) {
                animStyle.parentNode.removeChild(animStyle);
            }
        }, 3000);
    }
    
    // Show subtle visual cue for obstacle approach
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.right = '0';
    flash.style.top = `${obstacle.y}px`;
    flash.style.width = '10px';
    flash.style.height = `${obstacle.height}px`;
    flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    flash.style.borderRadius = '5px 0 0 5px';
    flash.style.zIndex = '8';
    flash.style.animation = 'flash-warning 0.5s ease forwards';
    
    document.getElementById('game-container').appendChild(flash);
    
    // Define the animation keyframes
    const style = document.createElement('style');
    style.textContent = `
        @keyframes flash-warning {
            0% { opacity: 0.8; }
            100% { opacity: 0; right: 10px; }
        }
    `;
    document.head.appendChild(style);
    
    // Remove the flash element after animation
    setTimeout(() => {
        if (flash.parentNode) {
            flash.parentNode.removeChild(flash);
        }
    }, 500);
}
        
        // Create powerup with enhanced visuals
function createPowerup() {
    // הסר 'money' מהסוגים הרגילים
    const types = ['earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
    
    // בדוק אם אפשר להוסיף בונוס כספי (פעם בחודש)
    if (currentMonth > 0 && monthlyPowerupCounter['money'] === 0) {
        // 20% סיכוי להוסיף בונוס כספי
        if (Math.random() < 0.2) {
            types.push('money');
        }
    }
    
    // Filter types that already appeared twice this month
    const availableTypes = types.filter(type => monthlyPowerupCounter[type] < 2);
    
    // If no available types, exit function
    if (availableTypes.length === 0) return;
    
    const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
    
    // Update counter for the selected type
    monthlyPowerupCounter[type]++;
    
    let text = '';
    let width = 40;
    let height = 40;
    let value = 1000;
    let color = '';
    
    switch(type) {
        case 'money':
            text = "בונוס כספי";
            value = getRandomInt(1000, 3000);
            color = "#2a6496"; // Blue
            break;
        case 'earlyRise':
            text = "קימה מוקדמת";
            color = "#3a7a5f"; // Green
            break;
                case 'earlySleep':
                    text = "שינה מוקדמת";
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "תזונה בריאה";
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "פעילות גופנית";
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
                x: canvas.width,
                y: getRandomInt(ground.y - 150, ground.y - 60),
                width: width,
                height: height,
                type: type,
                speed: 4, // Slower speed for longer game
                text: text,
                value: value,
                healthEffect: type === 'healthyFood' || type === 'exercise' ? 10 : 0, // Improve physical health
                mentalEffect: type === 'earlySleep' || type === 'earlyRise' ? 10 : 0, // Improve mental health
                color: color,
                animationOffset: Math.random() * Math.PI * 2, // For floating animation
                floatSpeed: 0.03 + Math.random() * 0.02,
                floatRange: 10 + Math.random() * 5, // How far it floats up/down
                glowing: true, // Add glow effect
                originalY: 0 // Store original Y for floating animation
            };
            
            // Store original Y for floating animation
    powerup.originalY = powerup.y;
    
    // בדיקה אם הפאוור-אפ החדש מתנגש עם אובייקטים קיימים
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // במידת הצורך, שנה את מיקום ה-Y של הפאוור-אפ
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 120; // שינוי אקראי בגובה 
            powerup.y = getRandomInt(ground.y - 150, ground.y - 60) + yOffset;
            powerup.originalY = powerup.y; // עדכון ה-originalY גם כן
        }
        
        // בדוק אם המיקום החדש פנוי
        validPosition = !isPositionOccupied(powerup);
        attempts++;
    }
    
    powerups.push(powerup);
            
            // Show subtle visual cue for powerup approach
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '10px';
            flash.style.height = `${powerup.height}px`;
            flash.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
            flash.style.borderRadius = '5px 0 0 5px';
            flash.style.zIndex = '8';
            flash.style.animation = 'flash-powerup 0.5s ease forwards';
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define the animation keyframes if not already defined
            if (!document.getElementById('powerup-flash-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-flash-style';
                style.textContent = `
                    @keyframes flash-powerup {
                        0% { opacity: 0.8; }
                        100% { opacity: 0; right: 10px; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the flash element after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 500);
        }
        // Create companion with enhanced visuals
function createCompanion() {
    // Check if companion already appeared twice this month
    if (monthlyPowerupCounter.companion >= 2) return;
    
    // Update companion counter
    monthlyPowerupCounter.companion++;
    
    const companion = {
        x: canvas.width,
        y: ground.y - 70,
        width: 40,
        height: 70,
        speed: 4,
        type: 'companion',
        text: "תמיכה חברתית בדרך הפיננסית",
        color: "#2a6496", // Blue
        animationOffset: Math.random() * Math.PI * 2,
        floatSpeed: 0.02,
        floatRange: 5,
        originalY: ground.y - 70,
        glowing: true,
        emitParticles: true // Special effect for companions
    };
    
    // בדיקה אם המלווה החדש מתנגש עם אובייקטים קיימים
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // במידת הצורך, שנה את מיקום ה-Y של המלווה
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 80; // שינוי אקראי בגובה בטווח קטן יותר
            companion.y = ground.y - 70 + yOffset;
            companion.originalY = companion.y; // עדכון ה-originalY גם כן
        }
        
        // בדוק אם המיקום החדש פנוי
        validPosition = !isPositionOccupied(companion);
        attempts++;
    }
    
    powerups.push(companion);
    showPopupMessage("תמיכה חברתית מתקרבת!", 2000);
            
            // Add sound or visual cue for companion
            const companionAlert = document.createElement('div');
            companionAlert.style.position = 'absolute';
            companionAlert.style.top = '50%';
            companionAlert.style.left = '50%';
            companionAlert.style.transform = 'translate(-50%, -50%)';
            companionAlert.style.color = 'white';
            companionAlert.style.fontSize = '24px';
            companionAlert.style.padding = '15px 30px';
            companionAlert.style.borderRadius = '8px';
            companionAlert.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
            companionAlert.style.zIndex = '50';
            companionAlert.style.animation = 'companion-alert 1.5s forwards';
            companionAlert.textContent = '👫 תמיכה חברתית מתקרבת!';
            
            document.getElementById('game-container').appendChild(companionAlert);
            
            // Add animation style if not already present
            if (!document.getElementById('companion-alert-style')) {
                const style = document.createElement('style');
                style.id = 'companion-alert-style';
                style.textContent = `
                    @keyframes companion-alert {
                        0% { opacity: 0; transform: translate(-50%, -70%); }
                        20% { opacity: 1; transform: translate(-50%, -50%); }
                        80% { opacity: 1; transform: translate(-50%, -50%); }
                        100% { opacity: 0; transform: translate(-50%, -30%); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the alert element after animation
            setTimeout(() => {
                if (companionAlert.parentNode) {
                    companionAlert.parentNode.removeChild(companionAlert);
                }
            }, 1500);
        }
        
        // Show powerup dialog with enhanced animation
function showPowerupDialog(powerup) {
    gamePaused = true;
    isMoving = false; // עצירת התנועה באופן מוחלט
    currentPowerup = powerup;
    powerupFollowupIndex = 0;
    
    // Set question based on powerup type
let question = "";
const powerupTitle = document.getElementById('powerup-title');
const ignoreBtn = document.getElementById('powerup-no-btn');
const acceptBtn = document.getElementById('powerup-yes-btn');

switch(powerup.type) {
    case 'exercise':
        powerupTitle.textContent = "🏋️ שאלת ידע: פעילות גופנית";
        question = "כיצד פעילות גופנית סדירה תורמת ליציבות פיננסית?";
        
        // ערבוב סדר האפשרויות באופן אקראי
        if(Math.random() < 0.5) {
            acceptBtn.textContent = "מספקת חוסן מנטלי לעמוד מול פיתויים כלכליים";
            ignoreBtn.textContent = "אין קשר בין פעילות גופנית להתנהלות פיננסית";
            powerup.correctButton = 'powerup-yes-btn';
        } else {
            acceptBtn.textContent = "אין קשר בין פעילות גופנית להתנהלות פיננסית";
            ignoreBtn.textContent = "מספקת חוסן מנטלי לעמוד מול פיתויים כלכליים";
            powerup.correctButton = 'powerup-no-btn';
        }
        
        powerup.explanation = "פעילות גופנית מחזקת את היכולת להתמודד עם לחצים ולהימנע מהוצאות אימפולסיביות";
        powerupFollowupQuestions = [];
        break;
    case 'healthyFood':
        powerupTitle.textContent = "🥗 שאלת ידע: תזונה בריאה";
        question = "למה תזונה בריאה עוזרת לחסוך כסף?";
        
        if(Math.random() < 0.5) {
            acceptBtn.textContent = "מונעת הוצאות רפואיות עתידיות ומפחיתה אכילה רגשית";
            ignoreBtn.textContent = "כדי לקנות מוצרים אורגניים יקרים ותוספי תזונה יוקרתיים";
            powerup.correctButton = 'powerup-yes-btn';
        } else {
            acceptBtn.textContent = "כדי לקנות מוצרים אורגניים יקרים ותוספי תזונה יוקרתיים";
            ignoreBtn.textContent = "מונעת הוצאות רפואיות עתידיות ומפחיתה אכילה רגשית";
            powerup.correctButton = 'powerup-no-btn';
        }
        
        powerup.explanation = "תזונה בריאה משפרת בריאות לטווח ארוך ומפחיתה הוצאות על טיפולים רפואיים";
        powerupFollowupQuestions = [];
        break;
        case 'earlyRise':
    powerupTitle.textContent = "🌅 שאלת ידע: קימה מוקדמת";
    question = "איזו השפעה יש לקימה מוקדמת על התנהלות פיננסית?";
    
    if(Math.random() < 0.5) {
        acceptBtn.textContent = "מספקת זמן לתכנון יומי ובניית הרגלי חיסכון";
        ignoreBtn.textContent = "אין קשר בין שעת הקימה להתנהלות הפיננסית";
        powerup.correctButton = 'powerup-yes-btn';
    } else {
        acceptBtn.textContent = "אין קשר בין שעת הקימה להתנהלות הפיננסית";
        ignoreBtn.textContent = "מספקת זמן לתכנון יומי ובניית הרגלי חיסכון";
        powerup.correctButton = 'powerup-no-btn';
    }
    
    powerup.explanation = "קימה מוקדמת מונעת לחצים של זמן שגורמים להוצאות לא מחושבות";
    powerupFollowupQuestions = [];
    break;
case 'earlySleep':
    powerupTitle.textContent = "😴 שאלת ידע: שינה מספקת";
    question = "כיצד שינה מספקת משפיעה על החלטות פיננסיות?";
    
    if(Math.random() < 0.5) {
        acceptBtn.textContent = "מבטיחה מוח צלול לקבלת החלטות פיננסיות מחושבות";
        ignoreBtn.textContent = "לא משפיעה כלל - החלטות פיננסיות הן תמיד רציונליות";
        powerup.correctButton = 'powerup-yes-btn';
    } else {
        acceptBtn.textContent = "לא משפיעה כלל - החלטות פיננסיות הן תמיד רציונליות";
        ignoreBtn.textContent = "מבטיחה מוח צלול לקבלת החלטות פיננסיות מחושבות";
        powerup.correctButton = 'powerup-no-btn';
    }
    
    powerup.explanation = "שינה איכותית מאפשרת חשיבה בהירה ומפחיתה קניות אימפולסיביות";
    powerupFollowupQuestions = [];
    break;
case 'money':
    powerupTitle.textContent = "💼 הערכת ביצועים תעסוקתית";
    question = "האם נתת סיבה החודש למנהל שלך לתת לך בונוס כספי?";
    // Set followup questions for bonus
    powerupFollowupQuestions = [...bonusQuestions];
    // Shuffle the questions to get random ones each time
    for (let i = powerupFollowupQuestions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [powerupFollowupQuestions[i], powerupFollowupQuestions[j]] = 
        [powerupFollowupQuestions[j], powerupFollowupQuestions[i]];
    }
    // Limit to 3 random questions
    powerupFollowupQuestions = powerupFollowupQuestions.slice(0, 3);
    
    // Reset button text
    acceptBtn.textContent = "כן";
    ignoreBtn.textContent = "לא";
    break;
case 'companion':
    powerupTitle.textContent = "👫 שאלת ידע: תמיכה חברתית";
    question = "מדוע חשוב שיהיה איתך חבר בדרך למטרות הפיננסיות שלך?";
    
    if(Math.random() < 0.5) {
        acceptBtn.textContent = "הצורך בהוצאות רגשיות ופיצויים עצמיים יורד משמעותית";
        ignoreBtn.textContent = "כדי שיהיה עם מי לבזבז כסף ולהשוויץ ברכישות חדשות";
        powerup.correctButton = 'powerup-yes-btn';
    } else {
        acceptBtn.textContent = "כדי שיהיה עם מי לבזבז כסף ולהשוויץ ברכישות חדשות";
        ignoreBtn.textContent = "הצורך בהוצאות רגשיות ופיצויים עצמיים יורד משמעותית";
        powerup.correctButton = 'powerup-no-btn';
    }
    
    powerup.explanation = "ליווי חברתי מחזק את היכולת לדחות סיפוקים ומונע בזבוז מיותר על פיצויים רגשיים";
    powerupFollowupQuestions = [];
    break;
    }
    
    // Set dialog content
    document.getElementById('powerup-text').textContent = question;
    
    // Add special styling based on powerup type
    const dialogBox = document.getElementById('powerup-dialog');
    
    // Reset any previous custom styling
    dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
    
    // Add type-specific styling
    switch(powerup.type) {
        case 'exercise':
            dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
            break;
        case 'healthyFood':
            dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)';
            break;
        case 'money':
            dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.3)';
            break;
        case 'companion':
            dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.4)';
            break;
    }
    
    // יצירת שכבת האפלה מאחורי הדיאלוג
    const dialogOverlay = createDialogOverlay();
    currentPowerup.dialogOverlay = dialogOverlay;
    
    // שינוי ה־z-index כדי להבטיח שהדיאלוג יהיה מעל שכבת האפלה
    dialogBox.style.zIndex = '100';
    
    // Show dialog
    dialogBox.style.display = 'block';
}
        
        // Handle powerup yes response
function powerupYesResponse() {
    if (!currentPowerup) return;
    
    // If this is a bonus with followup questions
    if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
        // Show positive feedback
        showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].positiveEffect, 2500);
        
        // Show next question
        const questionText = document.getElementById('powerup-text');
        questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
        
        // Reset button text for followup questions
        document.getElementById('powerup-yes-btn').textContent = "כן";
        document.getElementById('powerup-no-btn').textContent = "לא";
        
        powerupFollowupIndex++;
        return;
    }
    
    // Check if the answer is correct (for all except money)
    if (currentPowerup.type !== 'money' && currentPowerup.correctButton) {
        if (currentPowerup.correctButton === 'powerup-yes-btn') {
            // Answer is correct
            showPopupMessage("תשובה נכונה!", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // Apply the powerup effect based on the type
            stats.powerupsCollected++;
            
            // Apply power-up effects after showing feedback
            setTimeout(() => {
                applyPowerupEffect(currentPowerup);
            }, 1000);
        } else {
            // Answer is wrong
            showPopupMessage("תשובה שגויה", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // No power-up benefit for wrong answer
        }
        
        // הסרת שכבת האפלה
        if (currentPowerup && currentPowerup.dialogOverlay) {
            if (currentPowerup.dialogOverlay.parentNode) {
                currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
            }
        }
        
        // Hide dialog
        const dialogBox = document.getElementById('powerup-dialog');
        dialogBox.style.display = 'none';
        currentPowerup = null;
        gamePaused = false;
        
        // Update display
        updatePlayerCondition();
        updateDisplay();
        
        return;
    }
    
    // Apply the powerup effect based on the type for money
    stats.powerupsCollected++;
    
    if (currentPowerup.type === 'money') {
        let bonusAmount = currentPowerup.value;
        // If player answered followup questions, provide bigger bonus
        if (powerupFollowupQuestions.length > 0) {
            bonusAmount = Math.round(bonusAmount * (1 + 0.2 * powerupFollowupIndex));
        }
        
        score += bonusAmount;
        stats.income += bonusAmount / 5; // Distribute the bonus over time
        
        // Enhance the bonus popup with animation
        showCoinAnimation(bonusAmount);
        showPopupMessage(`קיבלת בונוס של ${bonusAmount} ש"ח!`, 2000);
    }
    
    // הסרת שכבת האפלה
    if (currentPowerup && currentPowerup.dialogOverlay) {
        if (currentPowerup.dialogOverlay.parentNode) {
            currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
        }
    }
    
    // Hide dialog
    const dialogBox = document.getElementById('powerup-dialog');
    dialogBox.style.display = 'none';
    currentPowerup = null;
    gamePaused = false;
    
    // Update display
    updatePlayerCondition();
    updateDisplay();
}

// Apply power-up effect (helper function)
function applyPowerupEffect(powerup) {
    switch(powerup.type) {
        case 'earlyRise':
        case 'earlySleep':
            player.powerUp = true;
            player.powerUpTime = maxPowerUpTime;
            player.powerUpType = powerup.type;
            document.getElementById('power-meter').style.display = 'block';
            
            // Improve mental health
            stats.mentalHealth = Math.min(100, stats.mentalHealth + powerup.mentalEffect);
            
            // Enhanced visual effect
            showMentalBoostEffect();
            showPopupMessage(`חיזוק פעיל: ${powerup.type === 'earlyRise' ? 'ניהול זמן יעיל' : 'הרגלי שינה טובים'}`, 2000);
            break;
        case 'healthyFood':
        case 'exercise':
            player.powerUp = true;
            player.powerUpTime = maxPowerUpTime;
            player.powerUpType = powerup.type;
            document.getElementById('power-meter').style.display = 'block';
            
            // Improve physical health
            stats.physicalHealth = Math.min(100, stats.physicalHealth + powerup.healthEffect);
            
            // Enhanced visual effect
            showPhysicalBoostEffect();
            showPopupMessage(`חיזוק פעיל: ${powerup.type === 'healthyFood' ? 'תזונה מאוזנת' : 'כושר גופני'}`, 2000);
            break;
        case 'companion':
            player.companion = true;
            player.powerUp = true;
            player.powerUpTime = maxPowerUpTime * 2; // Companion lasts longer
            player.powerUpType = 'companion';
            document.getElementById('power-meter').style.display = 'block';
            
            // Companion helps with both mental and physical health
            stats.mentalHealth = Math.min(100, stats.mentalHealth + 15);
            stats.physicalHealth = Math.min(100, stats.physicalHealth + 15);
            
            // Enhanced visual effect
            showCompanionJoinEffect();
            showPopupMessage("תמיכה חברתית מחזקת את החוסן האישי!", 2500);
            break;
    }
}
        
        // Helper function for coin animation
        function showCoinAnimation(amount) {
            // Create 5-10 animated coins based on amount size
            const coinCount = Math.min(10, Math.max(5, Math.floor(amount / 500)));
            
            for (let i = 0; i < coinCount; i++) {
                const coin = document.createElement('div');
                coin.className = 'animated-coin';
                
                // Style the coin
                coin.style.position = 'absolute';
                coin.style.width = '30px';
                coin.style.height = '30px';
                coin.style.borderRadius = '50%';
                coin.style.backgroundColor = '#FFD700';
                coin.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.7)';
                coin.style.zIndex = '30';
                coin.style.display = 'flex';
                coin.style.justifyContent = 'center';
                coin.style.alignItems = 'center';
                coin.style.color = '#333';
                coin.style.fontWeight = 'bold';
                coin.style.fontSize = '16px';
                coin.textContent = '₪';
                
                // Position at center of screen initially
                coin.style.top = '50%';
                coin.style.left = '50%';
                
                // Add to game container
                document.getElementById('game-container').appendChild(coin);
                
                // Animate coin
                const randomX = Math.random() * 200 - 100; // -100 to 100
                const randomY = Math.random() * 100 - 150; // -150 to -50 (upward)
                const randomDelay = Math.random() * 200;
                
                // Create dynamic keyframes for each coin
                const keyframes = `
                    @keyframes coin-move-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        10% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 1;
                        }
                        60% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY}px)) scale(1);
                            opacity: 1;
                        }
                        100% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY - 50}px)) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific coin
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    coin.style.animation = `coin-move-${i} 1.5s ease-out forwards`;
                }, randomDelay);
                
                // Remove coin after animation
                setTimeout(() => {
                    if (coin.parentNode) {
                        coin.parentNode.removeChild(coin);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, 1800 + randomDelay);
            }
            
            // Show total amount animation
            const totalAmount = document.createElement('div');
            totalAmount.className = 'total-bonus';
            totalAmount.style.position = 'absolute';
            totalAmount.style.top = '40%';
            totalAmount.style.left = '50%';
            totalAmount.style.transform = 'translate(-50%, -50%)';
            totalAmount.style.fontSize = '36px';
            totalAmount.style.fontWeight = 'bold';
            totalAmount.style.color = '#FFD700';
            totalAmount.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            totalAmount.style.zIndex = '31';
            totalAmount.style.opacity = '0';
            totalAmount.textContent = `+${amount} ₪`;
            
            document.getElementById('game-container').appendChild(totalAmount);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes total-bonus-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation with delay
            setTimeout(() => {
                totalAmount.style.animation = 'total-bonus-anim 2s ease-out forwards';
            }, 300);
            
            // Remove elements after animation
            setTimeout(() => {
                if (totalAmount.parentNode) {
                    totalAmount.parentNode.removeChild(totalAmount);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
        }
        
        // Mental boost visual effect
        function showMentalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'mental-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(42, 100, 150, 0.3) 0%, rgba(42, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes mental-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'mental-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Physical boost visual effect
        function showPhysicalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'physical-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(58, 122, 95, 0.3) 0%, rgba(58, 122, 95, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes physical-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'physical-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Companion join visual effect
        function showCompanionJoinEffect() {
            // Create multiple particles effect
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'companion-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
                particle.style.zIndex = '25';
                
                // Position around player
                particle.style.top = `${player.y + player.height / 2}px`;
                particle.style.left = `${player.x + player.width / 2}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create dynamic animation for each particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const duration = 0.8 + Math.random() * 0.7;
                const delay = Math.random() * 0.3;
                const size = 5 + Math.random() * 10;
                
                // Update size
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // Create specific keyframes for this particle
                const keyframes = `
                    @keyframes companion-particle-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        20% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 0.8;
                        }
                        100% {
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific particle
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    particle.style.animation = `companion-particle-${i} ${duration}s ease-out forwards`;
                }, delay * 1000);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, (delay + duration + 0.1) * 1000);
            }
            
            // Add companion icon
            const icon = document.createElement('div');
            icon.className = 'companion-icon';
            icon.style.position = 'absolute';
            icon.style.top = `${player.y - 40}px`;
            icon.style.left = `${player.x + player.width / 2}px`;
            icon.style.transform = 'translate(-50%, -50%)';
            icon.style.fontSize = '30px';
            icon.style.opacity = '0';
            icon.style.zIndex = '26';
            icon.textContent = '👫';
            
            document.getElementById('game-container').appendChild(icon);
            
            // Define animation for icon
            const iconStyle = document.createElement('style');
            iconStyle.textContent = `
                @keyframes companion-icon-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -80px) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -100px) scale(0.8); }
                }
            `;
            document.head.appendChild(iconStyle);
            
            // Apply animation
            icon.style.animation = 'companion-icon-anim 2s ease-out forwards';
            
            // Remove icon after animation
            setTimeout(() => {
                if (icon.parentNode) {
                    icon.parentNode.removeChild(icon);
                }
                if (iconStyle.parentNode) {
                    iconStyle.parentNode.removeChild(iconStyle);
                }
            }, 2000);
        }
        // Handle powerup no response
function powerupNoResponse() {
    if (!currentPowerup) return;
    
    // If this is a bonus with followup questions
    if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
        // Show negative feedback
        showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].negativeEffect, 2500);
        
        // Show next question
        const questionText = document.getElementById('powerup-text');
        questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
        
        // Reset button text for followup questions
        document.getElementById('powerup-yes-btn').textContent = "כן";
        document.getElementById('powerup-no-btn').textContent = "לא";
        
        powerupFollowupIndex++;
        return;
    }
    
    // Check if the answer is correct (for all except money)
    if (currentPowerup.type !== 'money' && currentPowerup.correctButton) {
        if (currentPowerup.correctButton === 'powerup-no-btn') {
            // Answer is correct
            showPopupMessage("תשובה נכונה!", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // Apply the powerup effect based on the type
            stats.powerupsCollected++;
            
            // Apply power-up effects after showing feedback
            setTimeout(() => {
                applyPowerupEffect(currentPowerup);
            }, 1000);
        } else {
            // Answer is wrong
            showPopupMessage("תשובה שגויה", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // Apply negative effect for wrong answer
            switch(currentPowerup.type) {
                case 'exercise':
                case 'healthyFood':
                    // Decrease physical health
                    stats.physicalHealth = Math.max(20, stats.physicalHealth - 10);
                    showNegativePhysicalEffect();
                    break;
                case 'earlyRise':
                case 'earlySleep':
                    // Decrease mental health
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 10);
                    showNegativeMentalEffect();
                    break;
                case 'companion':
                    // Decrease mental health (lighter effect)
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 5);
                    showNegativeMentalEffect();
                    break;
            }
        }
        
        // הסרת שכבת האפלה
        if (currentPowerup && currentPowerup.dialogOverlay) {
            if (currentPowerup.dialogOverlay.parentNode) {
                currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
            }
        }
        
        // Hide dialog
        const dialogBox = document.getElementById('powerup-dialog');
        dialogBox.style.display = 'none';
        currentPowerup = null;
        gamePaused = false;
        
        // Update display
        updatePlayerCondition();
        updateDisplay();
        
        return;
    }
    
    // Apply negative effect based on type for money
    if (currentPowerup.type === 'money') {
        // No bonus for poor performance
        showPopupMessage("פספסת הזדמנות לשיפור מצבך הפיננסי", 2500);
        // Show subtle negative effect
        showMissedOpportunityEffect();
    }
    
    // הסרת שכבת האפלה
    if (currentPowerup && currentPowerup.dialogOverlay) {
        if (currentPowerup.dialogOverlay.parentNode) {
            currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
        }
    }
    
    // Hide dialog
    const dialogBox = document.getElementById('powerup-dialog');
    dialogBox.style.display = 'none';
    currentPowerup = null;
    gamePaused = false;
    
    // Update display
    updatePlayerCondition();
    updateDisplay();
}
        
        // Visual effect for negative physical impact
        function showNegativePhysicalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-physical-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(212, 91, 91, 0.2) 0%, rgba(212, 91, 91, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-physical {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-physical 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for negative mental impact
        function showNegativeMentalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-mental-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(100, 100, 150, 0.2) 0%, rgba(100, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-mental {
                    0% { opacity: 0; }
                    30% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-mental 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for missed opportunity
        function showMissedOpportunityEffect() {
            const effect = document.createElement('div');
            effect.className = 'missed-opportunity';
            effect.style.position = 'absolute';
            effect.style.top = '40%';
            effect.style.left = '50%';
            effect.style.transform = 'translate(-50%, -50%)';
            effect.style.color = 'rgba(150, 150, 150, 0.8)';
            effect.style.fontSize = '40px';
            effect.style.fontWeight = 'bold';
            effect.style.zIndex = '25';
            effect.style.opacity = '0';
            effect.style.textShadow = '0 0 10px rgba(150, 150, 150, 0.5)';
            effect.innerHTML = '<span style="text-decoration: line-through;">₪</span>';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes missed-opportunity {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'missed-opportunity 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Handle applying powerup directly
// For modern gameplay with interaction, show dialog instead of direct application
function applyPowerup(powerup) {
    // Reset button text before showing dialog
    resetPowerupDialogButtons();
    
    // For modern gameplay with interaction, show dialog instead of direct application
    showPowerupDialog(powerup);
    return;
}
        
        // Show obstacle dialog with enhanced animation
function showObstacleDialog(obstacle) {
    // Pause the game
    gamePaused = true;
    isMoving = false; // עצירת התנועה באופן מוחלט
    currentObstacle = obstacle;
    persuasionStage = 0; // Reset persuasion stage
    
    // Set dialog content - initial stage
    document.getElementById('obstacle-title').textContent = obstacle.obstacleTitle;
    document.getElementById('obstacle-text').textContent = obstacle.initialText;
    
    // Change button text based on obstacle type
    if (obstacle.type === 'thought') {
        // For thought obstacles, show only one button with custom text
document.getElementById('ignore-btn').style.display = "none"; // הסתרת כפתור ימני
document.getElementById('accept-btn').textContent = obstacle.acceptOption || "אימוץ המחשבה";
document.getElementById('accept-btn').style.width = "100%"; // הרחבת הכפתור הנשאר
document.getElementById('accept-btn').style.backgroundColor = "var(--primary-color)"; // שמירה על צבע אחיד
    } else if (obstacle.type === 'companion_msg') {
        // For companion messages, also show only one button
document.getElementById('ignore-btn').style.display = "none";
document.getElementById('accept-btn').textContent = "תודה על העידוד!";
document.getElementById('accept-btn').style.width = "100%";
document.getElementById('accept-btn').style.backgroundColor = "var(--primary-color)"; // שמירה על צבע אחיד
    } else if (obstacle.type === 'financial_question') {
        // For financial questions, change button text to the answer options
        const question = obstacle.questionData;
        
        // Randomize which button gets the correct answer
        if (Math.random() < 0.5) {
            document.getElementById('ignore-btn').textContent = question.correctAnswer;
            document.getElementById('accept-btn').textContent = question.wrongAnswer;
            // Mark which button has the correct answer
            obstacle.correctButton = 'ignore-btn';
        } else {
            document.getElementById('ignore-btn').textContent = question.wrongAnswer;
            document.getElementById('accept-btn').textContent = question.correctAnswer;
            // Mark which button has the correct answer
            obstacle.correctButton = 'accept-btn';
        }
    } else {
        // For regular obstacles with custom button text
        if (obstacle.ignoreOption && obstacle.acceptOption) {
            document.getElementById('ignore-btn').textContent = obstacle.ignoreOption;
            document.getElementById('accept-btn').textContent = obstacle.acceptOption;
        } else {
            // Fallback to default text
            document.getElementById('ignore-btn').textContent = "סירוב";
            document.getElementById('accept-btn').textContent = "הסכמה";
        }
    }
    
    // Enhanced visual styling based on obstacle type
    const dialogBox = document.getElementById('obstacle-dialog');
    
    // Reset any previous custom styling
    dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
    
    // Add type-specific styling
    switch(obstacle.type) {
        case 'person':
            dialogBox.style.boxShadow = '0 5px 20px rgba(100, 100, 150, 0.3)';
            break;
        case 'ad':
            dialogBox.style.boxShadow = '0 5px 20px rgba(73, 80, 87, 0.3)';
            break;
        case 'food':
            dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
            break;
        case 'thought':
            dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)';
            break;
        case 'companion_msg':
            dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.3)';
            break;
        case 'financial_question':
            dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)'; // ירוק לשאלות פיננסיות
            break;
    }
    
    // יצירת שכבת האפלה מאחורי הדיאלוג
    const dialogOverlay = createDialogOverlay();
    currentObstacle.dialogOverlay = dialogOverlay;
    
    // שינוי ה־z-index כדי להבטיח שהדיאלוג יהיה מעל שכבת האפלה
    dialogBox.style.zIndex = '100';
    
    // Show dialog
    dialogBox.style.display = 'block';
    
    // Add appropriate overlay effect based on type
    let overlayColor = 'rgba(200, 50, 50, 0.1)'; // Default red for negative obstacles
    
    // Change color for positive obstacles
    if (obstacle.type === 'thought') {
        overlayColor = 'rgba(58, 122, 95, 0.1)'; // Green for thoughts
    } else if (obstacle.type === 'companion_msg') {
        overlayColor = 'rgba(42, 100, 150, 0.1)'; // Blue for companion messages
    } else if (obstacle.type === 'financial_question') {
        overlayColor = 'rgba(58, 122, 95, 0.1)'; // Green for financial questions
    }
    
    const warningOverlay = document.createElement('div');
    warningOverlay.className = 'warning-overlay';
    warningOverlay.style.position = 'absolute';
    warningOverlay.style.top = '0';
    warningOverlay.style.left = '0';
    warningOverlay.style.width = '100%';
    warningOverlay.style.height = '100%';
    warningOverlay.style.backgroundColor = overlayColor;
    warningOverlay.style.opacity = '0';
    warningOverlay.style.transition = 'opacity 0.5s ease';
    warningOverlay.style.zIndex = '15';
    warningOverlay.style.pointerEvents = 'none';
    
    document.getElementById('game-container').appendChild(warningOverlay);
    
    // Fade in the overlay
    setTimeout(() => {
        warningOverlay.style.opacity = '1';
    }, 100);
    
    // Store reference to remove later
    currentObstacle.warningOverlay = warningOverlay;
    
    // Add an icon animation near the obstacle position
    if (obstacle.x && obstacle.y) {
        const iconElement = document.createElement('div');
        iconElement.className = 'obstacle-icon';
        iconElement.style.position = 'absolute';
        iconElement.style.top = `${obstacle.y - 40}px`;
        iconElement.style.left = `${obstacle.x}px`;
        iconElement.style.fontSize = '24px';
        iconElement.style.zIndex = '16';
        iconElement.style.opacity = '0.9';
        
        // Set icon based on obstacle type
        if (obstacle.type === 'thought') {
            iconElement.textContent = '💭'; // Thought bubble
            iconElement.style.color = '#3a7a5f';
        } else if (obstacle.type === 'companion_msg') {
            iconElement.textContent = '👫'; // Companion
            iconElement.style.color = '#2a6496';
        } else if (obstacle.type === 'financial_question') {
            iconElement.textContent = '❓'; // Question mark
            iconElement.style.color = '#3a7a5f';
        } else {
            iconElement.textContent = '⚠️'; // Warning
            iconElement.style.color = 'red';
        }
        
        iconElement.style.animation = 'warning-bounce 0.8s infinite alternate';
        
        document.getElementById('game-container').appendChild(iconElement);
        
        // Add animation style if not already defined
        if (!document.getElementById('warning-animation-style')) {
            const style = document.createElement('style');
            style.id = 'warning-animation-style';
            style.textContent = `
                @keyframes warning-bounce {
                    from { transform: translateY(0); }
                    to { transform: translateY(-10px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Store reference to remove later
        currentObstacle.warningIcon = iconElement;
    }
}
        
        // Continue to next persuasion stage with enhanced visuals
function continuePersuasion() {
    if (!currentObstacle) return;
    
    persuasionStage++;
    
    // Special handling for thought, companion obstacles, and financial questions
    if (currentObstacle.type === 'thought' || currentObstacle.type === 'companion_msg' || currentObstacle.type === 'financial_question') {
        // Close the dialog
        hideObstacleDialog();
        
        // Small mental boost for acknowledging positive messages
        stats.mentalHealth = Math.min(100, stats.mentalHealth + 2);
        updatePlayerCondition();
        
        if (currentObstacle.type === 'thought') {
            // Score boost for adopting financial thinking
            score += currentObstacle.value || 500;
            
            // Show custom message with the adopted thought option
            showPopupMessage("אימצת את המחשבה: " + currentObstacle.acceptOption, 2500);
        } else if (currentObstacle.type === 'companion_msg') {
            showPopupMessage("הקשבת לחבר שלך!", 2000);
        } else if (currentObstacle.type === 'financial_question') {
    // Check if answer is correct (the user clicked 'ignore-btn')
    if (currentObstacle.correctButton === 'ignore-btn') {
        // Removed score increase
        showPopupMessage("✅ תשובה נכונה!", 2000);
        
        // Show explanation
        setTimeout(() => {
            showPopupMessage("💡 " + currentObstacle.questionData.explanation, 3000);
        }, 2200);
    } else {
        showPopupMessage("❌ תשובה שגויה", 2000);
        setTimeout(() => {
            showPopupMessage("💡 " + currentObstacle.questionData.explanation, 3000);
        }, 2200);
    }
}
        
        return;
    }
    
    // Regular persuasion flow for normal obstacles
    // Check if we have more persuasive texts
    if (persuasionStage <= currentObstacle.persuasiveTexts.length) {
        // Update text for current stage with animation
        const textElement = document.getElementById('obstacle-text');
        const ignoreBtn = document.getElementById('ignore-btn');
        const acceptBtn = document.getElementById('accept-btn');
        
        // Fade out current text and buttons
        textElement.style.transition = 'opacity 0.2s, transform 0.2s';
        textElement.style.opacity = '0';
        textElement.style.transform = 'translateY(-10px)';
        
        // After fade out, update text and fade in
        setTimeout(() => {
            // Check if persuasiveTexts is an array of objects or strings
            if (typeof currentObstacle.persuasiveTexts[0] === 'object') {
                // Using new format with custom button text
                const persuasion = currentObstacle.persuasiveTexts[persuasionStage - 1];
                textElement.textContent = persuasion.text;
                
                // Update button text if available
                if (persuasion.ignoreOption) {
                    ignoreBtn.textContent = persuasion.ignoreOption;
                }
                if (persuasion.acceptOption) {
                    acceptBtn.textContent = persuasion.acceptOption;
                }
            } else {
                // Legacy format (just text strings)
                textElement.textContent = currentObstacle.persuasiveTexts[persuasionStage - 1];
            }
            
            // Fade in new text
            textElement.style.transform = 'translateY(0)';
            textElement.style.opacity = '1';
        }, 200);
        
        // If this is the last stage, change the ignore button text
if (persuasionStage === currentObstacle.persuasiveTexts.length) {
    if (!currentObstacle.persuasiveTexts[persuasionStage - 1].ignoreOption) {
        ignoreBtn.textContent = "החלטה סופית: סירוב";
    }
    ignoreBtn.style.fontWeight = 'bold';
    // שימור צבע אחיד ללא שינוי בשלב האחרון
    ignoreBtn.style.background = 'var(--primary-color)';
} else if (typeof currentObstacle.persuasiveTexts[0] !== 'object') {
    // Only reset if using legacy format
    ignoreBtn.textContent = "סירוב";
}
        
        // Visual effect on each persuasion stage
        const persuasionEffect = document.createElement('div');
        persuasionEffect.className = 'persuasion-pulse';
        persuasionEffect.style.position = 'absolute';
        persuasionEffect.style.top = '0';
        persuasionEffect.style.left = '0';
        persuasionEffect.style.width = '100%';
        persuasionEffect.style.height = '100%';
        persuasionEffect.style.background = 'radial-gradient(circle at center, rgba(150, 50, 50, 0.1) 0%, rgba(150, 50, 50, 0) 70%)';
        persuasionEffect.style.opacity = '0';
        persuasionEffect.style.zIndex = '14';
        persuasionEffect.style.pointerEvents = 'none';
        
        document.getElementById('game-container').appendChild(persuasionEffect);
        
        // Define animation for persuasion pulse
        const pulseStyle = document.createElement('style');
        pulseStyle.textContent = `
            @keyframes persuasion-pulse {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(pulseStyle);
        
        // Apply animation
        persuasionEffect.style.animation = 'persuasion-pulse 1s ease-out forwards';
        
        // Remove elements after animation
        setTimeout(() => {
            if (persuasionEffect.parentNode) {
                persuasionEffect.parentNode.removeChild(persuasionEffect);
            }
            if (pulseStyle.parentNode) {
                pulseStyle.parentNode.removeChild(pulseStyle);
            }
        }, 1000);
    } else {
        // If no more texts, close the dialog
        hideObstacleDialog();
        stats.obstaclesAvoided++; // Increment obstacle resistance counter
        
        // Small mental boost for fully resisting
        stats.mentalHealth = Math.min(100, stats.mentalHealth + 5);
        updatePlayerCondition();
        
        // Show resistance message
        showPopupMessage("קבלת החלטה פיננסית מושכלת!", 2500);
        
        // Add visual reinforcement for good decision
        showPositiveDecisionEffect();
    }
}
        
        // Visual effect for positive financial decision
        function showPositiveDecisionEffect() {
            // Create shield-like visual around player
            const shield = document.createElement('div');
            shield.className = 'decision-shield';
            shield.style.position = 'absolute';
            shield.style.top = `${player.y + player.height / 2}px`;
            shield.style.left = `${player.x + player.width / 2}px`;
            shield.style.width = '0';
            shield.style.height = '0';
            shield.style.borderRadius = '50%';
            shield.style.background = 'radial-gradient(circle, rgba(58, 122, 95, 0.2) 0%, rgba(58, 122, 95, 0) 70%)';
            shield.style.transform = 'translate(-50%, -50%)';
            shield.style.zIndex = '15';
            
            document.getElementById('game-container').appendChild(shield);
            
            // Define animation for expanding shield
            const shieldStyle = document.createElement('style');
            shieldStyle.textContent = `
                @keyframes shield-expand {
                    0% { width: 0; height: 0; opacity: 0; }
                    50% { width: 200px; height: 200px; opacity: 0.7; }
                    100% { width: 300px; height: 300px; opacity: 0; }
                }
            `;
            document.head.appendChild(shieldStyle);
            
            // Apply animation
            shield.style.animation = 'shield-expand 1.5s ease-out forwards';
            
            // Add checkmark icon
            const checkmark = document.createElement('div');
            checkmark.className = 'decision-checkmark';
            checkmark.style.position = 'absolute';
            checkmark.style.top = `${player.y - 30}px`;
            checkmark.style.left = `${player.x + player.width / 2}px`;
            checkmark.style.transform = 'translate(-50%, -50%)';
            checkmark.style.fontSize = '30px';
            checkmark.style.color = 'rgb(58, 122, 95)';
            checkmark.style.zIndex = '16';
            checkmark.style.opacity = '0';
            checkmark.textContent = '✓';
            
            document.getElementById('game-container').appendChild(checkmark);
            
            // Define animation for checkmark
            const checkStyle = document.createElement('style');
            checkStyle.textContent = `
                @keyframes checkmark-appear {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
                    100% { opacity: 0; transform: translate(-50%, -130%) scale(1); }
                }
            `;
            document.head.appendChild(checkStyle);
            
            // Apply animation
            checkmark.style.animation = 'checkmark-appear 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (shield.parentNode) {
                    shield.parentNode.removeChild(shield);
                }
                if (shieldStyle.parentNode) {
                    shieldStyle.parentNode.removeChild(shieldStyle);
                }
                if (checkmark.parentNode) {
                    checkmark.parentNode.removeChild(checkmark);
                }
                if (checkStyle.parentNode) {
                    checkStyle.parentNode.removeChild(checkStyle);
                }
            }, 1500);
        }
        
        // Handle accepting obstacle with enhanced visuals
function acceptObstacle() {
    if (!currentObstacle) return;
    
    // Handle different obstacle types
    if (currentObstacle.type === 'thought') {
        // Positive effect for adopting financial thoughts
        score += currentObstacle.value;
        stats.mentalHealth = Math.min(100, stats.mentalHealth + currentObstacle.mentalEffect);
        showPopupMessage(`אימצת: ${currentObstacle.acceptOption}. +${currentObstacle.value} ש"ח, +${currentObstacle.mentalEffect} חוסן מנטלי`, 2500);
        showPositiveDecisionEffect();
    } else if (currentObstacle.type === 'companion_msg') {
        // Positive effect for accepting companion advice
        stats.mentalHealth = Math.min(100, stats.mentalHealth + currentObstacle.mentalEffect);
        showPopupMessage(`קיבלת עידוד מחברך: +${currentObstacle.mentalEffect} חוסן מנטלי`, 2500);
        showPositiveDecisionEffect();
    } else if (currentObstacle.type === 'financial_question') {
        // Check if answer is correct (the user clicked 'accept-btn')
        if (currentObstacle.correctButton === 'accept-btn') {
            // Removed score increase
            showPopupMessage("תשובה נכונה!", 2000);
            
            // Show explanation
            setTimeout(() => {
                showPopupMessage(currentObstacle.questionData.explanation, 3000);
            }, 2200);
        } else {
            showPopupMessage("תשובה שגויה", 2000);
            setTimeout(() => {
                showPopupMessage(currentObstacle.questionData.explanation, 3000);
            }, 2200);
        }
    } else {
        // Apply the negative effects for regular obstacles
        score -= currentObstacle.value;
        stats.expenses += currentObstacle.value;
        
        // Apply specific effects based on obstacle type
        if (currentObstacle.type === 'person') {
            stats.mentalHealth -= currentObstacle.mentalEffect;
            showPopupMessage(`לחץ חברתי השפיע עליך: -${currentObstacle.mentalEffect} נקודות חוסן מנטלי`, 2500);
            showNegativeMentalEffect();
        } else if (currentObstacle.type === 'food') {
            stats.physicalHealth -= currentObstacle.weightEffect;
            showPopupMessage(`החלטה תזונתית לא מיטבית: -${currentObstacle.weightEffect} נקודות בריאות`, 2500);
            showNegativePhysicalEffect();
        } else {
            showPopupMessage(`הוצאה בלתי מתוכננת: ${currentObstacle.value} ש"ח`, 2000);
            showMoneyLossEffect(currentObstacle.value);
        }
    }
    
    // Update obstacle interactions counter
    stats.obstaclesFaced++;
    
    // Update player condition
    updatePlayerCondition();
    updateDisplay();
    
    // Reset and continue game
    hideObstacleDialog();
    
    // Check if player is now bankrupt
    if (score < 0) {
        gameOver(`המאזן השלילי הוביל לקריסה פיננסית. הוצאת יותר מדי על ${currentObstacle.text}`);
        return;
    }
    
    // Check if mental or physical health is too low
    if (stats.mentalHealth <= 20) {
        gameOver("החוסן המנטלי שלך נפגע משמעותית. אינך מסוגל להמשיך.");
        return;
    }
    
    if (stats.physicalHealth <= 20) {
        gameOver("בריאותך הפיזית נפגעה באופן חמור. קשה לך להמשיך בדרך.");
        return;
    }
}
        
        // Visual effect for money loss
        function showMoneyLossEffect(amount) {
            // Create money loss text
            const lossText = document.createElement('div');
            lossText.className = 'money-loss';
            lossText.style.position = 'absolute';
            lossText.style.top = '40%';
            lossText.style.left = '50%';
            lossText.style.transform = 'translate(-50%, -50%)';
            lossText.style.fontSize = '36px';
            lossText.style.fontWeight = 'bold';
            lossText.style.color = '#d45b5b';
            lossText.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            lossText.style.zIndex = '30';
            lossText.style.opacity = '0';
            lossText.textContent = `-${amount} ₪`;
            
            document.getElementById('game-container').appendChild(lossText);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes money-loss-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, 0) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            lossText.style.animation = 'money-loss-anim 2s ease-out forwards';
            
            // Create falling coins for large amounts
            if (amount > 1000) {
                const coinCount = Math.min(8, Math.floor(amount / 500));
                
                for (let i = 0; i < coinCount; i++) {
                    const coin = document.createElement('div');
                    coin.className = 'falling-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '20px';
                    coin.style.height = '20px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#d45b5b';
                    coin.style.boxShadow = '0 0 5px rgba(212, 91, 91, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '12px';
                    coin.textContent = '₪';
                    
                    // Position at center of screen initially
                    coin.style.top = '40%';
                    coin.style.left = '50%';
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create dynamic animation for each coin
                    const fallDelay = Math.random() * 0.5;
                    const fallDuration = 1 + Math.random() * 0.5;
                    const horizontalOffset = (Math.random() * 200) - 100; // -100px to 100px
                    
                    // Create specific keyframes for this coin
                    const coinKeyframes = `
                        @keyframes coin-fall-${i} {
                            0% { 
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1); 
                            }
                            100% { 
                                opacity: 0;
                                transform: translate(calc(-50% + ${horizontalOffset}px), calc(-50% + 200px)) scale(0.5) rotate(${Math.random() * 360}deg); 
                            }
                        }
                    `;
                    
                    // Add style for this specific coin
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-fall-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDelay + fallDuration + 0.1) * 1000);
                }
            }
            
            // Remove elements after animation
            setTimeout(() => {
                if (lossText.parentNode) {
                    lossText.parentNode.removeChild(lossText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2000);
        }
        // Hide obstacle dialog and continue game with cleanup
function hideObstacleDialog() {
    const dialogBox = document.getElementById('obstacle-dialog');
    
    // הסרת שכבת האפלה
    if (currentObstacle && currentObstacle.dialogOverlay) {
        if (currentObstacle.dialogOverlay.parentNode) {
            currentObstacle.dialogOverlay.parentNode.removeChild(currentObstacle.dialogOverlay);
        }
    }
    
    // החזרת הקלט למשחק
    document.getElementById('game-container').style.pointerEvents = 'auto';
    
    // הסתרת הדיאלוג
    dialogBox.style.display = 'none';
    
    // הסתרת האלמנטים הנוספים
    if (currentObstacle && currentObstacle.warningOverlay) {
        currentObstacle.warningOverlay.style.opacity = '0';
        setTimeout(() => {
            if (currentObstacle.warningOverlay.parentNode) {
                currentObstacle.warningOverlay.parentNode.removeChild(currentObstacle.warningOverlay);
            }
        }, 500);
    }
    
    if (currentObstacle && currentObstacle.warningIcon) {
        if (currentObstacle.warningIcon.parentNode) {
            currentObstacle.warningIcon.parentNode.removeChild(currentObstacle.warningIcon);
        }
    }
    
    // שחרור משחק
    setTimeout(() => {
        currentObstacle = null;
        gamePaused = false;
        persuasionStage = 0;
        
        // Reset button styles to default
const ignoreBtn = document.getElementById('ignore-btn');
ignoreBtn.textContent = "סירוב";
ignoreBtn.style.fontWeight = 'normal';
ignoreBtn.style.background = 'var(--primary-color)';
ignoreBtn.style.display = 'inline-block';
ignoreBtn.style.width = '';
        
        // Reset accept button too
        const acceptBtn = document.getElementById('accept-btn');
        acceptBtn.textContent = "הסכמה";
        acceptBtn.style.width = '';
    }, 300);
}

// Reset powerup dialog button text when dialog is hidden
function resetPowerupDialogButtons() {
    // Reset button text
    document.getElementById('powerup-yes-btn').textContent = "כן";
    document.getElementById('powerup-no-btn').textContent = "לא";
}
        
        // Collision detection
function checkCollision(obj1, obj2) {
    return obj1.x < obj2.x + obj2.width &&
           obj1.x + obj1.width > obj2.x &&
           obj1.y < obj2.y + obj2.height &&
           obj1.y + obj1.height > obj2.y;
}

// Check if a position is occupied by any existing object
function isPositionOccupied(newObj) {
    // הגדר מרווח מינימלי בין אובייקטים
    const minSpacing = 20; // מרווח מינימלי של 20 פיקסלים
    
    // הרחב את האובייקט הזמני לבדיקה כדי לדרוש מרווח מינימלי
    const tempObj = {
        x: newObj.x - minSpacing,
        y: newObj.y - minSpacing,
        width: newObj.width + (minSpacing * 2),
        height: newObj.height + (minSpacing * 2)
    };
    
    // Check collision with existing obstacles
    for (let i = 0; i < obstacles.length; i++) {
        if (checkCollision(tempObj, obstacles[i])) {
            return true;
        }
    }
    
    // Check collision with existing powerups
    for (let i = 0; i < powerups.length; i++) {
        if (checkCollision(tempObj, powerups[i])) {
            return true;
        }
    }
    
    return false;
}
        
        // Handle obstacle hit
function hitObstacle(obstacle) {
    // See if enough time has passed since last obstacle dialog
    const now = Date.now();
    if (now - lastObstacleTime < minObstacleInterval) {
        // Too soon for another obstacle dialog
        return true;
    }
    
    // Show obstacle dialog with enhanced animation
    showObstacleDialog(obstacle);
    lastObstacleTime = now;
    
    // Play appropriate sound based on obstacle type
    if (obstacle.type === 'thought') {
        // Could add a positive thought sound here if you add sounds later
    } else if (obstacle.type === 'companion_msg') {
        // Could add a friendly message sound here if you add sounds later
    }
    
    return true; // Obstacle is handled (will be removed in the main loop)
}
        
        // Update game state
        function updateGame() {
    if (!gameRunning || gamePaused) return;
    
    // Update day/night cycle only if player is moving
    if (isMoving) {
        updateDayNightCycle();
    } else {
        // אם השחקן לא זז, עדיין נעדכן את תצוגת השעון
        updateClockDisplay();
    }
    
    // עדכון מצב הכפתור באופן דינמי
    updateArrowButtonAttention();
    
    // הקוד להצגת טיפים פיננסיים הוסר כיוון שהם עכשיו חלק ממערכת השאלות
    
    // Update month timer only if player is moving (pressing forward button)
    if (isMoving) {
        // Progress at speed adjusted to player condition
        currentMonthTimer += player.currentSpeed / player.baseSpeed;
    }
            
    if (currentMonthTimer >= framesPerMonth) {
        currentMonthTimer = 0;
        currentMonth++;
        stats.monthsPlayed++;
        
        // Add monthly income to score with animation
        score += stats.income;
        showMonthlyIncomeEffect();
        
        // Slightly recover mental and physical health each month
        stats.mentalHealth = Math.min(100, stats.mentalHealth + 2);
        stats.physicalHealth = Math.min(100, stats.physicalHealth + 2);
        updatePlayerCondition();
        
        // Reset monthly counters at the beginning of a new month
        monthlyObstacleCounter = {
            person: 0,
            ad: 0,
            food: 0
        };
        
        monthlyPowerupCounter = {
            money: 0,
            earlyRise: 0,
            earlySleep: 0,
            healthyFood: 0,
            exercise: 0,
            companion: 0
        };
        
        // Check win condition
        if (score >= 100000) {
            winGame();
            return;
        }
        
        // Update display
        updateDisplay();
        
        // Show month transition animation
        showMonthTransitionEffect();
        
        // Maybe show job offer (15% chance each month)
        if (Math.random() < 0.15) {
            showJobOffer();
        }
        
        // Create monthly powerups
        const monthlyTypes = ['money', 'earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
        monthlyTypes.forEach(type => {
            // Schedule powerups throughout the month
            setTimeout(() => {
                createCustomPowerup(type);
            }, getRandomInt(5, monthDuration * 0.7) * 1000);
        });
        
        // Every 2 months, create a companion powerup
        if (currentMonth % 2 === 0) {
            setTimeout(() => {
                createCompanion();
            }, getRandomInt(10, monthDuration * 0.6) * 1000);
        }
        
    }
    
    // Update powerup status
    if (player.powerUp) {
        player.powerUpTime--;
        
        // Update power meter with smoother animation
        const powerFill = document.getElementById('power-meter-fill');
        const powerPercentage = (player.powerUpTime / maxPowerUpTime) * 100;
        powerFill.style.width = `${Math.min(100, powerPercentage)}%`;
        
        // Change color based on time remaining
        if (powerPercentage < 20) {
            powerFill.style.backgroundColor = 'var(--danger-color)';
        } else if (powerPercentage < 50) {
            powerFill.style.backgroundColor = 'var(--warning-color)';
        } else {
            powerFill.style.backgroundColor = 'var(--success-color)';
        }
        
        if (player.powerUpTime <= 0) {
            player.powerUp = false;
            player.companion = false;
            document.getElementById('power-meter').style.display = 'none';
            showPopupMessage("השפעת החיזוק הסתיימה", 1500);
        }
    }
    
    // Update obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        
        // Update position only if player is moving
        if (isMoving) {
            obstacle.x -= obstacle.speed;
            
            // Apply any obstacle-specific animations
            if (obstacle.bobSpeed) {
                obstacle.y = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 2;
            }
            
            // For ad obstacles, add pulsing effect
            if (obstacle.type === 'ad' && obstacle.pulseRate) {
                obstacle.pulseValue = (Math.sin(Date.now() * obstacle.pulseRate) + 1) / 2; // 0 to 1
            }
        }
        
        // Check for collision
        if (checkCollision(player, obstacle)) {
            const survived = hitObstacle(obstacle);
            obstacles.splice(i, 1);
            
            if (!survived) return; // Game over
        }
        
        // Remove if off-screen
        if (obstacle.x + obstacle.width < 0) {
            obstacles.splice(i, 1);
        }
    }
    
    // Update powerups
    for (let i = powerups.length - 1; i >= 0; i--) {
        const powerup = powerups[i];
        
        // Update position only if player is moving
        if (isMoving) {
            powerup.x -= powerup.speed;
            
            // Apply floating animation if available
            if (powerup.floatSpeed && powerup.originalY) {
                powerup.y = powerup.originalY + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
            }
        }
        
        // Check for collision
        if (checkCollision(player, powerup)) {
            // Apply powerup effect
            applyPowerup(powerup);
            powerups.splice(i, 1);
        }
        
        // Remove if off-screen
        if (powerup.x + powerup.width < 0) {
            powerups.splice(i, 1);
        }
    }
    
    // Maybe create a new obstacle (0.3% chance per frame - slower for longer game)
if (Math.random() < 0.003 && isMoving) {
    // Ensure there's enough distance from the last obstacle
    let canCreateObstacle = true;
    
    for (let i = 0; i < obstacles.length; i++) {
        if (obstacles[i].x > canvas.width - 450) { // Increased space between obstacles
            canCreateObstacle = false;
            break;
        }
    }
    
    // גם בדוק מרחק מפאוור-אפים קיימים
    for (let i = 0; i < powerups.length; i++) {
        if (powerups[i].x > canvas.width - 300) { // לא ליצור מכשול קרוב מדי לפאוור-אפ
            canCreateObstacle = false;
            break;
        }
    }
    
    if (canCreateObstacle) {
        createObstacle();
    }
}

// Maybe create a new powerup (0.1% chance per frame - fewer powerups)
if (Math.random() < 0.001 && isMoving) {
    // Make sure powerups are spaced out
    let canCreatePowerup = true;
    
    for (let i = 0; i < powerups.length; i++) {
        if (powerups[i].x > canvas.width - 500) { // Increased space between powerups
            canCreatePowerup = false;
            break;
        }
    }
    
    // גם בדוק מרחק ממכשולים קיימים
    for (let i = 0; i < obstacles.length; i++) {
        if (obstacles[i].x > canvas.width - 300) { // לא ליצור פאוור-אפ קרוב מדי למכשול
            canCreatePowerup = false;
            break;
        }
    }
    
    if (canCreatePowerup) {
        createPowerup();
    }
}
    
    // Process any pending obstacles
    if (pendingObstacles.length > 0 && gameRunning && isMoving) {
        const now = Date.now();
        
        for (let i = pendingObstacles.length - 1; i >= 0; i--) {
            if (now >= pendingObstacles[i].time) {
                createObstacle();
                pendingObstacles.splice(i, 1);
            }
        }
    }
    
    // Render game
    renderGame();
    
    // Update game message time
    if (gameMessageTime > 0) {
        gameMessageTime--;
        if (gameMessageTime <= 0) {
            gameMessage = '';
        }
    }
}
        
        // Monthly income visual effect
        function showMonthlyIncomeEffect() {
            // Create income text effect
            const incomeText = document.createElement('div');
            incomeText.className = 'income-text';
            incomeText.style.position = 'absolute';
            incomeText.style.top = '40%';
            incomeText.style.left = '50%';
            incomeText.style.transform = 'translate(-50%, -50%)';
            incomeText.style.fontSize = '32px';
            incomeText.style.fontWeight = 'bold';
            incomeText.style.color = '#3a7a5f';
            incomeText.style.textShadow = '0 0 10px rgba(58, 122, 95, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            incomeText.style.zIndex = '30';
            incomeText.style.opacity = '0';
            incomeText.textContent = `+${stats.income.toLocaleString()} ש"ח משכורת חודשית`;
            
            document.getElementById('game-container').appendChild(incomeText);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes income-text-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            incomeText.style.animation = 'income-text-anim 2.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (incomeText.parentNode) {
                    incomeText.parentNode.removeChild(incomeText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
            
            // Show falling money for visual reinforcement
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'income-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '30px';
                    coin.style.height = '30px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#3a7a5f';
                    coin.style.boxShadow = '0 0 10px rgba(58, 122, 95, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '18px';
                    coin.textContent = '₪';
                    
                    // Position at top of screen
                    const startX = Math.random() * canvas.width;
                    coin.style.top = '-30px';
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation
                    const fallDuration = 1.5 + Math.random();
                    const fallDelay = Math.random() * 0.5;
                    const rotation = Math.random() * 360;
                    const endX = startX + (Math.random() * 200 - 100);
                    
                    const coinKeyframes = `
                        @keyframes coin-income-${i} {
                            0% { 
                                opacity: 1;
                                transform: translateY(0) rotate(0deg); 
                            }
                            80% {
                                opacity: 1;
                            }
                            100% { 
                                opacity: 0;
                                transform: translateY(${canvas.height}px) translateX(${endX - startX}px) rotate(${rotation}deg); 
                            }
                        }
                    `;
                    
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-income-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDuration + fallDelay + 0.1) * 1000);
                }, i * 100); // Stagger coin creation
            }
        }
        
        // Month transition effect
        function showMonthTransitionEffect() {
            // Create month transition overlay
            const overlay = document.createElement('div');
            overlay.className = 'month-transition';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            overlay.style.zIndex = '40';
            overlay.style.pointerEvents = 'none';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            // Create month text
            const monthText = document.createElement('div');
            monthText.style.fontSize = '48px';
            monthText.style.fontWeight = 'bold';
            monthText.style.color = 'rgba(42, 100, 150, 0)';
            monthText.style.textShadow = '0 0 20px rgba(42, 100, 150, 0.5)';
            monthText.style.opacity = '0';
            monthText.style.transform = 'scale(0.8)';
            monthText.style.transition = 'all 0.5s ease';
            monthText.textContent = monthNames[currentMonth];
            
            overlay.appendChild(monthText);
            document.getElementById('game-container').appendChild(overlay);
            
            // Animate the transition
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                monthText.style.opacity = '1';
                monthText.style.color = 'rgba(42, 100, 150, 1)';
                monthText.style.transform = 'scale(1.2)';
            }, 100);
            
            setTimeout(() => {
                monthText.style.opacity = '0';
                monthText.style.transform = 'scale(0.8)';
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            }, 1500);
            
            // Remove overlay after animation
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            }, 2000);
        }
        // Create a specific type of powerup with enhanced visuals
function createCustomPowerup(type) {
    let text = '';
    let width = 40;
    let height = 40;
    let value = 1000;
    let healthEffect = 0;
    let mentalEffect = 0;
    let color = '';
            
            switch(type) {
                case 'money':
                    text = "בונוס כספי";
                    value = getRandomInt(1000, 3000);
                    color = "#2a6496"; // Blue
                    break;
                case 'earlyRise':
                    text = "קימה מוקדמת";
                    mentalEffect = 10;
                    color = "#3a7a5f"; // Green
                    break;
                case 'earlySleep':
                    text = "שינה מוקדמת";
                    mentalEffect = 15;
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "תזונה בריאה";
                    healthEffect = 15;
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "פעילות גופנית";
                    healthEffect = 20;
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
        x: canvas.width,
        y: getRandomInt(ground.y - 150, ground.y - 60),
        width: width,
        height: height,
        type: type,
        speed: 4,
        text: text,
        value: value,
        healthEffect: healthEffect,
        mentalEffect: mentalEffect,
        color: color,
        animationOffset: Math.random() * Math.PI * 2,
        floatSpeed: 0.03 + Math.random() * 0.02,
        floatRange: 10 + Math.random() * 5,
        glowing: true,
        originalY: 0
    };
    
    // Store original Y for floating animation
    powerup.originalY = powerup.y;
    
    // בדיקה אם הפאוור-אפ החדש מתנגש עם אובייקטים קיימים
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // במידת הצורך, שנה את מיקום ה-Y של הפאוור-אפ
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 120; // שינוי אקראי בגובה 
            powerup.y = getRandomInt(ground.y - 150, ground.y - 60) + yOffset;
            powerup.originalY = powerup.y; // עדכון ה-originalY גם כן
        }
        
        // בדוק אם המיקום החדש פנוי
        validPosition = !isPositionOccupied(powerup);
        attempts++;
    }
    
    powerups.push(powerup);
    
    // Visual cue for powerup arrival
    showPowerupArrivalCue(powerup);
        }
        
        // Visual cue for powerup arrival
        function showPowerupArrivalCue(powerup) {
            // Create a subtle flash at the edge where the powerup will appear
            const flash = document.createElement('div');
            flash.className = 'powerup-arrival-flash';
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '20px';
            flash.style.height = `${powerup.height * 1.5}px`;
            flash.style.borderRadius = '10px 0 0 10px';
            flash.style.zIndex = '9';
            flash.style.opacity = '0';
            
            // Set color based on powerup type
            switch(powerup.type) {
                case 'money':
                    flash.style.backgroundColor = 'rgba(42, 100, 150, 0.6)';
                    break;
                case 'earlyRise':
                case 'healthyFood':
                    flash.style.backgroundColor = 'rgba(58, 122, 95, 0.6)';
                    break;
                case 'earlySleep':
                    flash.style.backgroundColor = 'rgba(90, 90, 143, 0.6)';
                    break;
                case 'exercise':
                    flash.style.backgroundColor = 'rgba(211, 135, 62, 0.6)';
                    break;
                default:
                    flash.style.backgroundColor = 'rgba(100, 100, 100, 0.6)';
            }
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define animation for flash
            const style = document.createElement('style');
            style.textContent = `
                @keyframes powerup-arrival-flash {
                    0% { opacity: 0; width: 5px; }
                    50% { opacity: 0.8; width: 20px; }
                    100% { opacity: 0; width: 5px; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            flash.style.animation = 'powerup-arrival-flash 1s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1000);
        }
        
        // Render game with enhanced visuals
function renderGame() {
    try {
        // בדיקה שהקנבס זמין ובגודל תקין
        if (!canvas || canvas.width <= 0 || canvas.height <= 0) {
            console.error("Canvas not ready or has invalid dimensions");
            return;
        }
        
        // בדיקה שההקשר של הקנבס זמין
        if (!ctx) {
            console.error("Canvas context not available");
            return;
        }
    
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // ניסיון לצייר רקע בסיסי למקרה של כשל בפונקציות האחרות
        try {
            // Draw sky with dynamic coloring based on time
            drawDynamicBackground();
        } catch (error) {
            console.error("Error in drawDynamicBackground:", error);
            // פתרון גיבוי - רקע פשוט
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        try {
            // Draw subtle background patterns
            drawBackgroundPatterns();
        } catch (error) {
            console.error("Error in renderGame:", error);
        }
        
        // Draw ground
        const groundGradient = ctx.createLinearGradient(0, ground.y, 0, canvas.height);
        groundGradient.addColorStop(0, "#adb5bd");
        groundGradient.addColorStop(1, "#6c757d");
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, ground.y, ground.width, ground.height);
        
        // Draw "stable career path" text on the ground
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.font = "bold 20px 'Open Sans', Arial";
        ctx.textAlign = "center";
        const text = "נתיב קריירה יציב";
        
        // בדיקה שהמדידה של הטקסט תקינה
        let textWidth;
        try {
            textWidth = ctx.measureText(text).width;
        } catch (error) {
            console.error("Error measuring text:", error);
            textWidth = 200; // ערך ברירת מחדל
        }
        
        // Create pattern with the text repeating across the ground
        const repetitions = Math.ceil(canvas.width / (textWidth + 100));
        
        for (let i = 0; i < repetitions; i++) {
            try {
                ctx.fillText(text, (textWidth + 100) * i + textWidth/2 + 50, ground.y + 40);
            } catch (error) {
                console.error("Error drawing text:", error);
            }
        }
            
            ctx.textAlign = "start";
            
            // Draw path edge with enhanced shadow
            const pathGlow = isDayTime ? 'rgba(73, 80, 87, 0.7)' : 'rgba(73, 80, 87, 0.9)';
            ctx.fillStyle = pathGlow;
            ctx.fillRect(0, ground.y, ground.width, 5);
            
            // Add subtle shadow/highlight to path edge based on time of day
            if (!isDayTime) {
                // Night shadow
                ctx.fillStyle = 'rgba(0, 0, 30, 0.3)';
                ctx.fillRect(0, ground.y + 5, ground.width, 3);
            } else {
                // Day highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(0, ground.y - 1, ground.width, 1);
            }
            
            // Draw player - enhanced style
            drawEnhancedPlayer();
            
            // Draw obstacles with enhanced visuals
            obstacles.forEach(obstacle => {
                switch(obstacle.type) {
                    case 'person':
    // Draw negative person as emoji with animation
    ctx.save();
    
    // Apply bobbing animation
    const personY = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 3;
    
    // Draw emoji
    ctx.font = `${obstacle.width}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום

    // Randomly select one of several negative emojis
    if (!obstacle.emojiChar) {
        const negativeEmojis = ["😠", "😒", "🙎‍♂️", "🙎‍♀️", "😤"];
        obstacle.emojiChar = negativeEmojis[Math.floor(Math.random() * negativeEmojis.length)];
    }

    ctx.fillText(obstacle.emojiChar, 
                obstacle.x + obstacle.width/2, 
                personY + obstacle.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
    
    // בועות דיבור הוסרו
    break;
                        
    case 'ad':
    // Draw ad as emoji with pulsing effect
    ctx.save();
    
    const pulseScale = obstacle.pulseValue ? 1 + (obstacle.pulseValue * 0.1) : 1;
    const adX = obstacle.x;
    const adY = obstacle.y;
    
    // Draw emoji with pulsing effect
ctx.font = `${obstacle.width * pulseScale}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום

// Randomly select one of several ad emojis
if (!obstacle.emojiChar) {
    const adEmojis = ["💰", "💸", "🤑", "📢", "🛒"];
    obstacle.emojiChar = adEmojis[Math.floor(Math.random() * adEmojis.length)];
}

ctx.fillText(obstacle.emojiChar, 
            adX + obstacle.width/2, 
            adY + obstacle.height/2);
    
    // Add sparkle effect on random positions
    if (Math.random() < 0.1) {
        const sparkleX = adX + Math.random() * obstacle.width;
        const sparkleY = adY + Math.random() * obstacle.height;
        
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, 1, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.textAlign = "start";
    ctx.restore();
    break;
                        
    case 'financial_question':
    // Draw financial question as emoji with special styling
    ctx.save();
    
    // Apply a subtle bobbing animation
    const questionY = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 3;
    
    // Draw glow effect
    ctx.shadowColor = 'rgba(58, 122, 95, 0.5)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    // Draw question emoji
ctx.font = `${obstacle.width}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום

// Randomly select one of several question emojis
if (!obstacle.emojiChar) {
    const questionEmojis = ["❓", "💭", "📊", "📈"];
    obstacle.emojiChar = questionEmojis[Math.floor(Math.random() * questionEmojis.length)];
}

ctx.fillText(obstacle.emojiChar, 
            obstacle.x + obstacle.width/2, 
            questionY + obstacle.height/2);
    
    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // Add shimmer effect
    const shimmerAngle = Date.now() * 0.002 % (Math.PI * 2);
    ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
    ctx.beginPath();
    ctx.ellipse(
        obstacle.x + obstacle.width/2 + Math.cos(shimmerAngle) * obstacle.width/4,
        questionY + obstacle.height/2 + Math.sin(shimmerAngle) * obstacle.height/4,
        5, 5, 0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Add sparkle effects
    if (Math.random() < 0.05) {
        drawSparkle(
            obstacle.x + Math.random() * obstacle.width,
            questionY + Math.random() * obstacle.height,
            3, 'rgba(255, 255, 255, 0.7)'
        );
    }
    
    ctx.restore();
    break;
                        
                        case 'food':
    // Draw food as emoji with rotation effect
    ctx.save();
    
    // Apply rotation animation
    const foodRotation = obstacle.rotationSpeed ? Date.now() * obstacle.rotationSpeed : 0;
    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
    ctx.rotate(Math.sin(foodRotation) * 0.05); // Subtle rotation
    
    // Draw food emoji
ctx.font = `${obstacle.width}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום

// Randomly select one of several food emojis
if (!obstacle.emojiChar) {
    const foodEmojis = ["🍔", "🍕", "🍣", "🍱", "🥡"];
    obstacle.emojiChar = foodEmojis[Math.floor(Math.random() * foodEmojis.length)];
}

ctx.fillText(obstacle.emojiChar, 0, 0);
    
    // Steam effect for hot food (only for certain emojis)
    if (Math.random() < 0.2 && (obstacle.emojiChar === "🍔" || obstacle.emojiChar === "🍕")) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
        ctx.lineWidth = 1;
        
        const steamHeight = 10 + Math.random() * 5;
        
        ctx.beginPath();
        ctx.moveTo(0, -obstacle.height/3);
        ctx.bezierCurveTo(
            -5, -obstacle.height/3 - steamHeight/2,
            5, -obstacle.height/3 - steamHeight,
            0, -obstacle.height/3 - steamHeight
        );
        ctx.stroke();
    }
    
    ctx.restore();
    break;
                        
    case 'thought':
    // Draw thought as emoji
    ctx.save();
    
    // Apply a subtle bobbing animation
    const thoughtY = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 3;
    
    // Draw thought emoji
ctx.font = `${obstacle.width}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום

// Use thought bubble emoji
ctx.fillText("💭", 
            obstacle.x + obstacle.width/2, 
            thoughtY + obstacle.height/2);
    
    ctx.restore();
    break;
    
// מקרה ברירת המחדל נשאר אותו דבר לטיפול במכשולים שלא טופלו מפורשות
default:
    // Default obstacle - minimalist style
    ctx.fillStyle = obstacle.color || "#6c757d";
    roundRect(ctx, obstacle.x, obstacle.y, obstacle.width, obstacle.height, 8, true, false);
    break;
                }
            });
            
            // Draw powerups with enhanced visuals
            powerups.forEach(powerup => {
                let fillColor = powerup.color || "#6c757d";
                
                // Draw the powerup with different shapes based on type
                if (powerup.type === 'money') {
    // Draw money bonus as emoji
    ctx.save();
    
    // Add glow effect
    if (powerup.glowing) {
        ctx.shadowColor = fillColor;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Get floating position
    const moneyY = powerup.y;
    
    // Draw money emoji with pulse animation
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום

// Pulsing animation
const pulseFactor = 1 + Math.sin(Date.now() * 0.005) * 0.2;
ctx.font = `${powerup.width * pulseFactor}px Arial`;

// Randomly select one of several money emojis
if (!powerup.emojiChar) {
    const moneyEmojis = ["💰", "💵", "💴", "💶", "💷", "👛"];
    powerup.emojiChar = moneyEmojis[Math.floor(Math.random() * moneyEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            moneyY + powerup.height/2);
    
    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // Add sparkle effects
    if (Math.random() < 0.2) {
        drawSparkle(powerup.x + powerup.width/2, moneyY + powerup.height/2, 5, fillColor);
    }
    
    ctx.textAlign = "start";
    ctx.restore();
} else if (powerup.type === 'companion') {
    // Draw companion as emoji
    ctx.save();
    
    // Add glow effect
    if (powerup.glowing) {
        ctx.shadowColor = fillColor;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Add subtle floating animation
    const companionY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Draw companion emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several companion emojis
if (!powerup.emojiChar) {
    const companionEmojis = ["👫", "👬", "👭", "🤝", "👨‍👩‍👧‍👦"];
    powerup.emojiChar = companionEmojis[Math.floor(Math.random() * companionEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            companionY + powerup.height/2);
    
    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // Emit particles for companion
    if (powerup.emitParticles && Math.random() < 0.1) {
        const particleX = powerup.x + powerup.width/2 + (Math.random() * 20 - 10);
        const particleY = companionY + (Math.random() * 10);
        
        drawPowerupParticle(particleX, particleY, fillColor);
    }
    
    ctx.textAlign = "start";
    ctx.restore();
} else {
                    // Draw other powerups - enhanced icons
                    
                    // Add glow effect
    if (powerup.glowing) {
        ctx.shadowColor = fillColor;
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    ctx.fillStyle = fillColor;
    
    if (powerup.type === 'earlyRise') {
        // Draw early rise as emoji
        ctx.save();
        
        // Add subtle floating animation
        const riseY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
        
        // Draw early rise emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several early rise emojis
if (!powerup.emojiChar) {
    const earlyRiseEmojis = ["🌅", "⏰", "🌞"];
    powerup.emojiChar = earlyRiseEmojis[Math.floor(Math.random() * earlyRiseEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            riseY + powerup.height/2);
        
        ctx.textAlign = "start";
        ctx.restore();
    } else if (powerup.type === 'earlySleep') {
    // Draw early sleep as emoji
    ctx.save();
    
    // Add subtle floating animation
    const sleepY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Draw early sleep emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several early sleep emojis
if (!powerup.emojiChar) {
    const earlySleepEmojis = ["🌙", "💤", "😴", "🛌"];
    powerup.emojiChar = earlySleepEmojis[Math.floor(Math.random() * earlySleepEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            sleepY + powerup.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
} else if (powerup.type === 'healthyFood') {
    // Draw healthy food as emoji
    ctx.save();
    
    // Add subtle floating animation
    const foodY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Draw healthy food emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several healthy food emojis
if (!powerup.emojiChar) {
    const healthyFoodEmojis = ["🥗", "🥦", "🍎", "🥝", "🍉"];
    powerup.emojiChar = healthyFoodEmojis[Math.floor(Math.random() * healthyFoodEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            foodY + powerup.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
} else if (powerup.type === 'exercise') {
    // Draw exercise as emoji
    ctx.save();
    
    // Add subtle floating animation
    const exerciseY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Add subtle shake animation
    const exerciseShake = Math.sin(Date.now() * 0.01) * 2;
    
    // Draw exercise emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several exercise emojis
if (!powerup.emojiChar) {
    const exerciseEmojis = ["🏋️‍♂️", "🏃‍♀️", "🚴‍♂️", "🧘‍♀️", "💪"];
    powerup.emojiChar = exerciseEmojis[Math.floor(Math.random() * exerciseEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2 + exerciseShake, 
            exerciseY + powerup.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
}
                }
            });
            
            /* Draw month progress bar with enhanced style - מוסתר כעת */
// הפס הוסתר - לא נציג אותו יותר
            
            // Draw running animation if player is moving
            if (isMoving) {
                // Draw motion lines behind player - more subtle for mature look
                ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.4)" : "rgba(150, 150, 180, 0.4)";
                ctx.lineWidth = 1.5;
                
                const motionX = player.x - 30;
                
                for (let i = 0; i < 4; i++) {
                    const lineY = player.y + 20 + i * 15;
                    const lineLength = 8 + i * 4;
                    
                    // Animate motion lines length based on player speed
                    const animatedLength = lineLength * (0.8 + Math.sin(Date.now() * 0.01 + i) * 0.2);
                    
                    ctx.beginPath();
                    ctx.moveTo(motionX, lineY);
                    ctx.lineTo(motionX - animatedLength, lineY);
                    ctx.stroke();
                }
                
                // Add dust particles at player's feet when moving
                if (Math.random() < 0.2) {
                    createDustParticle();
                }
            }
            
            // Draw game messages if any
            if (gameMessage && gameMessageTime > 0) {
                const alpha = Math.min(1, gameMessageTime / 100);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#495057";
                ctx.font = "18px 'Open Sans', Arial";
                ctx.textAlign = "center";
                ctx.fillText(gameMessage, canvas.width/2, canvas.height/2);
                ctx.textAlign = "start";
                ctx.globalAlpha = 1.0;
            }
            
            // Draw dynamic day/night indicator - רק אם הפונקציה קיימת
if (typeof drawDayNightIndicator === 'function') {
    drawDayNightIndicator();
}
        
// הוספת סוגר try
} catch (error) {
    console.error("Error in main renderGame process:", error);
}
} // סגירה נכונה של renderGame בסוף הפונקציה

// Draw dynamic background based on time of day
function drawDynamicBackground() {
    // Sky gradient based on time
    let skyGradient;
    const hour = currentHour + (currentMinute / 60);
    
    skyGradient = ctx.createLinearGradient(0, 0, 0, ground.y);
    
    // Dawn (5-6)
    if (hour >= 5 && hour < 6) {
                const dawnProgress = (hour - 5);
                skyGradient.addColorStop(0, mixColorStrings('#283655', '#FF7F50', dawnProgress));
                skyGradient.addColorStop(1, mixColorStrings('#1a2238', '#FFD700', dawnProgress));
            }
            // Morning (6-10)
            else if (hour >= 6 && hour < 10) {
                skyGradient.addColorStop(0, '#87CEEB');
                skyGradient.addColorStop(1, '#ADD8E6');
            }
            // Day (10-16)
            else if (hour >= 10 && hour < 16) {
                skyGradient.addColorStop(0, '#6CA6CD');
                skyGradient.addColorStop(1, '#87CEEB');
            }
            // Afternoon (16-18)
            else if (hour >= 16 && hour < 18) {
                const afternoonProgress = (hour - 16) / 2;
                skyGradient.addColorStop(0, mixColorStrings('#6CA6CD', '#FF7F50', afternoonProgress));
                skyGradient.addColorStop(1, mixColorStrings('#87CEEB', '#FFD700', afternoonProgress));
            }
            // Sunset (18-19)
            else if (hour >= 18 && hour < 19) {
                const sunsetProgress = (hour - 18);
                skyGradient.addColorStop(0, mixColorStrings('#FF7F50', '#283655', sunsetProgress));
                skyGradient.addColorStop(1, mixColorStrings('#FFD700', '#1a2238', sunsetProgress));
            }
            // Night (19-5)
            else {
                skyGradient.addColorStop(0, '#1a2238');
                skyGradient.addColorStop(1, '#283655');
            }
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add stars at night
            if (hour >= 19 || hour < 5) {
                drawStars();
            }
            // Draw sunrise/sunset rays
            else if ((hour >= 5 && hour < 7) || (hour >= 17 && hour < 19)) {
                drawSunrays();
            }
        }
        
        // Draw stars in night sky
        function drawStars() {
            // Use the stars array created in createStars()
            if (stars.length === 0) {
                createStars();
            }
            
            stars.forEach((star, index) => {
                // Twinkle effect
                const twinkle = 0.5 + Math.sin(Date.now() * 0.001 * star.twinkleSpeed) * 0.5;
                const size = star.size * (0.7 + twinkle * 0.3);
                
                // Draw star
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + twinkle * 0.5})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Occasional larger star with glow
                if (index % 8 === 0) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Draw sunrise/sunset rays
        function drawSunrays() {
            const hour = currentHour + (currentMinute / 60);
            let rayOpacity, rayColor, sunX, sunY;
            
            // Sunrise (5-7)
            if (hour >= 5 && hour < 7) {
                rayOpacity = (hour - 5) / 2; // 0 to 1 during sunrise
                rayColor = 'rgba(255, 215, 0, '; // Golden
                sunX = canvas.width * 0.2;
                sunY = ground.y * 0.8;
            }
            // Sunset (17-19)
            else {
                rayOpacity = 1 - ((hour - 17) / 2); // 1 to 0 during sunset
                rayColor = 'rgba(255, 127, 80, '; // Coral
                sunX = canvas.width * 0.8;
                sunY = ground.y * 0.8;
            }
            
            // Limit opacity
            rayOpacity = Math.min(0.7, Math.max(0, rayOpacity));
            
            // Draw rays
            ctx.save();
            ctx.translate(sunX, sunY);
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const rayLength = 100 + Math.sin(Date.now() * 0.001 + i) * 20;
                
                ctx.rotate(angle);
                ctx.fillStyle = rayColor + rayOpacity + ')';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(rayLength, 10);
                ctx.lineTo(rayLength, -10);
                ctx.closePath();
                ctx.fill();
                ctx.rotate(-angle);
            }
            
            ctx.restore();
        }
        
        // Draw background patterns - enhanced for day/night
        function drawBackgroundPatterns() {
            ctx.fillStyle = isDayTime ? "rgba(222, 226, 230, 0.2)" : "rgba(100, 100, 150, 0.1)";
            
            // Draw subtle grid pattern
            ctx.beginPath();
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, ground.y);
            }
            for (let i = 0; i < ground.y; i += 40) {
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
            }
            ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.05)" : "rgba(100, 100, 150, 0.05)";
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Add subtle visual elements representing financial graph
            ctx.strokeStyle = isDayTime ? 
                "rgba(42, 100, 150, 0.1)" : // Day: Blue
                "rgba(100, 100, 150, 0.1)"; // Night: Purple-blue
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Draw financial graph line in background
            ctx.moveTo(0, ground.y - 100);
            
            // Use current score to influence the graph height
            const scoreInfluence = Math.min(0.5, score / 100000);
            
            for (let x = 50; x < canvas.width; x += 50) {
                // Base graph with randomness
                let y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20;
                
                // Add upward trend based on score
                y -= scoreInfluence * 100;
                
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Add data points to graph
            if (score > 10000) {
                for (let x = 100; x < canvas.width; x += 100) {
                    const y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20 - (scoreInfluence * 100);
                    
                    ctx.fillStyle = isDayTime ? "rgba(42, 100, 150, 0.2)" : "rgba(100, 100, 150, 0.2)";
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function to create dust particles at player's feet
        function createDustParticle() {
            const particle = document.createElement('div');
            particle.className = 'dust-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = isDayTime ? 'rgba(200, 200, 200, 0.6)' : 'rgba(150, 150, 180, 0.6)';
            particle.style.zIndex = '12';
            
            // Position at player's feet
            particle.style.top = `${ground.y}px`;
            particle.style.left = `${player.x + player.width / 2}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.PI + (Math.random() * Math.PI * 0.5);
            const distance = 10 + Math.random() * 20;
            const duration = 0.5 + Math.random() * 0.5;
            
            const particleKeyframes = `
                @keyframes dust-move-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.5);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `dust-move-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw sparkle effect
        function drawSparkle(x, y, size, color) {
            // Draw a simple sparkle star
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * Math.PI * 2);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            const innerSize = size * 0.5;
            const outerSize = size;
            
            // Star shape
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * outerSize, Math.sin(angle) * outerSize);
            }
            ctx.stroke();
            
            // Inner glow
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, 0, innerSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw powerup particle effect
        function drawPowerupParticle(x, y, color) {
            const particle = document.createElement('div');
            particle.className = 'powerup-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '6px';
            particle.style.height = '6px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = color || 'rgba(42, 100, 150, 0.8)';
            particle.style.zIndex = '15';
            
            // Position at source
            particle.style.top = `${y}px`;
            particle.style.left = `${x}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 30;
            const duration = 1 + Math.random() * 1;
            
            const particleKeyframes = `
                @keyframes powerup-particle-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.2);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `powerup-particle-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw day/night indicator
        function drawDayNightIndicator() {
            // Small indicator in corner
            const size = 30;
            const margin = 20;
            const x = canvas.width - size - margin;
            const y = margin;
            
            // Draw background circle
            ctx.fillStyle = isDayTime ? 'rgba(255, 255, 255, 0.6)' : 'rgba(50, 50, 80, 0.6)';
            ctx.beginPath();
            ctx.arc(x, y, size/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw icon based on time
            if (isDayTime) {
                // Sun icon
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Sun rays
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                ctx.lineWidth = 1.5;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerRadius = size/3 + 2;
                    const outerRadius = size/2 - 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        x + Math.cos(angle) * innerRadius,
                        y + Math.sin(angle) * innerRadius
                    );
                    ctx.lineTo(
                        x + Math.cos(angle) * outerRadius,
                        y + Math.sin(angle) * outerRadius
                    );
                    ctx.stroke();
                }
            } else {
                // Moon icon
                ctx.fillStyle = 'rgba(230, 230, 250, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Moon shadow
                ctx.fillStyle = 'rgba(50, 50, 80, 0.6)';
                ctx.beginPath();
                ctx.arc(x + size/8, y - size/8, size/3 - 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Stars
                for (let i = 0; i < 3; i++) {
                    const starX = x + Math.cos(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    const starY = y + Math.sin(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(starX, starY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function for color string mixing
        function mixColorStrings(color1, color2, ratio) {
            // Convert hex to rgb if needed
            const getRGB = (color) => {
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return [r, g, b];
                } else if (color.startsWith('rgb')) {
                    return color.match(/\d+/g).map(Number);
                }
                return [0, 0, 0]; // Fallback
            };
            
            const rgb1 = getRGB(color1);
            const rgb2 = getRGB(color2);
            
            const r = Math.round(rgb1[0] * (1 - ratio) + rgb2[0] * ratio);
            const g = Math.round(rgb1[1] * (1 - ratio) + rgb2[1] * ratio);
            const b = Math.round(rgb1[2] * (1 - ratio) + rgb2[2] * ratio);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        // Draw speech bubble for characters - מבוטל כרגע
function drawSpeechBubble(ctx, x, y, text, maxWidth, maxHeight) {
    // פונקציה ריקה - בועות הדיבור הושבתו
    return;
}
        
        // Draw player and companion as emojis with animations
function drawEnhancedPlayer() {
    // Use health factor for player appearance
    const healthFactor = stats.physicalHealth / 100;
    const mentalFactor = stats.mentalHealth / 100;
    
    // Add subtle bob animation when moving - visual only
let playerY = player.y;
if (isMoving) {
    // אפקט ויזואלי בלבד - לא משנה את ערך ה-Y האמיתי של השחקן
    playerY = originalPlayerY + Math.sin(Date.now() * 0.01) * 2;
} else {
    // כשלא בתנועה, וודא שהשחקן חוזר למיקום המקורי
    playerY = originalPlayerY || ground.y - player.height - 5;
}
    
    // Draw shadow beneath player
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.beginPath();
    ctx.ellipse(player.x + player.width/2, ground.y, player.width/2, player.width/8, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Select player emoji based on state and health
if (!player.emojiChar || player.lastHealthCheck !== Math.floor(healthFactor * 10) + Math.floor(mentalFactor * 10) || player.lastMovementState !== isMoving) {
    // Update player emoji when health changes significantly or movement state changes
    player.lastHealthCheck = Math.floor(healthFactor * 10) + Math.floor(mentalFactor * 10);
    player.lastMovementState = isMoving;
    
    // Call the function that updates the player emoji
    updatePlayerEmoji();
}
    
    ctx.save();
    
    // If player has powerUp, add glow effect
    if (player.powerUp) {
        let glowColor;
        
        switch(player.powerUpType) {
            case 'earlyRise':
                glowColor = 'rgba(58, 122, 95, 0.7)'; // Green-blue
                break;
            case 'earlySleep':
                glowColor = 'rgba(90, 90, 143, 0.7)'; // Purple-blue
                break;
            case 'healthyFood':
                glowColor = 'rgba(58, 122, 95, 0.7)'; // Green
                break;
            case 'exercise':
                glowColor = 'rgba(211, 135, 62, 0.7)'; // Orange
                break;
            case 'companion':
                glowColor = 'rgba(42, 100, 150, 0.7)'; // Blue
                break;
            default:
                glowColor = 'rgba(73, 80, 87, 0.7)'; // Default gray
        }
        
        // Add glow with pulsating animation
        const glowSize = 10 + Math.sin(Date.now() * 0.005) * 3;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = glowSize;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Draw player emoji
ctx.font = `${player.width * 1.2}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום

// Draw player emoji - no need to change this part
// since we handle movement state in the emoji selection logic
ctx.save();
ctx.translate(player.x + player.width/2, playerY + player.height/2);
ctx.scale(-1, 1); // הפיכת האימוג'י בציר X

// Apply slight forward lean only when moving
if (isMoving) {
    ctx.rotate(Math.PI * 0.03); // Slight forward lean
}

ctx.fillText(player.emojiChar, 0, 0);
ctx.restore();
    
    // Reset shadow and text alignment
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.textAlign = "start";
    
    // Draw companion if active - as emoji
    if (player.companion && player.powerUp) {
        // Calculate companion position with slight offset from player
        const companionX = player.x - 40; 
        const companionY = playerY;
        
        // Add companion animation - follows player with slight delay
        const companionBob = isMoving ? Math.sin((Date.now() - 100) * 0.01) * 2 : 0;
        
        // Add companion shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(companionX + 15, ground.y, 15, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Companion glow effect
        ctx.shadowColor = 'rgba(42, 100, 150, 0.6)';
        ctx.shadowBlur = 8 + Math.sin(Date.now() * 0.01) * 2;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Draw companion emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // שורה חדשה: הגדרת צבע מילוי אטום
ctx.font = `${player.width}px Arial`;

// Set companion emoji if not already set
if (!player.companionEmojiChar) {
    const companionEmojis = ["👫", "👬", "👭", "👨‍👩‍👧‍👦", "👨‍👨‍👧‍👦", "👩‍👩‍👧‍👦"];
    player.companionEmojiChar = companionEmojis[Math.floor(Math.random() * companionEmojis.length)];
}

ctx.fillText(player.companionEmojiChar, 
            companionX + 15, 
            companionY + companionBob + player.height/2);
        
        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // Connection line between player and companion
        ctx.strokeStyle = 'rgba(42, 100, 150, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        
        ctx.beginPath();
        ctx.moveTo(companionX + 30, companionY + companionBob + player.height/2);
        ctx.lineTo(player.x, playerY + player.height/2);
        ctx.stroke();
        
        // Reset line dash
        ctx.setLineDash([]);
        
        // Occasional particles between player and companion
        if (Math.random() < 0.05 && isMoving) {
            const particleX = companionX + 30 + Math.random() * (player.x - companionX - 30);
            const particleY = companionY + player.height/2 + (Math.random() * 20 - 10);
            
            drawPowerupParticle(particleX, particleY, 'rgba(42, 100, 150, 0.6)');
        }
        
        // Create companion message obstacles with same frequency as regular obstacles
        if (Math.random() < 0.003 && obstacles.length < 3) {
            const encouragement = [
                "🔥 אני מאמין בך! אל תעצור לרגע!",
                "🌟 אתה לגמרי בדרך הנכונה – גאה בך!",
                "💪 תמשיך בדיוק ככה, אתה השראה בשבילי!",
                "🤝 אנחנו יחד בזה, ונגיע רחוק!",
                "👏 עבודה נהדרת! רואים את ההתקדמות שלך!"
            ];
            
            const selectedMessage = encouragement[Math.floor(Math.random() * encouragement.length)];
            
            // Create a companion message obstacle
            const companionObstacle = {
                x: canvas.width,
                y: ground.y - 80,
                width: 50,
                height: 80,
                type: "companion_msg",
                speed: 4,
                text: selectedMessage,
                value: 0, // No direct monetary value
                mentalEffect: 8, // Significant mental boost
                persuasiveTexts: [],
                obstacleTitle: "👫 עידוד מחבר",
                initialText: selectedMessage,
                // Visual properties
                color: "#2a6496", // Blue
                animationOffset: Math.random() * Math.PI * 2,
                bobSpeed: 0.05 + Math.random() * 0.03
            };
            
            obstacles.push(companionObstacle);
        }
    }
    
    // Create thought obstacle with same frequency as regular obstacles
    if (Math.random() < 0.003 && obstacles.length < 3) {
        const thoughts = [
            {
                text: "חיסכון קבוע מביא לביטחון פיננסי",
                option: "אני מתחייב לשים בצד סכום קבוע כל חודש"
            },
            {
                text: "ההוצאות הקטנות מצטברות",
                option: "אני מתחיל להשים לב לכל שקל שיוצא"
            },
            {
                text: "השקעה בעצמי היא ההשקעה הטובה ביותר",
                option: "אני כמו מניה, כל הוצאה גורמת למניה לרדת"
            },
            {
                text: "סבלנות היא המפתח להצלחה פיננסית",
                option: "אני לא מחפש קיצורי דרך, אני בונה יציבות"
            },
            {
                text: "לתכנן מראש חוסך כסף בטווח הארוך",
                option: "אני שולט באופן מלא על החיים שלי"
            }
        ];
        
        const selectedThought = thoughts[Math.floor(Math.random() * thoughts.length)];
        
        // Create a new obstacle of type "thought"
        const thoughtObstacle = {
            x: canvas.width,
            y: ground.y - 80,
            width: 50,
            height: 80,
            type: "thought",
            speed: 4,
            text: selectedThought.text,
            value: 500, // Small bonus when interacting
            mentalEffect: 5, // Small positive mental effect
            persuasiveTexts: [],
            obstacleTitle: "💭 חשוב לזכור ש...",
            initialText: selectedThought.text,
            acceptOption: selectedThought.option, // Custom option text
            // Visual properties
            color: "#3a7a5f",
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.05 + Math.random() * 0.03
        };
        
        obstacles.push(thoughtObstacle);
    }
    
    ctx.restore();
}
        
        // Draw thought bubble - מבוטל כרגע
function drawThoughtBubble(ctx, x, y, text, maxWidth, maxHeight) {
    // פונקציה ריקה - בועות המחשבה הושבתו
    return;
}
        
        // Helper function for rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }
        
        // Update display with animated transitions
        function updateDisplay() {
    // Update score with smooth animation if significant change
    const scoreDisplay = document.getElementById('score-display');
    const assetsDisplay = document.getElementById('assets');
    const currentScoreText = scoreDisplay.textContent;
    const currentScore = parseInt(currentScoreText.match(/\d+/g).join(''));
            
    if (Math.abs(currentScore - score) > 100) {
    // Animate score change
    animateScoreChange(currentScore, score);
} else {
    // Small change, just update
    scoreDisplay.textContent = `סך נכסים פיננסיים: ${score.toLocaleString()} ש"ח`;
}

// Update assets display
assetsDisplay.textContent = score.toLocaleString();

// Update date display with transition effect
const dateDisplay = document.getElementById('date-display');
            
            if (dateDisplay.textContent !== monthNames[currentMonth]) {
                // Save original transform
                const originalTransform = dateDisplay.style.transform;
                
                // Fade out
                dateDisplay.style.opacity = '0';
                dateDisplay.style.transform = 'translateY(-5px)';
                
                // After fade out, update text and fade in
                setTimeout(() => {
                    dateDisplay.textContent = monthNames[currentMonth];
                    dateDisplay.style.opacity = '1';
                    dateDisplay.style.transform = originalTransform;
                }, 300);
            }
            
            // Update monthly stats
            document.getElementById('expenses').textContent = stats.expenses.toLocaleString();
            document.getElementById('income').textContent = stats.income.toLocaleString();
            
            // Highlight changes in income or expenses with color flash
            const expensesElem = document.getElementById('expenses');
            const incomeElem = document.getElementById('income');
            
            // Flash expenses if they changed
            if (stats.expenses > parseInt(expensesElem.getAttribute('data-prev-value') || '0')) {
                flashElement(expensesElem, 'rgba(212, 91, 91, 0.2)');
            }
            
            // Flash income if it changed
            if (stats.income > parseInt(incomeElem.getAttribute('data-prev-value') || '0')) {
                flashElement(incomeElem, 'rgba(58, 122, 95, 0.2)');
            }
            
            // Store current values for next comparison
            expensesElem.setAttribute('data-prev-value', stats.expenses);
            incomeElem.setAttribute('data-prev-value', stats.income);
        }
        
        // Animate score change with counting effect
        function animateScoreChange(startScore, endScore) {
            const scoreDisplay = document.getElementById('score-display');
            const duration = 1000; // 1 second animation
            const startTime = Date.now();
            const scoreChange = endScore - startScore;
            
            // Add highlight effect based on score change direction
            if (scoreChange > 0) {
                scoreDisplay.style.color = 'var(--success-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(58, 122, 95, 0.3)';
            } else if (scoreChange < 0) {
                scoreDisplay.style.color = 'var(--danger-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(212, 91, 91, 0.3)';
            }
            
            // Animation function
            function animate() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Easing function for smoother animation
                const easedProgress = progress < 0.5 ? 
                    4 * progress * progress * progress : 
                    1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                // Calculate current value
                const currentValue = Math.round(startScore + scoreChange * easedProgress);
                
                // Update display
                scoreDisplay.textContent = `סך נכסים פיננסיים: ${currentValue.toLocaleString()} ש"ח`;
                
                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Reset style after animation
                    setTimeout(() => {
                        scoreDisplay.style.color = 'var(--primary-color)';
                        scoreDisplay.style.textShadow = 'none';
                    }, 500);
                }
            }
            
            // Start animation
            animate();
        }
        
        // Flash element background color
        function flashElement(element, color) {
            // Save original background
            const originalBg = element.style.backgroundColor;
            const originalTransition = element.style.transition;
            
            // Apply flash
            element.style.transition = 'background-color 0.1s ease-in';
            element.style.backgroundColor = color;
            
            // Remove flash with transition
            setTimeout(() => {
                element.style.transition = 'background-color 0.5s ease-out';
                element.style.backgroundColor = originalBg;
                
                // Reset transition after animation
                setTimeout(() => {
                    element.style.transition = originalTransition;
                }, 500);
            }, 100);
        }
        
        // Show job offer with enhanced visuals
function showJobOffer() {
    gamePaused = true;
    isMoving = false; // עצירת התנועה באופן מוחלט
    jobOfferStage = 0;
    
    // Prepare dialog with animation
    const jobOfferDialog = document.getElementById('job-offer');
    jobOfferDialog.style.animation = 'job-offer-appear 0.5s ease forwards';
    
    // Add animation style if not already present
    if (!document.getElementById('job-offer-style')) {
        const style = document.createElement('style');
        style.id = 'job-offer-style';
        style.textContent = `
            @keyframes job-offer-appear {
                from {
                    opacity: 0;
                    transform: translate(-50%, -60%) scale(0.9);
                }
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1);
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // יצירת שכבת האפלה מאחורי הדיאלוג במקום ה-overlay המקורי
    const dialogOverlay = createDialogOverlay();
    
    // שמירת הפניה לשכבת האפלה על האובייקט של הדיאלוג
    jobOfferDialog.dialogOverlay = dialogOverlay;
    
    // שינוי ה־z-index של הדיאלוג
    jobOfferDialog.style.zIndex = '100';
    
    // Show dialog
    jobOfferDialog.style.display = 'block';
    
    // Add career icon animation
    const careerIcon = document.createElement('div');
    careerIcon.className = 'career-icon';
    careerIcon.style.position = 'absolute';
    careerIcon.style.top = '-40px';
    careerIcon.style.left = '50%';
    careerIcon.style.transform = 'translateX(-50%)';
    careerIcon.style.fontSize = '50px';
    careerIcon.style.opacity = '0';
    careerIcon.style.transition = 'all 0.5s ease';
    careerIcon.textContent = '💼';
    
    jobOfferDialog.appendChild(careerIcon);
    
    // Animate icon
    setTimeout(() => {
        careerIcon.style.opacity = '1';
        careerIcon.style.top = '-60px';
    }, 300);
}
        
        // Show job offer followup with enhanced visuals
        function showJobOfferFollowup() {
            // Hide job offer dialog
            const jobOfferDialog = document.getElementById('job-offer');
            jobOfferDialog.style.animation = 'job-offer-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('job-offer-exit-style')) {
                const style = document.createElement('style');
                style.id = 'job-offer-exit-style';
                style.textContent = `
                    @keyframes job-offer-exit {
                        from {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        to {
                            opacity: 0;
                            transform: translate(-50%, -60%) scale(0.9);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // After exit animation, hide dialog and show followup
            setTimeout(() => {
                jobOfferDialog.style.display = 'none';
                
                // Check if there's a career icon to remove
                const careerIcon = jobOfferDialog.querySelector('.career-icon');
                if (careerIcon) {
                    jobOfferDialog.removeChild(careerIcon);
                }
                
                // Set followup text
                document.getElementById('followup-text').textContent = jobOfferTexts[jobOfferStage];
                
                // Show followup dialog with entrance animation
                const followupDialog = document.getElementById('job-offer-followup');
                followupDialog.style.animation = 'job-followup-appear 0.4s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('job-followup-style')) {
                    const style = document.createElement('style');
                    style.id = 'job-followup-style';
                    style.textContent = `
                        @keyframes job-followup-appear {
                            from {
                                opacity: 0;
                                transform: translate(-50%, -40%) scale(0.95);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                followupDialog.style.display = 'block';
                
                // Add persuasion icon based on stage
                let persuasionIcon = '💰'; // Default money
                
                if (jobOfferStage === 1) persuasionIcon = '📈'; // Growth
                if (jobOfferStage === 2) persuasionIcon = '🚀'; // Career
                if (jobOfferStage === 3) persuasionIcon = '⏱️'; // Time/flexibility
                
                const iconElem = document.createElement('div');
                iconElem.className = 'persuasion-icon';
                iconElem.style.position = 'absolute';
                iconElem.style.top = '-40px';
                iconElem.style.left = '50%';
                iconElem.style.transform = 'translateX(-50%)';
                iconElem.style.fontSize = '40px';
                iconElem.style.opacity = '0';
                iconElem.style.transition = 'all 0.5s ease';
                iconElem.textContent = persuasionIcon;
                
                followupDialog.appendChild(iconElem);
                
                // Animate icon
                setTimeout(() => {
                    iconElem.style.opacity = '1';
                    iconElem.style.top = '-50px';
                }, 300);
            }, 300);
        }
        
        // Game over with enhanced visuals
        function gameOver(reason) {
            gameRunning = false;
            
            // Update game stats
            document.getElementById('game-over-reason').textContent = reason;
            document.getElementById('final-score').textContent = score.toLocaleString();
            document.getElementById('months-played').textContent = stats.monthsPlayed;
            document.getElementById('powerups-collected').textContent = stats.powerupsCollected;
            document.getElementById('obstacles-avoided').textContent = stats.obstaclesFaced;
            
            // Create dramatic overlay
            const overlay = document.createElement('div');
            overlay.className = 'game-over-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            overlay.style.transition = 'background-color 1.5s ease';
            overlay.style.zIndex = '90';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in dark overlay
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
            }, 100);
            
            // Show game over with enhanced animation
            setTimeout(() => {
                const gameOverScreen = document.getElementById('game-over');
                gameOverScreen.style.display = 'block';
                gameOverScreen.style.animation = 'game-over-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('game-over-style')) {
                    const style = document.createElement('style');
                    style.id = 'game-over-style';
                    style.textContent = `
                        @keyframes game-over-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.05);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Add dramatic visual effects
                createGameOverEffect();
            }, 800);
        }
        
        // Create visual effects for game over
        function createGameOverEffect() {
            // Add falling coins/money effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'falling-money';
                    
                    // Randomize coin appearance - dollar, shekel, or coins
                    const coinTypes = ['💰', '💸', '₪', '💵'];
                    const coinText = coinTypes[Math.floor(Math.random() * coinTypes.length)];
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.fontSize = `${20 + Math.random() * 20}px`;
                    coin.style.opacity = '0.7';
                    coin.style.zIndex = '91';
                    coin.style.color = '#d45b5b';
                    coin.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.5)';
                    coin.textContent = coinText;
                    
                    // Position randomly at top
                    const startX = Math.random() * window.innerWidth;
                    coin.style.top = `-50px`;
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation for falling
                    const fallDuration = 3 + Math.random() * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 720;
                    const horizontalMovement = (Math.random() - 0.5) * 100;
                    const delay = Math.random() * 2;
                    
                    // Create keyframes for this specific coin
                    const keyframes = `
                        @keyframes fall-${Date.now()}-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0.7;
                            }
                            80% {
                                opacity: 0.7;
                            }
                            100% {
                                transform: translateY(${window.innerHeight + 100}px) 
                                           translateX(${horizontalMovement}px) 
                                           rotate(${rotationSpeed}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    
                    // Add style for this specific animation
                    const style = document.createElement('style');
                    style.textContent = keyframes;
                    document.head.appendChild(style);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `fall-${Date.now()}-${i} ${fallDuration}s cubic-bezier(0.4, 0, 1, 1) forwards`;
                    }, delay * 1000);
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (style.parentNode) {
                            style.parentNode.removeChild(style);
                        }
                    }, (fallDuration + delay + 0.5) * 1000);
                }, i * 200); // Stagger coin creation
            }
            
            // Add crack in ground effect
            const crack = document.createElement('div');
            crack.className = 'ground-crack';
            crack.style.position = 'absolute';
            crack.style.top = `${ground.y - 10}px`;
            crack.style.left = '50%';
            crack.style.transform = 'translateX(-50%)';
            crack.style.width = '0';
            crack.style.height = '20px';
            crack.style.backgroundColor = '#333';
            crack.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5), 0 0 5px rgba(255, 0, 0, 0.3)';
            crack.style.zIndex = '91';
            
            document.getElementById('game-container').appendChild(crack);
            
            // Create crack animation
            const crackStyle = document.createElement('style');
            crackStyle.textContent = `
                @keyframes crack-grow {
                    0% { width: 0; }
                    60% { width: 60%; }
                    100% { width: 50%; }
                }
            `;
            document.head.appendChild(crackStyle);
            
            // Apply animation
            crack.style.animation = 'crack-grow 1.2s ease-out forwards';
        }
        
        // Win game with enhanced visuals
        function winGame() {
            gameRunning = false;
            
            // Update win stats
            document.getElementById('win-months').textContent = stats.monthsPlayed;
            document.getElementById('win-powerups').textContent = stats.powerupsCollected;
            document.getElementById('win-obstacles').textContent = stats.obstaclesFaced;
            
            // Create celebratory overlay
            const overlay = document.createElement('div');
            overlay.className = 'win-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'radial-gradient(circle, rgba(42, 100, 150, 0) 0%, rgba(42, 100, 150, 0.3) 100%)';
            overlay.style.transition = 'all 1.5s ease';
            overlay.style.zIndex = '90';
            overlay.style.opacity = '0';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in overlay
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 100);
            
            // Create celebration effects
            createWinEffects();
            
            // Show win screen with enhanced animation
            setTimeout(() => {
                const winScreen = document.getElementById('win-screen');
                winScreen.style.display = 'block';
                winScreen.style.animation = 'win-screen-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('win-screen-style')) {
                    const style = document.createElement('style');
                    style.id = 'win-screen-style';
                    style.textContent = `
                        @keyframes win-screen-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.1);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }, 1500);
        }
        
        // Create celebration effects for win
        function createWinEffects() {
            // Create fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createFirework();
                }, i * 300);
            }
            
            // Create golden rain
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    createGoldenRain();
                }, Math.random() * 2000);
            }
            
            // Create floating achievement icons
            const achievementIcons = ['💰', '📈', '🏆', '💪', '📊', '✅', '🎯'];
            
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const icon = document.createElement('div');
                    icon.className = 'floating-achievement';
                    
                    // Style the icon
                    icon.style.position = 'absolute';
                    icon.style.fontSize = `${30 + Math.random() * 20}px`;
                    icon.style.opacity = '0';
                    icon.style.zIndex = '91';
                    icon.textContent = achievementIcons[Math.floor(Math.random() * achievementIcons.length)];
                    
                    // Position randomly
                    icon.style.top = `${Math.random() * (window.innerHeight * 0.7)}px`;
                    icon.style.left = `${Math.random() * window.innerWidth}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(icon);
                    
                    // Define animation
                    const floatDuration = 5 + Math.random() * 3;
                    const floatDistance = 100 + Math.random() * 200;
                    
                    const iconStyle = document.createElement('style');
                    iconStyle.textContent = `
                        @keyframes float-icon-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0;
                            }
                            10% {
                                opacity: 0.9;
                            }
                            90% {
                                opacity: 0.9;
                            }
                            100% {
                                transform: translateY(-${floatDistance}px) rotate(${Math.random() * 40 - 20}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    document.head.appendChild(iconStyle);
                    
                    // Apply animation
                    icon.style.animation = `float-icon-${i} ${floatDuration}s ease-out forwards`;
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (icon.parentNode) {
                            icon.parentNode.removeChild(icon);
                        }
                        if (iconStyle.parentNode) {
                            iconStyle.parentNode.removeChild(iconStyle);
                        }
                    }, floatDuration * 1000 + 100);
                }, i * 500 + Math.random() * 1000);
            }
        }
        
        // Create a firework effect
        function createFirework() {
            // Create firework explosion at random position
            const explosionX = Math.random() * window.innerWidth;
            const explosionY = Math.random() * (window.innerHeight * 0.6);
            
            // Random firework color
            const colors = [
                '255, 215, 0',  // Gold
                '42, 100, 150', // Blue
                '58, 122, 95',  // Green
                '255, 127, 80', // Coral
                '147, 112, 219' // Purple
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Create particles
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'firework-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = `rgba(${color}, 0.8)`;
                particle.style.boxShadow = `0 0 6px rgba(${color}, 0.5)`;
                particle.style.zIndex = '92';
                
                // Position at explosion center
                particle.style.top = `${explosionY}px`;
                particle.style.left = `${explosionX}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create specific animation for this particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 150;
                const duration = 0.8 + Math.random() * 0.6;
                
                const particleKeyframes = `
                    @keyframes firework-particle-${Date.now()}-${i} {
                        0% { 
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1.5); 
                        }
                        100% { 
                            opacity: 0;
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5); 
                        }
                    }
                `;
                
                const particleStyle = document.createElement('style');
                particleStyle.textContent = particleKeyframes;
                document.head.appendChild(particleStyle);
                
                // Apply animation
                particle.style.animation = `firework-particle-${Date.now()}-${i} ${duration}s ease-out forwards`;
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (particleStyle.parentNode) {
                        particleStyle.parentNode.removeChild(particleStyle);
                    }
                }, duration * 1000 + 100);
            }
        }
        
        // Create golden rain for win effect
        function createGoldenRain() {
            const coin = document.createElement('div');
            coin.className = 'golden-rain';
            
            // Style coin
            coin.style.position = 'absolute';
            coin.style.fontSize = `${15 + Math.random() * 10}px`;
            coin.style.opacity = '0.9';
            coin.style.zIndex = '91';
            coin.style.color = '#FFD700';
            coin.style.textShadow = '0 0 5px rgba(255, 215, 0, 0.7)';
            coin.textContent = '₪';
            
            // Position at top with random horizontal placement
            const startX = Math.random() * window.innerWidth;
            coin.style.top = `-20px`;
            coin.style.left = `${startX}px`;
            
            document.getElementById('game-container').appendChild(coin);
            
            // Create animation
            const fallDuration = 3 + Math.random() * 2;
            const swayAmount = 50 + Math.random() * 50;
            const direction = Math.random() > 0.5 ? 1 : -1;
            const rotationAmount = Math.random() * 360;
            
            const keyframes = `
                @keyframes golden-rain-${Date.now()} {
                    0% {
                        transform: translateY(0) rotate(0deg);
                        opacity: 0;
                    }
                    10% {
                        opacity: 0.9;
                    }
                    100% {
                        transform: translateY(${window.innerHeight + 50}px) 
                                   translateX(${swayAmount * direction}px) 
                                   rotate(${rotationAmount}deg);
                        opacity: 0.7;
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = keyframes;
            document.head.appendChild(style);
            
            // Apply animation
            coin.style.animation = `golden-rain-${Date.now()} ${fallDuration}s ease-in forwards`;
            
            // Remove elements after animation
            setTimeout(() => {
                if (coin.parentNode) {
                    coin.parentNode.removeChild(coin);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, fallDuration * 1000 + 100);
        }
        // Reset game with simple initialization
function resetGame() {
    // Initialize game variables directly without fade effects
    gameRunning = true;
    gamePaused = false;
    score = 0;
    currentMonth = 0;
    currentMonthTimer = 0;
    obstacles = [];
    powerups = [];
    pendingObstacles = [];
    isMoving = false;
        
    // איפוס המערכת החדשה של ימים שנותרו
currentHour = 5; // משמר למקרה שצריך לחישובים אחרים
currentMinute = 0; // משמר למקרה שצריך לחישובים אחרים
isDayTime = true;
lastTimeUpdate = Date.now(); // חשוב: איפוס הזמן האחרון
lastDaysRemaining = 30; // איפוס מספר הימים הנותרים

    // הסתר את לוח המחוונים וכפתור החץ בעת אתחול המשחק מחדש
    document.querySelector('.dashboard-container').style.display = 'none';
    document.getElementById('forward-arrow-button').style.display = 'none';

    // Reset stats
    stats = {
        monthsPlayed: 0,
        powerupsCollected: 0,
        obstaclesAvoided: 0,
        obstaclesFaced: 0,
        expenses: 0,
        income: 5000,
        mentalHealth: 100,
        physicalHealth: 100
    };

    // אתחול מהירות היום
    updateDaySpeed();
    
    // Reset monthly counters
monthlyObstacleCounter = {
    person: 0,
    ad: 0,
    food: 0,
    thought: 0,
    companion_msg: 0,
    financial_question: 0
};

monthlyPowerupCounter = {
    money: 0,
    earlyRise: 0,
    earlySleep: 0,
    healthyFood: 0,
    exercise: 0,
    companion: 0
};
    
    // Reset achievements
    achievements = {
        firstMonth: { earned: false, text: "הישרדות חודש ראשון" },
        saveHero: { earned: false, text: "חסכת 50,000 ש\"ח" },
        powerCollector: { earned: false, text: "אימצת 10 הרגלים פיננסיים חיוביים" },
        resistanceMaster: { earned: false, text: "פתרת 20 דילמות פיננסיות" },
        mentalStrength: { earned: false, text: "שמרת על חוסן מנטלי גבוה" }
    };
    
    // Reset player
player.powerUp = false;
player.powerUpTime = 0;
player.companion = false;
player.currentSpeed = player.baseSpeed;

// וודא שהשחקן חוזר למיקום המקורי שלו על הקרקע
originalPlayerY = ground.y - player.height - 5; // 5px gap
player.y = originalPlayerY;
    
    // Adjust player size based on screen dimensions
    let scaleFactor = Math.min(window.innerWidth, window.innerHeight) / 500;
    scaleFactor = Math.max(0.5, Math.min(1.5, scaleFactor)); // Limit between 0.5 and 1.5
    player.width = 50 * scaleFactor;
    player.height = 80 * scaleFactor;
    
    // Update player position after size change - with a small 5px gap above ground
player.y = ground.y - player.height - 5; // 5px gap for better visual
originalPlayerY = player.y; // Update the original position variable
    
    // Reset displays
    updateDisplay();
    updatePlayerCondition();
    updateClockDisplay();
    
    // Hide status displays
    document.getElementById('status-negative').style.display = 'none';
    document.getElementById('status-weight').style.display = 'none';
    
    // Hide power meter
    document.getElementById('power-meter').style.display = 'none';
    
    // Hide all dialogs
    document.getElementById('job-offer').style.display = 'none';
    document.getElementById('job-offer-followup').style.display = 'none';
    document.getElementById('obstacle-dialog').style.display = 'none';
    document.getElementById('powerup-dialog').style.display = 'none';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('win-screen').style.display = 'none';
    
    // Reset tutorial and show it
    tutorialShown = true;
    document.getElementById('tutorial-message').style.display = 'block';
    document.getElementById('movement-instruction').style.display = 'none';
    
    // אתחול מסכי המדריך מחדש - הצג רק את הראשון
    currentTutorialScreen = 1;
    for (let i = 1; i <= totalTutorialScreens; i++) {
        const screen = document.getElementById(`tutorial-screen-${i}`);
        if (screen) {
            screen.style.display = i === 1 ? 'block' : 'none';
        }
    }
                
    // Reset finance tip
    document.getElementById('finance-tip').style.opacity = '0';
    
    // Reset obstacle dialog tracking
    currentObstacle = null;
    lastObstacleTime = 0;
    persuasionStage = 0;
    
    // Reset powerup dialog tracking
    currentPowerup = null;
    powerupFollowupIndex = 0;
    
    // נקה קודם אלמנטים קיימים של כוכבים, עננים וציפורים
    document.querySelectorAll('.star, .cloud, .bird').forEach(elem => {
        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    });
    
    // Create new stars and environmental elements
    createStars();
    createClouds();
    createBirds();
}
        
        // Handle movement events with feedback
// שמירת מיקום Y מקורי של השחקן
let originalPlayerY; 

function startMoving() {
    if (!isMoving) {
        isMoving = true;
        
        // בעת התחלת תנועה, עדכן את זמן המשחק להתחלת המדידה
        lastTimeUpdate = Date.now();
        
        // שמירת המיקום המקורי בפעם הראשונה שנלחץ
        if (!originalPlayerY) {
            originalPlayerY = ground.y - player.height - 5; // 5px gap above ground
        }
        
        // Ensure we're showing the right emoji immediately
        updatePlayerEmoji();
        
        // Create dust particles at player's feet
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                createDustParticle();
            }, i * 100);
        }
    }
}

// הוספת פונקציה חדשה שתעדכן את האימוג'י של השחקן
function updatePlayerEmoji() {
    const healthFactor = stats.physicalHealth / 100;
    const mentalFactor = stats.mentalHealth / 100;
    
    if (!isMoving) {
        // When player isn't moving, always show standing emoji
        const standingEmojis = ["🧍‍♂️", "🧍‍♀️"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    } else if (healthFactor > 0.7 && mentalFactor > 0.7) {
        // Excellent health - running
        const runningEmojis = ["🏃‍♂️", "🏃‍♀️"];
        player.emojiChar = runningEmojis[Math.floor(Math.random() * runningEmojis.length)];
    } else if (healthFactor > 0.4 && mentalFactor > 0.4) {
        // Good health - walking
        const walkingEmojis = ["🚶‍♂️", "🚶‍♀️"];
        player.emojiChar = walkingEmojis[Math.floor(Math.random() * walkingEmojis.length)];
    } else {
        // Poor health - standing
        const standingEmojis = ["🧍‍♂️", "🧍‍♀️"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    }
}

function stopMoving() {
    if (isMoving) {
        isMoving = false;
        
        // וידוא שהשחקן חוזר למיקום המקורי
        player.y = originalPlayerY;
        
        // Create stopping dust effect
        createDustParticle();
    }
}
        
        // Handle window resize with smooth transitions
        function handleResize() {
            // Store old dimensions for transition calculations
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            const oldGroundY = ground.y;
            
            // Update canvas dimensions
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update ground position
            ground.y = canvas.height * 0.8;
            ground.width = canvas.width;
            ground.height = canvas.height * 0.2;
            
            // Adjust player size and position based on screen dimensions
            let scaleFactor = Math.min(window.innerWidth, window.innerHeight) / 500;
            scaleFactor = Math.max(0.5, Math.min(1.5, scaleFactor)); // Limit between 0.5 and 1.5
            
            player.width = 50 * scaleFactor;
            player.height = 80 * scaleFactor;
            
            // Maintain relative position to ground
            player.y = ground.y - player.height;
            
            // Scale player's X position proportionally to new width
            player.x = (player.x / oldWidth) * canvas.width;
            
            // Adjust player base speed for screen size
            player.baseSpeed = 5 * scaleFactor;
            updatePlayerCondition(); // Update speed based on health
            
            // Update positions of obstacles and powerups
            obstacles.forEach(obstacle => {
                // Scale X position proportionally
                obstacle.x = (obstacle.x / oldWidth) * canvas.width;
                
                // Adjust Y position relative to new ground
                const oldRelativeY = (obstacle.y - oldGroundY) / (oldHeight - oldGroundY);
                obstacle.y = ground.y + oldRelativeY * (canvas.height - ground.y);
            });
            
            powerups.forEach(powerup => {
                // Scale X position proportionally
                powerup.x = (powerup.x / oldWidth) * canvas.width;
                
                // Adjust Y position relative to new ground
                const oldRelativeY = powerup.y / oldHeight;
                powerup.y = oldRelativeY * canvas.height;
                
                // Update original Y for floating animation
                if (powerup.originalY) {
                    powerup.originalY = powerup.y;
                }
            });
            
            // Recreate environmental elements for new dimensions
            createStars();
            createClouds();
            
            // Adjust sun and moon positions
            updateCelestialBodies();
        }
        
        // Helper function to schedule obstacles
        function scheduleObstacle(delayMs) {
            pendingObstacles.push({
                time: Date.now() + delayMs
            });
        }
        
        // Mobile-specific optimizations
function optimizeForMobile() {
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (isMobile) {
        // Reduce visual effects for better performance
        const style = document.createElement('style');
        style.textContent = `
            @media (max-width: 768px) {
                #game-canvas {
                    image-rendering: optimizeSpeed;
                }
                .health-bars {
                    width: 220px;
                    padding: 10px;
                }
                .health-bar .label {
                    font-size: 12px;
                }
                .health-bar .bar {
                    height: 10px;
                }
                
                /* Reduce particle effects on mobile */
                .dust-particle, .powerup-particle, .companion-particle {
                    opacity: 0.7 !important;
                }

                /* Smaller celestial bodies */
                #sun, #moon {
                    width: 40px !important;
                    height: 40px !important;
                }

                /* Fewer stars for better performance */
                .star {
                    opacity: 0.5 !important;
                }
            }
        `;
document.head.appendChild(style);
                
                // Reduce number of particles in effects
                const originalCreateDustParticle = createDustParticle;
                createDustParticle = function() {
                    if (Math.random() < 0.5) { // Only create dust particles 50% of the time
                        originalCreateDustParticle();
                    }
                };
                
                // Reduce firework particles
                const originalCreateFirework = createFirework;
                createFirework = function() {
                    const tempCreate = (Math.random() < 0.8); // 80% chance to create
                    if (tempCreate) {
                        originalCreateFirework();
                    }
                };
            }
        }

        // פונקציית עזר ליצירת שכבת האפלה מאחורי תיבות דו-שיח
        function createDialogOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    overlay.style.position = 'absolute';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.65)';
    overlay.style.zIndex = '95';
    overlay.style.backdropFilter = 'blur(2px)';
    overlay.style.transition = 'opacity 0.3s ease';
    overlay.style.opacity = '0';
    
    document.getElementById('game-container').appendChild(overlay);
    
    // אנימציית הופעה הדרגתית
    setTimeout(() => {
        overlay.style.opacity = '1';
    }, 10);
    
    return overlay;
}
        
        // Start game with direct initialization
function startGame() {
    try {
        // חשוב: הגדרת canvas ראשוני
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Initialize the game directly
        resetGame();

        // אתחול ראשוני של מהירות היום
        updateDaySpeed();
        
        // Handle resize event
        window.removeEventListener('resize', handleResize);
        window.addEventListener('resize', handleResize);
        handleResize();
        
        // Show tutorial initially
        tutorialShown = true;
        document.getElementById('tutorial-message').style.display = 'block';
        
        // הגדר את המשחק למצב ריצה רק אחרי סגירת ההדרכה
        gameRunning = false;
        
        // Add welcome message
        showWelcomeMessage();
        
        // Clear any existing game loops
        if (window.gameLoopInterval) {
            clearInterval(window.gameLoopInterval);
        }
        
        // Game loop - run at 60fps
        window.gameLoopInterval = setInterval(() => {
            if (gameRunning) {
                updateGame();
            }
        }, frameTime);
        
        console.log("Game started successfully");
    } catch (error) {
        console.error("Error starting game:", error);
    }
}
        
        // Show welcome message with enhanced visuals
function showWelcomeMessage() {
    // וודא שהמשחק מוכן לפעולה
    gameRunning = true;
    return;
}
        
        // Event listeners - keydown and keyup for space key
document.addEventListener('keydown', function(event) {
    if (event.code === 'Space') {
        if (tutorialShown) {
            tutorialShown = false;
            document.getElementById('tutorial-message').style.display = 'none';
        }
        // אין יותר הפעלת תנועה על ידי מקש הרווח
    }
});

document.addEventListener('keyup', function(event) {
    // אין יותר הפסקת תנועה על ידי מקש הרווח
});
        
        // ביטול לחיצות מסך ישירות - רק כפתור החץ יפעיל תנועה
// לא נוסיף יותר מאזיני אירועים למסך הקנבס
// אבל נשאיר את האפשרות לסגור את ההודעה של התחלת המשחק ע"י לחיצה על המסך

// ביטול לחיצות מסך ישירות - רק כפתור החץ יפעיל תנועה
canvas.addEventListener('touchstart', function(event) {
    // מניעת אירועי מגע על הקנבס
    event.preventDefault();
    
    // אם יש הודעת הדרכה - לא לעשות כלום (לא לסגור את ההדרכה)
});

// מאזין לחיצה לא משפיע על הודעת ההדרכה
canvas.addEventListener('mousedown', function(event) {
    // הסרנו את הקוד שמסתיר את מסך ההדרכה בלחיצה על הקנבס
    // רק כפתורי "הבא" ו"התחל" יכולים לשנות את מצב המדריך
});

// פונקציה חדשה לעדכון מצב הכפתור
function updateArrowButtonAttention() {
    const arrowButton = document.getElementById('forward-arrow-button');
    if (!arrowButton) return;
    
    // אם המשחק רץ, אך השחקן לא זז, הוסף את האנימציה
    if (gameRunning && !gamePaused && !isMoving) {
        // בדוק אם כבר יש את המחלקה
        if (!arrowButton.classList.contains('attention-needed')) {
            arrowButton.classList.add('attention-needed');
        }
    } else {
        // הסר את המחלקה אם השחקן זז או המשחק לא פעיל
        arrowButton.classList.remove('attention-needed');
    }
}

// הוספת מאזיני אירועים לכפתור החץ עם ניסיון חוזר
function setupArrowButtonEvents() {
    const arrowButton = document.getElementById('forward-arrow-button');
    if (!arrowButton) {
        // אם הכפתור לא נמצא, ננסה שוב בעוד חצי שנייה
        console.log("Arrow button not found, retrying in 500ms");
        setTimeout(setupArrowButtonEvents, 500);
        return;
    }
    
    // ניקוי מאזינים קודמים למניעת כפילויות
    const newArrowButton = arrowButton.cloneNode(true);
    if (arrowButton.parentNode) {
        arrowButton.parentNode.replaceChild(newArrowButton, arrowButton);
    }
    
    // הוספת מאזינים לעותק החדש
    newArrowButton.addEventListener('mousedown', function(event) {
        if (gameRunning && !gamePaused) {
            startMoving();
        }
    });

    newArrowButton.addEventListener('mouseup', function(event) {
        if (gameRunning && !gamePaused) {
            stopMoving();
        }
    });

    newArrowButton.addEventListener('touchstart', function(event) {
    if (gameRunning && !gamePaused) {
        event.preventDefault(); // מניעת התנהגות ברירת מחדל של מגע
        event.stopPropagation(); // עצירת הפצת האירוע
        startMoving();
    }
});

newArrowButton.addEventListener('touchend', function(event) {
    if (gameRunning && !gamePaused) {
        event.preventDefault();
        event.stopPropagation(); // עצירת הפצת האירוע
        stopMoving();
    }
});

    // הוספת מאזין למקרה שהמשתמש עוזב את הכפתור באמצע לחיצה
    newArrowButton.addEventListener('mouseleave', function(event) {
        if (gameRunning && !gamePaused && isMoving) {
            stopMoving();
        }
    });
    
    console.log("Arrow button event listeners setup complete");
}

// Obstacle dialog buttons
document.getElementById('ignore-btn').addEventListener('click', function() {
    continuePersuasion(); // Continue to next persuasion stage or close dialog
});
        
        document.getElementById('accept-btn').addEventListener('click', function() {
            acceptObstacle(); // Accept obstacle with all negative consequences
        });
        
        // Powerup dialog buttons
        document.getElementById('powerup-yes-btn').addEventListener('click', function() {
            powerupYesResponse();
        });
        
        document.getElementById('powerup-no-btn').addEventListener('click', function() {
            powerupNoResponse();
        });
        
        // מעקב אחר המסך הנוכחי במדריך
let currentTutorialScreen = 1;
const totalTutorialScreens = 7; // עודכן מ-6 ל-7 בגלל הוספת מסך
let playerGender = "male"; // ברירת מחדל

// מעבר למסך הבא במדריך
function nextTutorialScreen() {
    // הסתר את המסך הנוכחי
    const currentScreen = document.getElementById(`tutorial-screen-${currentTutorialScreen}`);
    if (currentScreen) {
        currentScreen.style.display = 'none';
    }
    
    // עבור למסך הבא
    currentTutorialScreen++;
    
    // הצג את המסך הבא אם קיים
    if (currentTutorialScreen <= totalTutorialScreens) {
        const nextScreen = document.getElementById(`tutorial-screen-${currentTutorialScreen}`);
        if (nextScreen) {
            nextScreen.style.display = 'block';
        }
    }
}

// הוסף מאזיני אירועים לכפתורי "הבא"
document.querySelectorAll('.next-btn').forEach(button => {
    button.addEventListener('click', function() {
        // אנימציית לחיצה
        this.style.transform = 'scale(0.95)';
        
        // השהיה קצרה לאפקט הלחיצה
        setTimeout(() => {
            this.style.transform = '';
            nextTutorialScreen();
        }, 100);
    });
});

// הוסף מאזיני אירועים לכפתורי בחירת מין
document.getElementById('male-btn').addEventListener('click', function() {
    playerGender = "male";
    this.style.transform = 'scale(0.95)';
    
    setTimeout(() => {
        this.style.transform = '';
        nextTutorialScreen();
    }, 100);
});

document.getElementById('female-btn').addEventListener('click', function() {
    playerGender = "female";
    this.style.transform = 'scale(0.95)';
    
    setTimeout(() => {
        this.style.transform = '';
        nextTutorialScreen();
    }, 100);
});

// Start button click
document.getElementById('start-btn').addEventListener('click', function() {
    tutorialShown = false;
    
    // Add button press animation
    const button = document.getElementById('start-btn');
    button.style.transform = 'scale(0.95)';
    button.style.backgroundColor = '#1e5180';
    
    // Reset after short delay
    setTimeout(() => {
        button.style.transform = '';
        button.style.backgroundColor = '';
        
        // Hide tutorial immediately without fade
        const tutorial = document.getElementById('tutorial-message');
        tutorial.style.display = 'none';
        
        // הצג את לוח המחוונים וכפתור החץ רק כאשר המשחק מתחיל באמת
        document.querySelector('.dashboard-container').style.display = 'block';
        document.getElementById('forward-arrow-button').style.display = 'block';
        
        // Make sure the game is running
        gameRunning = true;
        console.log("Game set to running state");
        
        // Update critical game state
        lastTimeUpdate = Date.now(); // חידוש זמן התחלתי
        
        // אתחול שעון המשחק
        currentHour = 5;
        currentMinute = 0;
        
        // Update the display and player condition
        updateDisplay();
        updatePlayerCondition();
        
        // ודא שלולאת המשחק פועלת
        if (!window.gameLoopInterval) {
            window.gameLoopInterval = setInterval(() => {
                if (gameRunning) {
                    updateGame();
                }
            }, frameTime);
            console.log("Game loop started");
        }
    }, 100);
});

// מניעת סגירת מסך ההדרכה בלחיצה על האזור שלו (אבל לא על הכפתורים)
document.getElementById('tutorial-message').addEventListener('mousedown', function(event) {
    // אם הלחיצה לא על אחד הכפתורים, מנע שיבוע (bubbling) של האירוע
    if (!event.target.classList.contains('next-btn') && event.target.id !== 'start-btn') {
        event.stopPropagation();
    }
});

// גם למקרה של מכשירי מגע
document.getElementById('tutorial-message').addEventListener('touchstart', function(event) {
    // אם הנגיעה לא על אחד הכפתורים, מנע שיבוע (bubbling) ופעולת ברירת מחדל
    if (!event.target.classList.contains('next-btn') && event.target.id !== 'start-btn') {
        event.stopPropagation();
        event.preventDefault();
    }
});
        
        // Job offer buttons
        document.getElementById('yes-btn').addEventListener('click', function() {
            gameOver("החלפת קריירה. איבדת את היציבות הפיננסית בתקופת המעבר.");
        });
        
        document.getElementById('no-btn').addEventListener('click', function() {
            showJobOfferFollowup();
        });
        
        document.getElementById('followup-yes-btn').addEventListener('click', function() {
            gameOver("החלפת קריירה. איבדת את היציבות הפיננסית בתקופת המעבר.");
        });
        
        document.getElementById('followup-no-btn').addEventListener('click', function() {
            jobOfferStage++;
            if (jobOfferStage < jobOfferTexts.length) {
                // Update text with animation
                const textElement = document.getElementById('followup-text');
                
                // Fade out current text
                textElement.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
                textElement.style.opacity = '0';
                textElement.style.transform = 'translateY(-10px)';
                
                // Update text and fade in
                setTimeout(() => {
                    textElement.textContent = jobOfferTexts[jobOfferStage];
                    textElement.style.opacity = '1';
                    textElement.style.transform = 'translateY(0)';
                }, 200);
                
                // Update icon
                const icon = document.querySelector('.persuasion-icon');
                if (icon) {
                    // Animate icon change
                    icon.style.transform = 'translateX(-50%) scale(0.8)';
                    icon.style.opacity = '0.5';
                    
                    setTimeout(() => {
                        // Change icon based on stage
                        let persuasionIcon = '💰'; // Default money
                        if (jobOfferStage === 1) persuasionIcon = '📈'; // Growth
                        if (jobOfferStage === 2) persuasionIcon = '🚀'; // Career
                        if (jobOfferStage === 3) persuasionIcon = '⏱️'; // Time/flexibility
                        
                        icon.textContent = persuasionIcon;
                        icon.style.transform = 'translateX(-50%) scale(1.2)';
                        icon.style.opacity = '1';
                        
                        // Reset after animation
                        setTimeout(() => {
                            icon.style.transform = 'translateX(-50%) scale(1)';
                        }, 200);
                    }, 200);
                }
            } else {
                // Exit animation for dialog
                const followupDialog = document.getElementById('job-offer-followup');
                followupDialog.style.animation = 'job-followup-exit 0.3s ease forwards';
                
                // Add exit animation style if not already present
                if (!document.getElementById('job-followup-exit-style')) {
                    const style = document.createElement('style');
                    style.id = 'job-followup-exit-style';
                    style.textContent = `
                        @keyframes job-followup-exit {
                            from {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1);
                            }
                            to {
                                opacity: 0;
                                transform: translate(-50%, -40%) scale(0.95);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Remove overlay
                const overlay = document.querySelector('.job-offer-overlay');
                if (overlay) {
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        if (overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }
                    }, 500);
                }
                
                // Hide dialog after animation
                setTimeout(() => {
                    followupDialog.style.display = 'none';
                    
                    // Remove icon
                    const icon = document.querySelector('.persuasion-icon');
                    if (icon && icon.parentNode) {
                        icon.parentNode.removeChild(icon);
                    }
                    
                    gamePaused = false;
                    
                    // Reward player for resisting temptation
                    score += 1500;
                    
                    // Also boost mental health
                    stats.mentalHealth = Math.min(100, stats.mentalHealth + 10);
                    updatePlayerCondition();
                    
                    // Show reward effect
                    showCoinAnimation(1500);
                    showPopupMessage("תגמול על התמדה בקריירה: 1,500 ש\"ח", 2500);
                    updateDisplay();
                }, 300);
            }
        });
        
        // Game over buttons
        document.getElementById('restart-btn').addEventListener('click', function() {
            // Button press animation
            const button = document.getElementById('restart-btn');
            button.style.transform = 'scale(0.95)';
            
            // Reset after short delay
            setTimeout(() => {
                button.style.transform = '';
                resetGame();
            }, 100);
        });
        
        document.getElementById('play-again-btn').addEventListener('click', function() {
            // Button press animation
            const button = document.getElementById('play-again-btn');
            button.style.transform = 'scale(0.95)';
            
            // Reset after short delay
            setTimeout(() => {
                button.style.transform = '';
                resetGame();
            }, 100);
        });

        // בדיקת מצב הדף ואתחול רק כאשר הדף טעון במלואו
if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(initializeGame, 500); // הארכת ההשהיה לוודא טעינה מלאה
} else {
    document.addEventListener("DOMContentLoaded", function() {
        setTimeout(initializeGame, 500); // הארכת ההשהיה לוודא טעינה מלאה
    });
}

function initializeGame() {
    console.log("Initializing game...");
    
    // וידא שהקנבס קיים ומוגדר
    if (!canvas) {
        console.error("Canvas not found!");
        return;
    }
    
    // אתחול מחדש של הקנבס
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // וידוא שכל המשתנים החיוניים מוגדרים
    if (!ground || !player || !ctx) {
        console.error("Essential game variables not defined!");
        return;
    }
    
    optimizeForMobile();
    createStars();
    createClouds();
    setupArrowButtonEvents();

    // אתחול מסכי המדריך מחדש - הצג רק את הראשון
currentTutorialScreen = 1;
for (let i = 1; i <= totalTutorialScreens; i++) {
    const screen = document.getElementById(`tutorial-screen-${i}`);
    if (screen) {
        screen.style.display = i === 1 ? 'block' : 'none';
    }
}

    // וידוא שהמשחק מאותחל לפני הפעלתו
    lastTimeUpdate = Date.now();
    gameRunning = false; // שינוי: המשחק לא רץ עד ללחיצה על "התחל"

    // הוסף בדיקה תקופתית לכפתור החץ
    setInterval(updateArrowButtonAttention, 1000);

    // הוסף מאזין אירוע ללחיצה על כותרת לוח המחוונים
    document.querySelector('.dashboard-header').addEventListener('click', function() {
        document.querySelector('.dashboard-container').classList.toggle('dashboard-collapsed');
    });

    startGame();
    console.log("Game initialization complete");
}

// לא לקרוא לפונקציות אלה ישירות כאן
// optimizeForMobile();
// createStars();
// createClouds();
// setupArrowButtonEvents();
// startGame();
    </script>
</body>
</html>
