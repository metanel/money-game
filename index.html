<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>משחק המשמעת הפיננסית</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2a6496;
            --secondary-color: #4a4a4a;
            --success-color: #3a7a5f;
            --warning-color: #d3873e;
            --danger-color: #d45b5b;
            --background-color: #f8f9fa;
            --card-color: rgba(255, 255, 255, 0.95);
            --text-color: #333333;
            --text-light: #ffffff;
            --day-sky-color-start: #87CEEB;
            --day-sky-color-end: #ADD8E6;
            --night-sky-color-start: #1a2238;
            --night-sky-color-end: #283655;
            --sunset-sky-color-start: #FF7F50;
            --sunset-sky-color-end: #FFD700;
            --sunrise-sky-color-start: #FF7F50;
            --sunrise-sky-color-end: #ADD8E6;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            font-family: 'Open Sans', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            transition: background-color 0.5s ease;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
            transition: filter 2s ease; /* Smooth transition for day/night filter */
        }
        
        .game-display {
            position: absolute;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        #score-display {
            top: 15px;
            right: 15px;
            color: var(--primary-color);
        }
        
        #date-display {
            top: 15px;
            left: 15px;
            color: var(--secondary-color);
        }
        
        #monthly-stats {
            position: absolute;
            top: 60px;
            right: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            line-height: 1.6;
            z-index: 10;
        }
        
        #monthly-stats div {
            margin-bottom: 5px;
        }
        
        #tutorial-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 25px;
            background-color: var(--card-color);
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            max-width: 80%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            line-height: 1.6;
        }
        
        .dialog-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            line-height: 1.6;
            animation: dialog-appear 0.3s ease-out forwards;
        }
        
        @keyframes dialog-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -40%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .dialog-box h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 20px;
        }
        
        .dialog-box p {
            margin: 15px 0;
            font-size: 16px;
        }
        
        .dialog-box button {
            margin: 8px;
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
            min-width: 100px;
        }
        
        .dialog-box button:hover {
            background-color: #1e5180;
            transform: translateY(-2px);
        }
        
        .dialog-box button.no-btn {
            background-color: var(--danger-color);
        }
        
        .dialog-box button.no-btn:hover {
            background-color: #c04848;
        }
        
        #obstacle-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            animation: bounce-in 0.5s ease-out forwards;
        }
        
        @keyframes bounce-in {
            0% {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -48%);
            }
            100% {
                transform: translate(-50%, -50%);
            }
        }
        
        #obstacle-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #obstacle-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #obstacle-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }
        
        #ignore-btn {
            background-color: var(--success-color);
            color: white;
        }
        
        #accept-btn {
            background-color: var(--warning-color);
            color: white;
        }
        
        #ignore-btn:hover {
            background-color: #2c6a4f;
            transform: translateY(-2px);
        }
        
        #accept-btn:hover {
            background-color: #c77730;
            transform: translateY(-2px);
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(50, 50, 50, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: fade-in 0.7s ease-out forwards;
        }
        
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #game-over h2,
        #win-screen h2 {
            font-size: 24px;
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        #game-over button,
        #win-screen button {
            margin-top: 25px;
            padding: 12px 28px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
        }
        
        #game-over button:hover,
        #win-screen button:hover {
            background-color: #1e5180;
            transform: translateY(-2px);
        }
        
        #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 100, 150, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: scale-in 0.6s ease-out forwards;
        }
        
        @keyframes scale-in {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .popup-message {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: rgba(50, 50, 50, 0.9);
            color: white;
            border-radius: 25px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 20;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .power-meter {
            position: absolute;
            bottom: 25px;
            left: 20px;
            width: 200px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            overflow: hidden;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .power-meter-fill {
            height: 100%;
            background-color: var(--success-color);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .status-effect {
            position: absolute;
            top: 50%;  /* Center vertically */
            left: 50%;  /* Center horizontally */
            transform: translate(-50%, 150px);  /* Adjust vertical position */
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
            margin: 0 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 15;
            animation: status-effect-appear 0.4s ease forwards;
        }
        
        @keyframes status-effect-appear {
            from {
                opacity: 0;
                transform: translate(-50%, 170px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 150px);
            }
        }
        
        #status-negative {
            background-color: rgba(212, 91, 91, 0.9);
        }
        
        #status-weight {
            background-color: rgba(211, 135, 62, 0.9);
        }
        
        #speed-indicator {
            position: absolute;
            bottom: 25px;
            right: 20px;
            padding: 8px 15px;
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: background-color 0.3s ease;
        }
        
        #movement-instruction {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            display: none;
            z-index: 25;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 80%;
            animation: pulse 1.5s infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Health indicators in center */
        .health-bars {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            width: 260px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .health-bar {
            margin-bottom: 15px;
        }
        
        .health-bar .label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--secondary-color);
        }
        
        .health-bar .bar {
            width: 100%;
            height: 12px;
            background-color: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .health-bar .fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #physical-health-fill {
            background-color: var(--success-color);
        }
        
        #mental-health-fill {
            background-color: var(--primary-color);
        }
        
        .day-clock-container {
            margin-top: 15px;
            text-align: center;
        }
        
        #day-clock {
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            display: inline-block;
            margin-top: 5px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        #day-clock:hover {
            transform: scale(1.05);
        }
        
        .clock-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 18px;
        }
        .finance-tip {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(42, 100, 150, 0.85);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            max-width: 80%;
            text-align: center;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 15;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        
        #powerup-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            animation: slide-in 0.4s ease forwards;
        }
        
        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #powerup-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #powerup-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #powerup-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 80px;
        }
        
        #powerup-yes-btn {
            background-color: var(--success-color);
            color: white;
        }
        
        #powerup-no-btn {
            background-color: var(--danger-color);
            color: white;
        }
        
        #powerup-yes-btn:hover {
            background-color: #2c6a4f;
            transform: translateY(-2px);
        }
        
        #powerup-no-btn:hover {
            background-color: #c04848;
            transform: translateY(-2px);
        }
        
        .achievements-panel {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: none;
            text-align: center;
        }
        
        .achievement {
            margin: 5px 0;
            font-size: 14px;
            color: var(--primary-color);
            font-weight: 600;
            animation: achievement-pop 0.5s ease-out forwards;
        }
        
        @keyframes achievement-pop {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        
        /* Sun and Moon */
        #sun {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #FFD700 40%, rgba(255, 215, 0, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            z-index: 5;
            opacity: 1;
            transition: all 2s ease;
        }
        
        #moon {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #E6E6FA 40%, rgba(230, 230, 250, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(230, 230, 250, 0.5);
            z-index: 5;
            opacity: 0;
            transition: all 2s ease;
        }
        
        /* Moon shadow effect */
        #moon::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            width: 45px;
            height: 45px;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.1) 40%, rgba(0, 0, 0, 0) 70%);
            border-radius: 50%;
        }
        
        /* Stars in night sky */
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 2s ease;
            animation: twinkle 3s infinite alternate;
            z-index: 4;
        }
        
        @keyframes twinkle {
            from { opacity: 0.2; }
            to { opacity: 0.8; }
        }
        
        /* Weather effects */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            z-index: 6;
            transition: all 1s ease;
            opacity: 0;
        }
        
        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
        }
        
        .bird {
            position: absolute;
            z-index: 6;
            transition: all 0.5s ease;
            opacity: 0;
        }
        
        /* Day/Night cycle overlay */
        #day-night-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 30, 0);
            z-index: 3;
            pointer-events: none;
            transition: background-color 2s ease;
        }
        
        @media (max-width: 768px) {
            .game-display {
                font-size: 14px;
                padding: 8px 12px;
            }
            
            .dialog-box {
                width: 90%;
                max-width: 400px;
                padding: 20px;
            }
            
            .dialog-box h3 {
                font-size: 18px;
            }
            
            .dialog-box p {
                font-size: 14px;
            }
            
            .dialog-box button {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            #tutorial-message {
                font-size: 14px;
                max-width: 95%;
                padding: 20px;
            }
            
            .power-meter {
                width: 150px;
                height: 10px;
            }
            
            #obstacle-dialog {
                width: 90%;
                max-width: 400px;
                padding: 20px;
            }
            
            #obstacle-dialog p {
                font-size: 14px;
            }
            
            .health-bars {
                width: 220px;
                padding: 12px;
                top: 100px;
            }
            
            .finance-tip {
                font-size: 12px;
                padding: 8px 16px;
            }
            
            #day-clock {
                font-size: 20px;
                padding: 4px 12px;
            }
            
            #sun, #moon {
                width: 40px;
                height: 40px;
                right: 60px;
                top: 40px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <!-- Day/Night cycle overlay -->
        <div id="day-night-overlay"></div>
        
        <!-- Sun and Moon -->
        <div id="sun"></div>
        <div id="moon"></div>
        
        <div id="score-display" class="game-display">סך נכסים פיננסיים: 0 ש"ח</div>
        <div id="date-display" class="game-display">מרץ 2025</div>
        
        <div id="monthly-stats">
            <div>הוצאות חודשיות: <span id="expenses">0</span> ש"ח</div>
            <div>הכנסה חודשית: <span id="income">5,000</span> ש"ח</div>
        </div>
        
        <div class="health-bars">
            <div class="health-bar">
                <div class="label">בריאות פיזית</div>
                <div class="bar">
                    <div id="physical-health-fill" class="fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="health-bar">
                <div class="label">בריאות מנטלית</div>
                <div class="bar">
                    <div id="mental-health-fill" class="fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="day-clock-container">
                <div class="label">שעון יומי <span class="clock-icon">🕒</span></div>
                <div id="day-clock">05:00</div>
            </div>
        </div>
        
        <div id="achievements" class="achievements-panel"></div>
        
        <div id="power-meter" class="power-meter">
            <div id="power-meter-fill" class="power-meter-fill"></div>
        </div>
        
        <div id="popup-message" class="popup-message"></div>
        <div id="finance-tip" class="finance-tip"></div>
        
        <div id="status-negative" class="status-effect">השפעה מנטלית: חלש</div>
        <div id="status-weight" class="status-effect">מצב גופני: כבד</div>
        <div id="speed-indicator">מהירות: רגילה</div>
        <div id="movement-instruction">לחץ על המסך כדי להתקדם!<br><span style="font-size: 16px; font-weight: normal; opacity: 0.9;">בלי לחיצה אין התקדמות</span></div>
        
        <!-- דיאלוג הפאוור-אפים -->
        <div id="powerup-dialog" class="dialog-box">
            <h3 id="powerup-title">נתקלת בהזדמנות לשיפור!</h3>
            <p id="powerup-text">האם עשית אימון כבר היום?</p>
            <button id="powerup-yes-btn">כן</button>
            <button id="powerup-no-btn">לא</button>
        </div>
        
        <!-- דיאלוג המכשול -->
        <div id="obstacle-dialog" class="dialog-box">
            <h3 id="obstacle-title">התמודדות עם דילמה פיננסית</h3>
            <p id="obstacle-text">האם לבחור בהוצאה מיידית או להמשיך בתוכנית החיסכון?</p>
            <button id="ignore-btn">סירוב</button>
            <button id="accept-btn">הסכמה</button>
        </div>
        
        <div id="tutorial-message">
            <h3>ברוכים הבאים למשחק המשמעת הפיננסית</h3>
            <p>המטרה שלך היא לצבור 100,000 ש"ח באמצעות התמדה והחלטות פיננסיות חכמות.</p>
            <p>לחץ על המסך (או החזק מקש הרווח) כדי להתקדם בדרך הפיננסית. התקדמות דורשת מאמץ מתמיד.</p>
            <p>אתה מרוויח 5,000 ש"ח בחודש מהעבודה היציבה שלך, אך תיתקל בדילמות ופיתויים לאורך הדרך.</p>
            <p>קצב ההתקדמות שלך מושפע מהמצב הפיזי והמנטלי.</p>
            <p>זכור - יציבות פיננסית היא מרתון, לא ספרינט. נדרשת משמעת והתמדה לאורך זמן.</p>
            <button id="start-btn">התחל</button>
        </div>
        
        <div id="job-offer" class="dialog-box">
            <h3>הזדמנות קריירה חדשה</h3>
            <p>האם לבחור בקריירה עם שכר גבוה יותר אך פחות יציבות?</p>
            <button id="yes-btn">כן</button>
            <button id="no-btn" class="no-btn">לא</button>
        </div>
        
        <div id="job-offer-followup" class="dialog-box">
            <h3>שקול שוב את החלטתך</h3>
            <p id="followup-text">האם אתה בטוח שברצונך לדחות הזדמנות זו?</p>
            <button id="followup-yes-btn">כן</button>
            <button id="followup-no-btn" class="no-btn">לא</button>
        </div>
        
        <div id="game-over">
            <h2>ניהול פיננסי כושל</h2>
            <p id="game-over-reason"></p>
            <p>צברת סך של <span id="final-score">0</span> ש"ח בנכסים פיננסיים</p>
            <div id="game-stats">
                <p>תקופה שנוהלה: <span id="months-played">0</span> חודשים</p>
                <p>הרגלים פיננסיים חיוביים: <span id="powerups-collected">0</span></p>
                <p>דילמות פיננסיות שנפתרו: <span id="obstacles-avoided">0</span></p>
            </div>
            <p class="lesson">לקח: יציבות פיננסית דורשת משמעת, תכנון ארוך טווח והחלטות מושכלות.</p>
            <button id="restart-btn">ניסיון חדש</button>
        </div>
        
        <div id="win-screen">
            <h2>יציבות פיננסית הושגה!</h2>
            <p>הצלחת לצבור 100,000 ש"ח בנכסים פיננסיים!</p>
            <p>כל הכבוד על המשמעת העצמית, ההתמדה וקבלת ההחלטות הנכונות.</p>
            <div id="win-stats">
                <p>תקופת צבירת הנכסים: <span id="win-months">0</span> חודשים</p>
                <p>הרגלים פיננסיים חיוביים: <span id="win-powerups">0</span></p>
                <p>דילמות פיננסיות שנפתרו: <span id="win-obstacles">0</span></p>
            </div>
            <p class="lesson">זכור: יציבות פיננסית היא תהליך מתמשך הדורש התמדה והחלטות מושכלות.</p>
            <button id="play-again-btn">ניסיון נוסף</button>
        </div>
    </div>
    <script>
        // Canvas and context setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to cover the window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game variables
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let currentMonth = 0;
        let tutorialShown = true;
        let isMoving = false; // Movement control
        let moveTimer = null; // For instruction display timing
        let financeMessageTimer = null; // For finance tips display
        
        // Day/Night cycle variables
        let currentHour = 5; // Starting at 5:00 AM
        let currentMinute = 0;
        let dayProgress = 0; // 0 to 1 for day cycle
        let isDayTime = true;
        let timeMultiplier = 2.4; // 2.4 hours per real second (24h in 10 seconds)
        let lastTimeUpdate = Date.now();
        let stars = [];
        let clouds = [];
        let birds = [];
        
        // Create stars
        function createStars() {
            stars = [];
            const starCount = Math.min(50, Math.floor(window.innerWidth * window.innerHeight / 10000)); // Adjust based on screen size
            
            for (let i = 0; i < starCount; i++) {
                const star = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * 0.7), // Only in the sky area
                    size: Math.random() * 2 + 1, // 1-3px
                    twinkleSpeed: Math.random() * 2 + 1 // Variation in twinkle speed
                };
                stars.push(star);
            }
        }
        
        // Create clouds
        function createClouds() {
            clouds = [];
            const cloudCount = Math.min(5, Math.floor(window.innerWidth / 400)); // Adjust based on screen width
            
            for (let i = 0; i < cloudCount; i++) {
                createCloud();
            }
        }
        
        // Create a single cloud
        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            // Random cloud size and position
            const size = Math.random() * 40 + 60; // 60-100px
            const top = Math.random() * (canvas.height * 0.3) + 50; // Top half of sky
            const left = Math.random() * canvas.width;
            
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size / 2}px`;
            cloud.style.top = `${top}px`;
            cloud.style.left = `${left}px`;
            
            // Create cloud shape with pseudo-elements
            cloud.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3)';
            
            // Speed will determine how fast the cloud moves across the screen
            const speed = Math.random() * 0.05 + 0.01; // pixels per millisecond
            cloud.dataset.speed = speed;
            cloud.dataset.position = left;
            
            document.getElementById('game-container').appendChild(cloud);
            clouds.push(cloud);
            
            // Set initial opacity based on time of day
            updateCloudVisibility();
        }
        
        // Create birds
        function createBirds() {
            birds = [];
            const birdCount = Math.min(3, Math.floor(window.innerWidth / 500)); // Adjust based on screen width
            
            for (let i = 0; i < birdCount; i++) {
                if (Math.random() < 0.7) { // 70% chance to create a bird
                    createBird();
                }
            }
        }
        
        // Create a single bird
        function createBird() {
            const bird = document.createElement('div');
            bird.className = 'bird';
            
            // Create SVG for bird
            const birdSize = Math.random() * 10 + 15; // 15-25px
            bird.innerHTML = `
                <svg width="${birdSize}" height="${birdSize}" viewBox="0 0 100 100">
                    <path d="M10,50 Q30,30 50,50 Q70,30 90,50" stroke="#333" fill="transparent" stroke-width="5"/>
                </svg>
            `;
            
            // Random position
            const top = Math.random() * (canvas.height * 0.4) + 50; // Upper half of sky
            const left = -birdSize;
            
            bird.style.top = `${top}px`;
            bird.style.left = `${left}px`;
            
            // Speed will determine how fast the bird moves across the screen
            const speed = Math.random() * 0.08 + 0.05; // pixels per millisecond
            bird.dataset.speed = speed;
            bird.dataset.position = left;
            
            document.getElementById('game-container').appendChild(bird);
            birds.push(bird);
            
            // Only show birds during the day
            bird.style.opacity = isDayTime ? '1' : '0';
        }
        
        // Update clouds position
        function updateClouds(deltaTime) {
            clouds.forEach((cloud, index) => {
                let position = parseFloat(cloud.dataset.position);
                const speed = parseFloat(cloud.dataset.speed);
                
                position += speed * deltaTime;
                
                // Reset cloud when it goes off screen
                if (position > canvas.width + parseFloat(cloud.style.width)) {
                    position = -parseFloat(cloud.style.width);
                }
                
                cloud.dataset.position = position;
                cloud.style.left = `${position}px`;
            });
        }
        
        // Update birds position
        function updateBirds(deltaTime) {
            birds.forEach((bird, index) => {
                let position = parseFloat(bird.dataset.position);
                const speed = parseFloat(bird.dataset.speed);
                
                position += speed * deltaTime;
                
                // Remove bird when it goes off screen
                if (position > canvas.width + 50) {
                    document.getElementById('game-container').removeChild(bird);
                    birds.splice(index, 1);
                    
                    // Maybe create a new bird
                    if (Math.random() < 0.3 && isDayTime) {
                        setTimeout(createBird, Math.random() * 5000 + 2000);
                    }
                } else {
                    bird.dataset.position = position;
                    bird.style.left = `${position}px`;
                    
                    // Make bird flap by changing the SVG occasionally
                    if (Math.random() < 0.05) {
                        const path = bird.querySelector('path');
                        if (path) {
                            const flap = Math.random() < 0.5 ? 
                                "M10,50 Q30,20 50,50 Q70,20 90,50" : 
                                "M10,50 Q30,40 50,50 Q70,40 90,50";
                            path.setAttribute('d', flap);
                        }
                    }
                }
            });
            
            // Occasionally add new birds during the day
            if (birds.length < 3 && Math.random() < 0.001 && isDayTime) {
                createBird();
            }
        }
        
        // Update cloud visibility based on time of day
        function updateCloudVisibility() {
            const cloudOpacity = isDayTime ? 0.8 : 0.3; // Less visible at night
            
            clouds.forEach(cloud => {
                cloud.style.opacity = cloudOpacity;
                // Change cloud color for night
                if (isDayTime) {
                    cloud.style.background = "rgba(255, 255, 255, 0.7)";
                } else {
                    cloud.style.background = "rgba(200, 200, 220, 0.5)";
                }
            });
        }
        
        // Update birds visibility based on time of day
        function updateBirdsVisibility() {
            birds.forEach(bird => {
                // Birds only appear during day
                bird.style.opacity = isDayTime ? '1' : '0';
                
                // Remove birds at night
                if (!isDayTime) {
                    setTimeout(() => {
                        if (birds.includes(bird)) {
                            document.getElementById('game-container').removeChild(bird);
                            birds.splice(birds.indexOf(bird), 1);
                        }
                    }, 2000);
                }
            });
        }
        
        // Update day/night cycle
        function updateDayNightCycle() {
            const now = Date.now();
            const deltaTime = now - lastTimeUpdate;
            lastTimeUpdate = now;
            
            // Update time (hours incremented by timeMultiplier per second)
            const secondsElapsed = deltaTime / 1000;
            const hoursElapsed = secondsElapsed * timeMultiplier;
            
            // Update minutes first
            currentMinute += hoursElapsed * 60;
            
            // If minutes exceed 60, increment hour
            while (currentMinute >= 60) {
                currentMinute -= 60;
                currentHour++;
                
                // Reset hour after 24
                if (currentHour >= 24) {
                    currentHour = 0;
                }
                
                // Check for day/night transition
                if (currentHour === 18) {
                    transitionToNight();
                } else if (currentHour === 5) {
                    transitionToDay();
                }
            }
            
            // Format time display
            updateClockDisplay();
            
            // Update day progress (0-1 for full day)
            dayProgress = (currentHour + (currentMinute / 60)) / 24;
            
            // Update sky color based on time
            updateSkyColor();
            
            // Update sun/moon position
            updateCelestialBodies();
            
            // Update environment elements
            updateClouds(deltaTime);
            updateBirds(deltaTime);
        }
        
        // Format and update clock display
        function updateClockDisplay() {
            const hours = String(Math.floor(currentHour)).padStart(2, '0');
            const minutes = String(Math.floor(currentMinute)).padStart(2, '0');
            document.getElementById('day-clock').textContent = `${hours}:${minutes}`;
            
            // Visual effect on hour change
            if (Math.floor(currentMinute) === 0) {
                document.getElementById('day-clock').style.transform = 'scale(1.1)';
                setTimeout(() => {
                    document.getElementById('day-clock').style.transform = 'scale(1)';
                }, 300);
            }
        }
        
        // Update sky color based on time
        function updateSkyColor() {
            let skyColor;
            const hour = currentHour + (currentMinute / 60);
            
            // Day sky (6-17)
            if (hour >= 6 && hour < 17) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start');
            }
            // Sunset (17-19)
            else if (hour >= 17 && hour < 19) {
                const progress = (hour - 17) / 2; // 0-1 for sunset
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--sunset-sky-color-start'),
                    progress
                );
            }
            // Night (19-5)
            else if (hour >= 19 || hour < 5) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--night-sky-color-start');
            }
            // Sunrise (5-6)
            else {
                const progress = (hour - 5); // 0-1 for sunrise
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--sunrise-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    progress
                );
            }
            
            // Apply sky color in draw background
            ctx.fillStyle = skyColor;
        }
        
        // Helper for color mixing
        function mixColors(color1, color2, ratio) {
            color1 = color1.trim();
            color2 = color2.trim();
            
            // Simple mixing for hex or rgb colors
            if (color1.startsWith('#')) {
                // Convert hex to rgb
                const r1 = parseInt(color1.substr(1, 2), 16);
                const g1 = parseInt(color1.substr(3, 2), 16);
                const b1 = parseInt(color1.substr(5, 2), 16);
                
                const r2 = parseInt(color2.substr(1, 2), 16);
                const g2 = parseInt(color2.substr(3, 2), 16);
                const b2 = parseInt(color2.substr(5, 2), 16);
                
                const r = Math.round(r1 * (1 - ratio) + r2 * ratio);
                const g = Math.round(g1 * (1 - ratio) + g2 * ratio);
                const b = Math.round(b1 * (1 - ratio) + b2 * ratio);
                
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Assume rgb format
                return color1; // Simplified - would need regex for proper rgb mixing
            }
        }
        
        // Update sun and moon positions
        function updateCelestialBodies() {
            const sunElement = document.getElementById('sun');
            const moonElement = document.getElementById('moon');
            
            // Calculate positions - circular path in sky
            const skyWidth = canvas.width;
            const skyHeight = canvas.height * 0.6; // Top 60% is sky
            
            // Sun moves from left to right during day (5-19)
            if (currentHour >= 5 && currentHour < 19) {
                const sunProgress = (currentHour - 5) / 14; // 0-1 for sun path
                
                // Circular path for sun - moves in an arc
                const sunX = skyWidth * sunProgress;
                const sunY = skyHeight * 0.5 * Math.sin(Math.PI * sunProgress) + 50;
                
                sunElement.style.left = `${sunX}px`;
                sunElement.style.top = `${sunY}px`;
                
                // Set sun opacity based on time (fade during sunset/sunrise)
                if (currentHour >= 17) { // Sunset
                    const fadeProgress = (currentHour + currentMinute/60 - 17) / 2;
                    sunElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else if (currentHour < 6) { // Sunrise
                    const fadeProgress = (currentHour + currentMinute/60 - 5);
                    sunElement.style.opacity = Math.min(1, fadeProgress);
                } else {
                    sunElement.style.opacity = '1';
                }
                
                // Hide moon during day
                moonElement.style.opacity = '0';
                
                // Stars invisible during day
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
            } 
            // Moon moves from left to right during night (19-5)
            else {
                const moonProgress = (currentHour >= 19) ? 
                    (currentHour - 19) / 10 : // Evening (19-24)
                    (currentHour + 5) / 10;  // Morning (0-5)
                
                // Circular path for moon
                const moonX = skyWidth * moonProgress;
                const moonY = skyHeight * 0.3 * Math.sin(Math.PI * moonProgress) + 50;
                
                moonElement.style.left = `${moonX}px`;
                moonElement.style.top = `${moonY}px`;
                
                // Set moon opacity (fade during transitions)
                if (currentHour >= 19 && currentHour < 20) { // Dusk
                    const fadeProgress = (currentHour + currentMinute/60 - 19);
                    moonElement.style.opacity = Math.min(1, fadeProgress);
                } else if (currentHour >= 4 && currentHour < 5) { // Dawn
                    const fadeProgress = (currentHour + currentMinute/60 - 4);
                    moonElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else {
                    moonElement.style.opacity = '1';
                }
                
                // Hide sun during night
                sunElement.style.opacity = '0';
                
                // Stars visible at night
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
            }
        }
        
        // Transition to night
        function transitionToNight() {
            if (isDayTime) {
                isDayTime = false;
                
                // Fade in night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0.3)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Create stars if they don't exist
                if (document.querySelectorAll('.star').length === 0) {
                    createStarsElements();
                }
                
                // Show stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(0.8)';
                
                // Update UI elements for night
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.25)';
                });
            }
        }
        
        // Transition to day
        function transitionToDay() {
            if (!isDayTime) {
                isDayTime = true;
                
                // Fade out night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Hide stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(1)';
                
                // Update UI elements for day
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                });
                
                // Maybe create some birds for the new day
                if (birds.length < 2 && Math.random() < 0.5) {
                    createBird();
                }
            }
        }
        
        // Create star elements in DOM
        function createStarsElements() {
            createStars(); // Generate star data
            
            stars.forEach(star => {
                const starElement = document.createElement('div');
                starElement.className = 'star';
                starElement.style.width = `${star.size}px`;
                starElement.style.height = `${star.size}px`;
                starElement.style.left = `${star.x}px`;
                starElement.style.top = `${star.y}px`;
                
                // Custom twinkle animation
                starElement.style.animationDuration = `${star.twinkleSpeed}s`;
                
                document.getElementById('game-container').appendChild(starElement);
            });
        }
        // Game statistics
        let stats = {
            monthsPlayed: 0,
            powerupsCollected: 0,
            obstaclesAvoided: 0,
            obstaclesFaced: 0,
            expenses: 0,
            income: 5000,  // Starting monthly income
            mentalHealth: 100, // Mental state affects progress speed
            physicalHealth: 100 // Physical state affects progress speed
        };
        
        // Achievements
        let achievements = {
            firstMonth: { earned: false, text: "הישרדות חודש ראשון" },
            saveHero: { earned: false, text: "חסכת 50,000 ש\"ח" },
            powerCollector: { earned: false, text: "אימצת 10 הרגלים פיננסיים חיוביים" },
            resistanceMaster: { earned: false, text: "פתרת 20 דילמות פיננסיות" },
            mentalStrength: { earned: false, text: "שמרת על חוסן מנטלי גבוה" }
        };
        
        // Financial tips to display periodically
        const financialTips = [
            "הקצאת 50 ש\"ח ליום לארוחות חוץ מסתכמת בכ-18,000 ש\"ח בשנה",
            "70% מהצעירים שחוסכים 20% מהכנסתם מגיעים ליציבות פיננסית תוך 5 שנים",
            "השקעה של 500 ש\"ח בחודש בגיל 23 יכולה להגיע לכמיליון ש\"ח בגיל פרישה",
            "קרן חירום אידיאלית מכסה 3-6 חודשי הוצאות חיוניות",
            "הוצאות קבועות לא צריכות לעלות על 50% מההכנסה החודשית נטו",
            "הימנעות מהלוואות צרכניות בריבית גבוהה היא מפתח ליציבות פיננסית",
            "רכישת מוצרים משומשים יכולה לחסוך עד 70% מעלותם החדשה",
            "ליסינג תפעולי לרכב לרוב יקר יותר מרכישה ישירה של רכב בטווח הארוך",
            "הפרשה לפנסיה בגיל מוקדם מגדילה משמעותית את החיסכון הסופי",
            "בדיקה של כל ההוצאות החודשיות אחת לרבעון יכולה לחסוך מאות שקלים"
        ];
        
        // Total months of simulation - extended game time
        const totalMonths = 24; // March 2025 to March 2027
        const monthNames = [
            "מרץ 2025", "אפריל 2025", "מאי 2025", "יוני 2025", "יולי 2025", 
            "אוגוסט 2025", "ספטמבר 2025", "אוקטובר 2025", "נובמבר 2025", "דצמבר 2025",
            "ינואר 2026", "פברואר 2026", "מרץ 2026", "אפריל 2026", "מאי 2026", 
            "יוני 2026", "יולי 2026", "אוגוסט 2026", "ספטמבר 2026", "אוקטובר 2026", 
            "נובמבר 2026", "דצמבר 2026", "ינואר 2027", "פברואר 2027", "מרץ 2027"
        ];
        
        // Month duration increased to 5 minutes per month (300 seconds)
        const monthDuration = 300; // 5 minutes (300 seconds) per month
        const framesPerSecond = 60;
        const frameTime = 1000 / framesPerSecond;
        const framesPerMonth = monthDuration * framesPerSecond;
        let currentMonthTimer = 0;

        // Monthly counters to limit obstacle and powerup appearances
        let monthlyObstacleCounter = {
            person: 0,
            ad: 0,
            food: 0
        };

        let monthlyPowerupCounter = {
            money: 0,
            earlyRise: 0,
            earlySleep: 0,
            healthyFood: 0,
            exercise: 0,
            companion: 0
        };
      
        // Power-up variables
        const maxPowerUpTime = 900; // 15 seconds at 60fps
        let gameMessage = '';
        let gameMessageTime = 0;
        
        // Player variables
        const player = {
            x: canvas.width * 0.2,
            y: canvas.height * 0.7,
            width: 50,
            height: 80,
            baseSpeed: 5, // Base speed
            currentSpeed: 5, // Current speed affected by player condition
            powerUp: false,
            powerUpTime: 0,
            powerUpType: '',
            companion: false,
            weight: 1, // Increases with unhealthy food, affects speed
            mentalStrength: 1 // Decreases with negative mental effects, affects speed
        };
        
        // Ground variables
        const ground = {
            y: canvas.height * 0.8,
            width: canvas.width,
            height: canvas.height * 0.2
        };
        
        // Current powerup in dialog
        let currentPowerup = null;
        let powerupFollowupQuestions = [];
        let powerupFollowupIndex = 0;
        
        // Arrays for game objects
        let obstacles = [];
        let powerups = [];
        let pendingObstacles = [];  // For delayed creation
        
        // Obstacle dialog variables
        let currentObstacle = null;
        let lastObstacleTime = 0;
        const minObstacleInterval = 5000; // Minimum time between obstacle dialogs (5 seconds)
        let persuasionStage = 0; // Current persuasion stage
        let persuasionTexts = []; // Persuasion texts per obstacle
        
        // Job offer variables
        let jobOfferStage = 0;
        const jobOfferTexts = [
            "האם אתה בטוח שברצונך לדחות הזדמנות זו?",
            "השכר גבוה ב-25% ותנאי הסוציאליים משופרים",
            "ההזדמנות להתפתחות מקצועית משמעותית יותר",
            "העבודה מציעה גמישות רבה יותר בשעות העבודה"
        ];
        
        // Bonus questions for financial bonus powerup
        const bonusQuestions = [
            { 
                question: "האם הגעת לעבודה בזמן כל השבוע?", 
                positiveEffect: "אמינות ודייקנות הם ערכים חשובים למעסיק",
                negativeEffect: "איחורים פוגעים בתדמית המקצועית שלך"
            },
            { 
                question: "האם סיימת את כל המשימות שלך לפני הדדליין?", 
                positiveEffect: "עמידה ביעדים מוכיחה יעילות ומקצועיות",
                negativeEffect: "אי עמידה בזמנים פוגעת בהערכת הביצועים שלך"
            },
            { 
                question: "האם עזרת לעמיתים לעבודה השבוע?", 
                positiveEffect: "עבודת צוות טובה נלקחת בחשבון בהערכת עובדים",
                negativeEffect: "שיתוף פעולה מוגבל מקטין את הערך שלך לארגון"
            },
            { 
                question: "האם הבאת רעיון חדש או הצעת ייעול לעבודה?", 
                positiveEffect: "יוזמה ויצירתיות מובילות לקידום מקצועי",
                negativeEffect: "פסיביות בעבודה מגבילה את פוטנציאל הקידום שלך"
            },
            { 
                question: "האם השקעת זמן בהרחבת הידע המקצועי שלך?", 
                positiveEffect: "התפתחות אישית מגדילה את ערכך בשוק העבודה",
                negativeEffect: "קיבעון מקצועי מגביל את האפשרויות העתידיות שלך"
            }
        ];
        
        // Helper for random number generation
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // Display popup message with enhanced visuals
        function showPopupMessage(message, duration = 2000) {
            const popup = document.getElementById('popup-message');
            popup.textContent = message;
            popup.style.opacity = '1';
            popup.style.transform = 'translateX(-50%) translateY(-10px)';
            
            setTimeout(() => {
                popup.style.opacity = '0';
                popup.style.transform = 'translateX(-50%) translateY(0px)';
            }, duration);
        }
        
        // Show financial tip with enhanced styling
        function showFinanceTip() {
            if (financeMessageTimer) {
                clearTimeout(financeMessageTimer);
            }
            
            const tip = document.getElementById('finance-tip');
            const randomTip = financialTips[Math.floor(Math.random() * financialTips.length)];
            tip.textContent = randomTip;
            tip.style.opacity = '1';
            
            // Add subtle animation
            tip.style.transform = 'translateX(-50%) translateY(-5px)';
            setTimeout(() => {
                tip.style.transform = 'translateX(-50%) translateY(0)';
            }, 300);
            
            financeMessageTimer = setTimeout(() => {
                tip.style.opacity = '0';
            }, 8000); // Show for 8 seconds
        }
        
        // Update player's speed based on mental and physical health
        function updatePlayerCondition() {
            // Calculate weight effect (physical health)
            let weightEffect = 1;
            if (stats.physicalHealth < 80) {
                weightEffect = 0.9;
                document.getElementById('status-weight').style.display = 'block';
                document.getElementById('status-weight').textContent = "מצב גופני: ירוד";
            } else if (stats.physicalHealth < 60) {
                weightEffect = 0.7;
                document.getElementById('status-weight').style.display = 'block';
                document.getElementById('status-weight').textContent = "מצב גופני: לקוי";
            } else if (stats.physicalHealth < 40) {
                weightEffect = 0.5;
                document.getElementById('status-weight').style.display = 'block';
                document.getElementById('status-weight').textContent = "מצב גופני: חמור";
            } else {
                document.getElementById('status-weight').style.display = 'none';
            }
            
            // Calculate mental effect
            let mentalEffect = 1;
            if (stats.mentalHealth < 80) {
                mentalEffect = 0.9;
                document.getElementById('status-negative').style.display = 'block';
                document.getElementById('status-negative').textContent = "מצב מנטלי: ירוד";
            } else if (stats.mentalHealth < 60) {
                mentalEffect = 0.7;
                document.getElementById('status-negative').style.display = 'block';
                document.getElementById('status-negative').textContent = "מצב מנטלי: לקוי";
            } else if (stats.mentalHealth < 40) {
                mentalEffect = 0.5;
                document.getElementById('status-negative').style.display = 'block';
                document.getElementById('status-negative').textContent = "מצב מנטלי: חמור";
            } else {
                document.getElementById('status-negative').style.display = 'none';
            }
            
            // Update player speed
            player.currentSpeed = player.baseSpeed * weightEffect * mentalEffect;
            
            // Update speed indicator with enhanced styling
            const speedIndicator = document.getElementById('speed-indicator');
            if (player.currentSpeed < player.baseSpeed * 0.6) {
                speedIndicator.textContent = 'התקדמות: איטית מאוד';
                speedIndicator.style.backgroundColor = 'rgba(212, 91, 91, 0.9)';
            } else if (player.currentSpeed < player.baseSpeed * 0.8) {
                speedIndicator.textContent = 'התקדמות: איטית';
                speedIndicator.style.backgroundColor = 'rgba(211, 135, 62, 0.9)';
            } else if (player.currentSpeed < player.baseSpeed * 0.95) {
                speedIndicator.textContent = 'התקדמות: בינונית';
                speedIndicator.style.backgroundColor = 'rgba(214, 177, 45, 0.9)';
            } else {
                speedIndicator.textContent = 'התקדמות: אופטימלית';
                speedIndicator.style.backgroundColor = 'rgba(50, 50, 50, 0.8)';
            }
            
            // Update health bars with animation
            const physicalFill = document.getElementById('physical-health-fill');
            const mentalFill = document.getElementById('mental-health-fill');
            
            // Save current width for transition
            const currentPhysicalWidth = parseFloat(physicalFill.style.width) || 100;
            const currentMentalWidth = parseFloat(mentalFill.style.width) || 100;
            
            // Apply smooth transition if significant change
            if (Math.abs(currentPhysicalWidth - stats.physicalHealth) > 5) {
                physicalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { physicalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            if (Math.abs(currentMentalWidth - stats.mentalHealth) > 5) {
                mentalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { mentalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            // Set new values
            physicalFill.style.width = `${stats.physicalHealth}%`;
            mentalFill.style.width = `${stats.mentalHealth}%`;
            
            // Update color based on health level
            if (stats.physicalHealth < 40) {
                physicalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.physicalHealth < 70) {
                physicalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                physicalFill.style.backgroundColor = 'var(--success-color)';
            }
            
            if (stats.mentalHealth < 40) {
                mentalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.mentalHealth < 70) {
                mentalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                mentalFill.style.backgroundColor = 'var(--primary-color)';
            }
        }
        
        // Create obstacle with improved visuals
        function createObstacle() {
            const types = ['person', 'ad', 'food'];
            // Filter types that already appeared twice this month
            const availableTypes = types.filter(type => monthlyObstacleCounter[type] < 2);
            
            // If no available types, exit function
            if (availableTypes.length === 0) return;
            
            const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
            
            // Update counter for the selected type
            monthlyObstacleCounter[type]++;
            
            let obstacle;
            
            if (type === 'person') {
                const negativeComments = [
                    "קשה לחסוך עם משכורת כמו שלך",
                    "אתה לא תצליח להגיע ליציבות פיננסית",
                    "רוב האנשים לא מצליחים לחסוך",
                    "אתה מפספס הנאות בגלל הקמצנות שלך",
                    "חיסכון זה למעמד סוציו-אקונומי גבוה",
                    "אף פעם לא תגיע ליעד של 100,000",
                    "חיים רק פעם אחת, אל תחסוך ליום סגריר"
                ];
                
                // Persuasive texts for negative people
                const persuasiveTexts = [
                    // First stage title and text set separately
                    `מחקרים מראים שרוב האנשים לא מצליחים לחסוך בגלל מבנה מנטלי`, // Second stage
                    `האם לא עדיף ליהנות מהכסף עכשיו במקום לחכות לעתיד לא בטוח?`, // Third stage
                    `אתה נראה עייף, אולי תעשה לעצמך הפסקה קטנה מהחיסכון` // Fourth stage
                ];
                
                obstacle = {
                    x: canvas.width,
                    y: ground.y - 80,
                    width: 50,
                    height: 80,
                    type: type,
                    speed: 4 + (currentMonth * 0.1),
                    text: negativeComments[getRandomInt(0, negativeComments.length - 1)],
                    value: getRandomInt(500, 1000), // Cost if hit
                    mentalEffect: getRandomInt(5, 15), // How much it will reduce mental health
                    persuasiveTexts: persuasiveTexts,
                    obstacleTitle: "השפעה חברתית שלילית",
                    initialText: "חבר מציע לך לוותר על תוכנית החיסכון שלך כדי ליהנות יותר מההווה. כיצד תגיב?",
                    // Visual properties
                    color: "#6c757d",
                    animationOffset: Math.random() * Math.PI * 2, // For bobbing animation
                    bobSpeed: 0.05 + Math.random() * 0.03
                };
            } else if (type === 'ad') {
                const adTexts = [
                    "הצעה בלעדית! רק לזמן מוגבל!",
                    "חיסול מלאי: הנחות של עד 70%!",
                    "השקעה במראה שלך תעזור לך בקריירה",
                    "חופשה מושלמת בתשלומים נוחים",
                    "קורס שישפר את פוטנציאל ההכנסה שלך",
                    "הטבה לבעלי כרטיס אשראי בלבד",
                    "רכב חדש: במימון מלא ללא ריבית!"
                ];
                
                // Persuasive texts for ads
                const persuasiveTexts = [
                    `זו הזדמנות חד פעמית שלא תחזור!`,
                    `זו לא הוצאה, זו השקעה בעתיד שלך`,
                    `אם תחכה תפספס את ההזדמנות הזו לגמרי`
                ];
                
                obstacle = {
                    x: canvas.width,
                    y: ground.y - 70,
                    width: 60,
                    height: 70,
                    type: type,
                    speed: 5 + (currentMonth * 0.15),
                    text: adTexts[getRandomInt(0, adTexts.length - 1)],
                    value: getRandomInt(1000, 3000),
                    persuasiveTexts: persuasiveTexts,
                    obstacleTitle: "צריכה לא מתוכננת",
                    initialText: "נחשפת להצעה שיווקית שמפתה אותך לביצוע רכישה לא מתוכננת. מה תעשה?",
                    // Visual properties
                    color: "#495057",
                    animationOffset: Math.random() * Math.PI * 2,
                    bobSpeed: 0.08 + Math.random() * 0.04, // Ads move more erratically
                    pulseRate: 0.03 + Math.random() * 0.02 // For pulsing effect
                };
            } else if (type === 'food') {
                const foodTypes = [
                    "הזמנת משלוח מול בישול ביתי",
                    "ארוחה יקרה במסעדה",
                    "קפה ומאפה יומיים בדרך לעבודה",
                    "קניות במכולת יקרה לעומת סופר זול",
                    "אירוח חברים עם קייטרינג",
                    "אלכוהול בבר במחירים מופקעים"
                ];
                
                // Persuasive texts for food
                const persuasiveTexts = [
                    `אתה עובד קשה, מגיע לך להתפנק מדי פעם`,
                    `חוויות חברתיות חשובות כמו חיסכון כספי`,
                    `פעם אחת לא תשנה את המצב הפיננסי שלך`
                ];
                
                obstacle = {
                    x: canvas.width,
                    y: ground.y - 60,
                    width: 50,
                    height: 60,
                    type: type,
                    speed: 3 + (currentMonth * 0.1),
                    text: foodTypes[getRandomInt(0, foodTypes.length - 1)],
                    value: getRandomInt(300, 1200),
                    weightEffect: getRandomInt(5, 15), // How much it will reduce physical health
                    persuasiveTexts: persuasiveTexts,
                    obstacleTitle: "דילמת הוצאות מזון",
                    initialText: "עומדת בפניך בחירה בין הוצאה גבוהה על מזון או אפשרות חסכונית יותר. מה תבחר?",
                    // Visual properties
                    color: "#6c757d",
                    animationOffset: Math.random() * Math.PI * 2,
                    bobSpeed: 0.04 + Math.random() * 0.02, // Food moves more slowly
                    rotationSpeed: Math.random() * 0.01 // Slight rotation
                };
            }
            
            obstacles.push(obstacle);
            
            // Show subtle visual cue for obstacle approach
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${obstacle.y}px`;
            flash.style.width = '10px';
            flash.style.height = `${obstacle.height}px`;
            flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            flash.style.borderRadius = '5px 0 0 5px';
            flash.style.zIndex = '8';
            flash.style.animation = 'flash-warning 0.5s ease forwards';
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes flash-warning {
                    0% { opacity: 0.8; }
                    100% { opacity: 0; right: 10px; }
                }
            `;
            document.head.appendChild(style);
            
            // Remove the flash element after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 500);
        }
        
        // Create powerup with enhanced visuals
        function createPowerup() {
            const types = ['money', 'earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
            // Filter types that already appeared twice this month
            const availableTypes = types.filter(type => monthlyPowerupCounter[type] < 2);
            
            // If no available types, exit function
            if (availableTypes.length === 0) return;
            
            const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
            
            // Update counter for the selected type
            monthlyPowerupCounter[type]++;
            
            let text = '';
            let width = 40;
            let height = 40;
            let value = 1000;
            let color = '';
            
            switch(type) {
                case 'money':
                    text = "בונוס כספי";
                    value = getRandomInt(1000, 3000);
                    color = "#2a6496"; // Blue
                    break;
                case 'earlyRise':
                    text = "קימה מוקדמת";
                    color = "#3a7a5f"; // Green
                    break;
                case 'earlySleep':
                    text = "שינה מוקדמת";
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "תזונה בריאה";
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "פעילות גופנית";
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
                x: canvas.width,
                y: getRandomInt(ground.y - 150, ground.y - 60),
                width: width,
                height: height,
                type: type,
                speed: 4, // Slower speed for longer game
                text: text,
                value: value,
                healthEffect: type === 'healthyFood' || type === 'exercise' ? 10 : 0, // Improve physical health
                mentalEffect: type === 'earlySleep' || type === 'earlyRise' ? 10 : 0, // Improve mental health
                color: color,
                animationOffset: Math.random() * Math.PI * 2, // For floating animation
                floatSpeed: 0.03 + Math.random() * 0.02,
                floatRange: 10 + Math.random() * 5, // How far it floats up/down
                glowing: true, // Add glow effect
                originalY: 0 // Store original Y for floating animation
            };
            
            // Store original Y for floating animation
            powerup.originalY = powerup.y;
            
            powerups.push(powerup);
            
            // Show subtle visual cue for powerup approach
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '10px';
            flash.style.height = `${powerup.height}px`;
            flash.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
            flash.style.borderRadius = '5px 0 0 5px';
            flash.style.zIndex = '8';
            flash.style.animation = 'flash-powerup 0.5s ease forwards';
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define the animation keyframes if not already defined
            if (!document.getElementById('powerup-flash-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-flash-style';
                style.textContent = `
                    @keyframes flash-powerup {
                        0% { opacity: 0.8; }
                        100% { opacity: 0; right: 10px; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the flash element after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 500);
        }
        // Create companion with enhanced visuals
        function createCompanion() {
            // Check if companion already appeared twice this month
            if (monthlyPowerupCounter.companion >= 2) return;
            
            // Update companion counter
            monthlyPowerupCounter.companion++;
            
            const companion = {
                x: canvas.width,
                y: ground.y - 70,
                width: 40,
                height: 70,
                speed: 4,
                type: 'companion',
                text: "תמיכה חברתית בדרך הפיננסית",
                color: "#2a6496", // Blue
                animationOffset: Math.random() * Math.PI * 2,
                floatSpeed: 0.02,
                floatRange: 5,
                originalY: ground.y - 70,
                glowing: true,
                emitParticles: true // Special effect for companions
            };
            
            powerups.push(companion);
            showPopupMessage("תמיכה חברתית מתקרבת!", 2000);
            
            // Add sound or visual cue for companion
            const companionAlert = document.createElement('div');
            companionAlert.style.position = 'absolute';
            companionAlert.style.top = '50%';
            companionAlert.style.left = '50%';
            companionAlert.style.transform = 'translate(-50%, -50%)';
            companionAlert.style.color = 'white';
            companionAlert.style.fontSize = '24px';
            companionAlert.style.padding = '15px 30px';
            companionAlert.style.borderRadius = '8px';
            companionAlert.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
            companionAlert.style.zIndex = '50';
            companionAlert.style.animation = 'companion-alert 1.5s forwards';
            companionAlert.textContent = '👫 תמיכה חברתית מתקרבת!';
            
            document.getElementById('game-container').appendChild(companionAlert);
            
            // Add animation style if not already present
            if (!document.getElementById('companion-alert-style')) {
                const style = document.createElement('style');
                style.id = 'companion-alert-style';
                style.textContent = `
                    @keyframes companion-alert {
                        0% { opacity: 0; transform: translate(-50%, -70%); }
                        20% { opacity: 1; transform: translate(-50%, -50%); }
                        80% { opacity: 1; transform: translate(-50%, -50%); }
                        100% { opacity: 0; transform: translate(-50%, -30%); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the alert element after animation
            setTimeout(() => {
                if (companionAlert.parentNode) {
                    companionAlert.parentNode.removeChild(companionAlert);
                }
            }, 1500);
        }
        
        // Show powerup dialog with enhanced animation
        function showPowerupDialog(powerup) {
            gamePaused = true;
            currentPowerup = powerup;
            powerupFollowupIndex = 0;
            
            // Set question based on powerup type
            let question = "";
            const powerupTitle = document.getElementById('powerup-title');
            
            switch(powerup.type) {
                case 'exercise':
                    powerupTitle.textContent = "הזדמנות לשיפור בריאותי";
                    question = "האם עשית פעילות גופנית היום?";
                    powerupFollowupQuestions = [];
                    break;
                case 'healthyFood':
                    powerupTitle.textContent = "ניהול תזונה";
                    question = "האם הקפדת על תזונה בריאה היום?";
                    powerupFollowupQuestions = [];
                    break;
                case 'earlyRise':
                    powerupTitle.textContent = "ניהול זמן יעיל";
                    question = "האם קמת מוקדם היום?";
                    powerupFollowupQuestions = [];
                    break;
                case 'earlySleep':
                    powerupTitle.textContent = "הרגלי שינה";
                    question = "האם דאגת לישון מספיק שעות אתמול?";
                    powerupFollowupQuestions = [];
                    break;
                case 'money':
                    powerupTitle.textContent = "הערכת ביצועים תעסוקתית";
                    question = "האם נתת סיבה החודש למנהל שלך לתת לך בונוס כספי?";
                    // Set followup questions for bonus
                    powerupFollowupQuestions = [...bonusQuestions];
                    // Shuffle the questions to get random ones each time
                    for (let i = powerupFollowupQuestions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [powerupFollowupQuestions[i], powerupFollowupQuestions[j]] = 
                        [powerupFollowupQuestions[j], powerupFollowupQuestions[i]];
                    }
                    // Limit to 3 random questions
                    powerupFollowupQuestions = powerupFollowupQuestions.slice(0, 3);
                    break;
                case 'companion':
                    powerupTitle.textContent = "תמיכה חברתית";
                    question = "האם אתה פתוח לקבל עזרה מאחרים בהתנהלות הפיננסית שלך?";
                    powerupFollowupQuestions = [];
                    break;
            }
            
            // Set dialog content with animation
            document.getElementById('powerup-text').textContent = question;
            
            // Add special styling based on powerup type
            const dialogBox = document.getElementById('powerup-dialog');
            
            // Reset any previous custom styling
            dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
            
            // Add type-specific styling
            switch(powerup.type) {
                case 'exercise':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
                    break;
                case 'healthyFood':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)';
                    break;
                case 'money':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.3)';
                    break;
                case 'companion':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.4)';
                    break;
            }
            
            // Show dialog with enhanced animation
            dialogBox.style.display = 'block';
            dialogBox.style.animation = 'powerup-dialog-appear 0.4s ease forwards';
            
            // Add animation style if not already present
            if (!document.getElementById('powerup-dialog-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-dialog-style';
                style.textContent = `
                    @keyframes powerup-dialog-appear {
                        from { 
                            opacity: 0; 
                            transform: translate(-50%, -60%) scale(0.9); 
                        }
                        to { 
                            opacity: 1; 
                            transform: translate(-50%, -50%) scale(1); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Handle powerup yes response with enhanced feedback
        function powerupYesResponse() {
            if (!currentPowerup) return;
            
            // If this is a bonus with followup questions
            if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
                // Show positive feedback
                showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].positiveEffect, 2500);
                
                // Show next question with animation
                const questionText = document.getElementById('powerup-text');
                questionText.style.opacity = '0';
                questionText.style.transform = 'translateY(-10px)';
                
                setTimeout(() => {
                    questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
                    questionText.style.opacity = '1';
                    questionText.style.transform = 'translateY(0)';
                }, 300);
                
                powerupFollowupIndex++;
                return;
            }
            
            // Apply the powerup effect based on the type
            stats.powerupsCollected++;
            
            switch(currentPowerup.type) {
                case 'money':
                    let bonusAmount = currentPowerup.value;
                    // If player answered followup questions, provide bigger bonus
                    if (powerupFollowupQuestions.length > 0) {
                        bonusAmount = Math.round(bonusAmount * (1 + 0.2 * powerupFollowupIndex));
                    }
                    
                    score += bonusAmount;
                    stats.income += bonusAmount / 5; // Distribute the bonus over time
                    
                    // Enhance the bonus popup with animation
                    showCoinAnimation(bonusAmount);
                    showPopupMessage(`קיבלת בונוס של ${bonusAmount} ש"ח!`, 2000);
                    break;
                case 'earlyRise':
                case 'earlySleep':
                    player.powerUp = true;
                    player.powerUpTime = maxPowerUpTime;
                    player.powerUpType = currentPowerup.type;
                    document.getElementById('power-meter').style.display = 'block';
                    
                    // Improve mental health
                    stats.mentalHealth = Math.min(100, stats.mentalHealth + currentPowerup.mentalEffect);
                    
                    // Enhanced visual effect
                    showMentalBoostEffect();
                    showPopupMessage(`חיזוק פעיל: ${currentPowerup.type === 'earlyRise' ? 'ניהול זמן יעיל' : 'הרגלי שינה טובים'}`, 2000);
                    break;
                case 'healthyFood':
                case 'exercise':
                    player.powerUp = true;
                    player.powerUpTime = maxPowerUpTime;
                    player.powerUpType = currentPowerup.type;
                    document.getElementById('power-meter').style.display = 'block';
                    
                    // Improve physical health
                    stats.physicalHealth = Math.min(100, stats.physicalHealth + currentPowerup.healthEffect);
                    
                    // Enhanced visual effect
                    showPhysicalBoostEffect();
                    showPopupMessage(`חיזוק פעיל: ${currentPowerup.type === 'healthyFood' ? 'תזונה מאוזנת' : 'כושר גופני'}`, 2000);
                    break;
                case 'companion':
                    player.companion = true;
                    player.powerUp = true;
                    player.powerUpTime = maxPowerUpTime * 2; // Companion lasts longer
                    player.powerUpType = 'companion';
                    document.getElementById('power-meter').style.display = 'block';
                    
                    // Companion helps with both mental and physical health
                    stats.mentalHealth = Math.min(100, stats.mentalHealth + 15);
                    stats.physicalHealth = Math.min(100, stats.physicalHealth + 15);
                    
                    // Enhanced visual effect
                    showCompanionJoinEffect();
                    showPopupMessage("תמיכה חברתית מחזקת את החוסן האישי!", 2500);
                    break;
            }
            
            // Close the dialog and continue game with smooth exit animation
            const dialogBox = document.getElementById('powerup-dialog');
            dialogBox.style.animation = 'powerup-dialog-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('powerup-dialog-exit-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-dialog-exit-style';
                style.textContent = `
                    @keyframes powerup-dialog-exit {
                        from { 
                            opacity: 1; 
                            transform: translate(-50%, -50%) scale(1); 
                        }
                        to { 
                            opacity: 0; 
                            transform: translate(-50%, -40%) scale(0.95); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Hide dialog after animation
            setTimeout(() => {
                dialogBox.style.display = 'none';
                currentPowerup = null;
                gamePaused = false;
            }, 300);
            
            // Check achievement
            if (stats.powerupsCollected >= 10 && !achievements.powerCollector.earned) {
                achievements.powerCollector.earned = true;
                addAchievement(achievements.powerCollector.text);
            }
            
            // Update display
            updatePlayerCondition();
            updateDisplay();
        }
        
        // Helper function for coin animation
        function showCoinAnimation(amount) {
            // Create 5-10 animated coins based on amount size
            const coinCount = Math.min(10, Math.max(5, Math.floor(amount / 500)));
            
            for (let i = 0; i < coinCount; i++) {
                const coin = document.createElement('div');
                coin.className = 'animated-coin';
                
                // Style the coin
                coin.style.position = 'absolute';
                coin.style.width = '30px';
                coin.style.height = '30px';
                coin.style.borderRadius = '50%';
                coin.style.backgroundColor = '#FFD700';
                coin.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.7)';
                coin.style.zIndex = '30';
                coin.style.display = 'flex';
                coin.style.justifyContent = 'center';
                coin.style.alignItems = 'center';
                coin.style.color = '#333';
                coin.style.fontWeight = 'bold';
                coin.style.fontSize = '16px';
                coin.textContent = '₪';
                
                // Position at center of screen initially
                coin.style.top = '50%';
                coin.style.left = '50%';
                
                // Add to game container
                document.getElementById('game-container').appendChild(coin);
                
                // Animate coin
                const randomX = Math.random() * 200 - 100; // -100 to 100
                const randomY = Math.random() * 100 - 150; // -150 to -50 (upward)
                const randomDelay = Math.random() * 200;
                
                // Create dynamic keyframes for each coin
                const keyframes = `
                    @keyframes coin-move-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        10% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 1;
                        }
                        60% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY}px)) scale(1);
                            opacity: 1;
                        }
                        100% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY - 50}px)) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific coin
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    coin.style.animation = `coin-move-${i} 1.5s ease-out forwards`;
                }, randomDelay);
                
                // Remove coin after animation
                setTimeout(() => {
                    if (coin.parentNode) {
                        coin.parentNode.removeChild(coin);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, 1800 + randomDelay);
            }
            
            // Show total amount animation
            const totalAmount = document.createElement('div');
            totalAmount.className = 'total-bonus';
            totalAmount.style.position = 'absolute';
            totalAmount.style.top = '40%';
            totalAmount.style.left = '50%';
            totalAmount.style.transform = 'translate(-50%, -50%)';
            totalAmount.style.fontSize = '36px';
            totalAmount.style.fontWeight = 'bold';
            totalAmount.style.color = '#FFD700';
            totalAmount.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            totalAmount.style.zIndex = '31';
            totalAmount.style.opacity = '0';
            totalAmount.textContent = `+${amount} ₪`;
            
            document.getElementById('game-container').appendChild(totalAmount);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes total-bonus-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation with delay
            setTimeout(() => {
                totalAmount.style.animation = 'total-bonus-anim 2s ease-out forwards';
            }, 300);
            
            // Remove elements after animation
            setTimeout(() => {
                if (totalAmount.parentNode) {
                    totalAmount.parentNode.removeChild(totalAmount);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
        }
        
        // Mental boost visual effect
        function showMentalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'mental-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(42, 100, 150, 0.3) 0%, rgba(42, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes mental-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'mental-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Physical boost visual effect
        function showPhysicalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'physical-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(58, 122, 95, 0.3) 0%, rgba(58, 122, 95, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes physical-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'physical-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Companion join visual effect
        function showCompanionJoinEffect() {
            // Create multiple particles effect
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'companion-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
                particle.style.zIndex = '25';
                
                // Position around player
                particle.style.top = `${player.y + player.height / 2}px`;
                particle.style.left = `${player.x + player.width / 2}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create dynamic animation for each particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const duration = 0.8 + Math.random() * 0.7;
                const delay = Math.random() * 0.3;
                const size = 5 + Math.random() * 10;
                
                // Update size
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // Create specific keyframes for this particle
                const keyframes = `
                    @keyframes companion-particle-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        20% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 0.8;
                        }
                        100% {
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific particle
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    particle.style.animation = `companion-particle-${i} ${duration}s ease-out forwards`;
                }, delay * 1000);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, (delay + duration + 0.1) * 1000);
            }
            
            // Add companion icon
            const icon = document.createElement('div');
            icon.className = 'companion-icon';
            icon.style.position = 'absolute';
            icon.style.top = `${player.y - 40}px`;
            icon.style.left = `${player.x + player.width / 2}px`;
            icon.style.transform = 'translate(-50%, -50%)';
            icon.style.fontSize = '30px';
            icon.style.opacity = '0';
            icon.style.zIndex = '26';
            icon.textContent = '👫';
            
            document.getElementById('game-container').appendChild(icon);
            
            // Define animation for icon
            const iconStyle = document.createElement('style');
            iconStyle.textContent = `
                @keyframes companion-icon-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -80px) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -100px) scale(0.8); }
                }
            `;
            document.head.appendChild(iconStyle);
            
            // Apply animation
            icon.style.animation = 'companion-icon-anim 2s ease-out forwards';
            
            // Remove icon after animation
            setTimeout(() => {
                if (icon.parentNode) {
                    icon.parentNode.removeChild(icon);
                }
                if (iconStyle.parentNode) {
                    iconStyle.parentNode.removeChild(iconStyle);
                }
            }, 2000);
        }
        // Handle powerup no response with enhanced feedback
        function powerupNoResponse() {
            if (!currentPowerup) return;
            
            // If this is a bonus with followup questions
            if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
                // Show negative feedback
                showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].negativeEffect, 2500);
                
                // Show next question with animation
                const questionText = document.getElementById('powerup-text');
                questionText.style.opacity = '0';
                questionText.style.transform = 'translateY(-10px)';
                
                setTimeout(() => {
                    questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
                    questionText.style.opacity = '1';
                    questionText.style.transform = 'translateY(0)';
                }, 300);
                
                powerupFollowupIndex++;
                return;
            }
            
            // Apply negative effect based on type
            switch(currentPowerup.type) {
                case 'exercise':
                    // Decrease physical health
                    stats.physicalHealth = Math.max(20, stats.physicalHealth - 10);
                    showPopupMessage("העדר פעילות גופנית משפיע לרעה על בריאותך", 2500);
                    showNegativePhysicalEffect();
                    break;
                case 'healthyFood':
                    // Decrease physical health
                    stats.physicalHealth = Math.max(20, stats.physicalHealth - 10);
                    showPopupMessage("תזונה לא מאוזנת פוגעת במצב הגופני", 2500);
                    showNegativePhysicalEffect();
                    break;
                case 'earlyRise':
                case 'earlySleep':
                    // Decrease mental health
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 10);
                    showPopupMessage("ניהול זמן לקוי משפיע על המצב המנטלי", 2500);
                    showNegativeMentalEffect();
                    break;
                case 'money':
                    // No bonus for poor performance
                    showPopupMessage("פספסת הזדמנות לשיפור מצבך הפיננסי", 2500);
                    // Show subtle negative effect
                    showMissedOpportunityEffect();
                    break;
                case 'companion':
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 5);
                    showPopupMessage("תמיכה חברתית חשובה ליציבות הנפשית", 2500);
                    showNegativeMentalEffect();
                    break;
            }
            
            // Close the dialog with smooth exit animation
            const dialogBox = document.getElementById('powerup-dialog');
            dialogBox.style.animation = 'powerup-dialog-exit 0.3s ease forwards';
            
            // Hide dialog after animation
            setTimeout(() => {
                dialogBox.style.display = 'none';
                currentPowerup = null;
                gamePaused = false;
            }, 300);
            
            // Update display
            updatePlayerCondition();
            updateDisplay();
        }
        
        // Visual effect for negative physical impact
        function showNegativePhysicalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-physical-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(212, 91, 91, 0.2) 0%, rgba(212, 91, 91, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-physical {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-physical 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for negative mental impact
        function showNegativeMentalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-mental-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(100, 100, 150, 0.2) 0%, rgba(100, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-mental {
                    0% { opacity: 0; }
                    30% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-mental 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for missed opportunity
        function showMissedOpportunityEffect() {
            const effect = document.createElement('div');
            effect.className = 'missed-opportunity';
            effect.style.position = 'absolute';
            effect.style.top = '40%';
            effect.style.left = '50%';
            effect.style.transform = 'translate(-50%, -50%)';
            effect.style.color = 'rgba(150, 150, 150, 0.8)';
            effect.style.fontSize = '40px';
            effect.style.fontWeight = 'bold';
            effect.style.zIndex = '25';
            effect.style.opacity = '0';
            effect.style.textShadow = '0 0 10px rgba(150, 150, 150, 0.5)';
            effect.innerHTML = '<span style="text-decoration: line-through;">₪</span>';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes missed-opportunity {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'missed-opportunity 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Apply powerup effect (when collecting without dialog)
        function applyPowerup(powerup) {
            // For modern gameplay with interaction, show dialog instead of direct application
            showPowerupDialog(powerup);
            return;
        }
        
        // Show obstacle dialog with persuasive text and enhanced visuals
        function showObstacleDialog(obstacle) {
            // Pause the game
            gamePaused = true;
            currentObstacle = obstacle;
            persuasionStage = 0; // Reset persuasion stage
            
            // Set dialog content - initial stage
            document.getElementById('obstacle-title').textContent = obstacle.obstacleTitle;
            document.getElementById('obstacle-text').textContent = obstacle.initialText;
            
            // Change button text to be more professional
            document.getElementById('ignore-btn').textContent = "סירוב";
            document.getElementById('accept-btn').textContent = "הסכמה";
            
            // Enhanced visual styling based on obstacle type
            const dialogBox = document.getElementById('obstacle-dialog');
            
            // Reset any previous custom styling
            dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
            
            // Add type-specific styling
            switch(obstacle.type) {
                case 'person':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(100, 100, 150, 0.3)';
                    break;
                case 'ad':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(73, 80, 87, 0.3)';
                    break;
                case 'food':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
                    break;
            }
            
            // Show dialog with enhanced animation
            dialogBox.style.display = 'block';
            
            // Add a warning overlay effect
            const warningOverlay = document.createElement('div');
            warningOverlay.className = 'warning-overlay';
            warningOverlay.style.position = 'absolute';
            warningOverlay.style.top = '0';
            warningOverlay.style.left = '0';
            warningOverlay.style.width = '100%';
            warningOverlay.style.height = '100%';
            warningOverlay.style.backgroundColor = 'rgba(200, 50, 50, 0.1)';
            warningOverlay.style.opacity = '0';
            warningOverlay.style.transition = 'opacity 0.5s ease';
            warningOverlay.style.zIndex = '15';
            warningOverlay.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(warningOverlay);
            
            // Fade in the warning overlay
            setTimeout(() => {
                warningOverlay.style.opacity = '1';
            }, 100);
            
            // Store reference to remove later
            currentObstacle.warningOverlay = warningOverlay;
            
            // Add a warning icon animation near the obstacle position
            if (obstacle.x && obstacle.y) {
                const warningIcon = document.createElement('div');
                warningIcon.className = 'warning-icon';
                warningIcon.style.position = 'absolute';
                warningIcon.style.top = `${obstacle.y - 40}px`;
                warningIcon.style.left = `${obstacle.x}px`;
                warningIcon.style.fontSize = '24px';
                warningIcon.style.color = 'red';
                warningIcon.style.zIndex = '16';
                warningIcon.style.opacity = '0.9';
                warningIcon.textContent = '⚠️';
                warningIcon.style.animation = 'warning-bounce 0.8s infinite alternate';
                
                document.getElementById('game-container').appendChild(warningIcon);
                
                // Add animation style if not already defined
                if (!document.getElementById('warning-animation-style')) {
                    const style = document.createElement('style');
                    style.id = 'warning-animation-style';
                    style.textContent = `
                        @keyframes warning-bounce {
                            from { transform: translateY(0); }
                            to { transform: translateY(-10px); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Store reference to remove later
                currentObstacle.warningIcon = warningIcon;
            }
        }
        
        // Continue to next persuasion stage with enhanced visuals
        function continuePersuasion() {
            if (!currentObstacle) return;
            
            persuasionStage++;
            
            // Check if we have more persuasive texts
            if (persuasionStage <= currentObstacle.persuasiveTexts.length) {
                // Update text for current stage with animation
                const textElement = document.getElementById('obstacle-text');
                
                // Fade out current text
                textElement.style.transition = 'opacity 0.2s, transform 0.2s';
                textElement.style.opacity = '0';
                textElement.style.transform = 'translateY(-10px)';
                
                // After fade out, update text and fade in
                setTimeout(() => {
                    textElement.textContent = currentObstacle.persuasiveTexts[persuasionStage - 1];
                    
                    // Fade in new text
                    textElement.style.transform = 'translateY(0)';
                    textElement.style.opacity = '1';
                }, 200);
                
                // If this is the last stage, change the ignore button text
                if (persuasionStage === currentObstacle.persuasiveTexts.length) {
                    document.getElementById('ignore-btn').textContent = "החלטה סופית: סירוב";
                    document.getElementById('ignore-btn').style.fontWeight = 'bold';
                    document.getElementById('ignore-btn').style.background = 'var(--success-color)';
                } else {
                    document.getElementById('ignore-btn').textContent = "סירוב";
                }
                
                // Visual effect on each persuasion stage
                const persuasionEffect = document.createElement('div');
                persuasionEffect.className = 'persuasion-pulse';
                persuasionEffect.style.position = 'absolute';
                persuasionEffect.style.top = '0';
                persuasionEffect.style.left = '0';
                persuasionEffect.style.width = '100%';
                persuasionEffect.style.height = '100%';
                persuasionEffect.style.background = 'radial-gradient(circle at center, rgba(150, 50, 50, 0.1) 0%, rgba(150, 50, 50, 0) 70%)';
                persuasionEffect.style.opacity = '0';
                persuasionEffect.style.zIndex = '14';
                persuasionEffect.style.pointerEvents = 'none';
                
                document.getElementById('game-container').appendChild(persuasionEffect);
                
                // Define animation for persuasion pulse
                const pulseStyle = document.createElement('style');
                pulseStyle.textContent = `
                    @keyframes persuasion-pulse {
                        0% { opacity: 0; }
                        50% { opacity: 1; }
                        100% { opacity: 0; }
                    }
                `;
                document.head.appendChild(pulseStyle);
                
                // Apply animation
                persuasionEffect.style.animation = 'persuasion-pulse 1s ease-out forwards';
                
                // Remove elements after animation
                setTimeout(() => {
                    if (persuasionEffect.parentNode) {
                        persuasionEffect.parentNode.removeChild(persuasionEffect);
                    }
                    if (pulseStyle.parentNode) {
                        pulseStyle.parentNode.removeChild(pulseStyle);
                    }
                }, 1000);
            } else {
                // If no more texts, close the dialog
                hideObstacleDialog();
                stats.obstaclesAvoided++; // Increment obstacle resistance counter
                
                // Small mental boost for fully resisting
                stats.mentalHealth = Math.min(100, stats.mentalHealth + 5);
                updatePlayerCondition();
                
                // Show resistance message
                showPopupMessage("קבלת החלטה פיננסית מושכלת!", 2500);
                
                // Add visual reinforcement for good decision
                showPositiveDecisionEffect();
                
                // Check resistance achievement
                if (stats.obstaclesAvoided >= 20 && !achievements.resistanceMaster.earned) {
                    achievements.resistanceMaster.earned = true;
                    addAchievement(achievements.resistanceMaster.text);
                }
            }
        }
        
        // Visual effect for positive financial decision
        function showPositiveDecisionEffect() {
            // Create shield-like visual around player
            const shield = document.createElement('div');
            shield.className = 'decision-shield';
            shield.style.position = 'absolute';
            shield.style.top = `${player.y + player.height / 2}px`;
            shield.style.left = `${player.x + player.width / 2}px`;
            shield.style.width = '0';
            shield.style.height = '0';
            shield.style.borderRadius = '50%';
            shield.style.background = 'radial-gradient(circle, rgba(58, 122, 95, 0.2) 0%, rgba(58, 122, 95, 0) 70%)';
            shield.style.transform = 'translate(-50%, -50%)';
            shield.style.zIndex = '15';
            
            document.getElementById('game-container').appendChild(shield);
            
            // Define animation for expanding shield
            const shieldStyle = document.createElement('style');
            shieldStyle.textContent = `
                @keyframes shield-expand {
                    0% { width: 0; height: 0; opacity: 0; }
                    50% { width: 200px; height: 200px; opacity: 0.7; }
                    100% { width: 300px; height: 300px; opacity: 0; }
                }
            `;
            document.head.appendChild(shieldStyle);
            
            // Apply animation
            shield.style.animation = 'shield-expand 1.5s ease-out forwards';
            
            // Add checkmark icon
            const checkmark = document.createElement('div');
            checkmark.className = 'decision-checkmark';
            checkmark.style.position = 'absolute';
            checkmark.style.top = `${player.y - 30}px`;
            checkmark.style.left = `${player.x + player.width / 2}px`;
            checkmark.style.transform = 'translate(-50%, -50%)';
            checkmark.style.fontSize = '30px';
            checkmark.style.color = 'rgb(58, 122, 95)';
            checkmark.style.zIndex = '16';
            checkmark.style.opacity = '0';
            checkmark.textContent = '✓';
            
            document.getElementById('game-container').appendChild(checkmark);
            
            // Define animation for checkmark
            const checkStyle = document.createElement('style');
            checkStyle.textContent = `
                @keyframes checkmark-appear {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
                    100% { opacity: 0; transform: translate(-50%, -130%) scale(1); }
                }
            `;
            document.head.appendChild(checkStyle);
            
            // Apply animation
            checkmark.style.animation = 'checkmark-appear 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (shield.parentNode) {
                    shield.parentNode.removeChild(shield);
                }
                if (shieldStyle.parentNode) {
                    shieldStyle.parentNode.removeChild(shieldStyle);
                }
                if (checkmark.parentNode) {
                    checkmark.parentNode.removeChild(checkmark);
                }
                if (checkStyle.parentNode) {
                    checkStyle.parentNode.removeChild(checkStyle);
                }
            }, 1500);
        }
        
        // Handle accepting obstacle with enhanced visuals
        function acceptObstacle() {
            if (!currentObstacle) return;
            
            // Apply the negative effects
            score -= currentObstacle.value;
            stats.expenses += currentObstacle.value;
            
            // Apply specific effects based on obstacle type
            if (currentObstacle.type === 'person') {
                stats.mentalHealth -= currentObstacle.mentalEffect;
                showPopupMessage(`לחץ חברתי השפיע עליך: -${currentObstacle.mentalEffect} נקודות חוסן מנטלי`, 2500);
                showNegativeMentalEffect();
            } else if (currentObstacle.type === 'food') {
                stats.physicalHealth -= currentObstacle.weightEffect;
                showPopupMessage(`החלטה תזונתית לא מיטבית: -${currentObstacle.weightEffect} נקודות בריאות`, 2500);
                showNegativePhysicalEffect();
            } else {
                showPopupMessage(`הוצאה בלתי מתוכננת: ${currentObstacle.value} ש"ח`, 2000);
                showMoneyLossEffect(currentObstacle.value);
            }
            
            // Update obstacle interactions counter
            stats.obstaclesFaced++;
            
            // Update player condition
            updatePlayerCondition();
            updateDisplay();
            
            // Reset and continue game
            hideObstacleDialog();
            
            // Check if player is now bankrupt
            if (score < 0) {
                gameOver(`המאזן השלילי הוביל לקריסה פיננסית. הוצאת יותר מדי על ${currentObstacle.text}`);
                return;
            }
            
            // Check if mental or physical health is too low
            if (stats.mentalHealth <= 20) {
                gameOver("החוסן המנטלי שלך נפגע משמעותית. אינך מסוגל להמשיך.");
                return;
            }
            
            if (stats.physicalHealth <= 20) {
                gameOver("בריאותך הפיזית נפגעה באופן חמור. קשה לך להמשיך בדרך.");
                return;
            }
        }
        
        // Visual effect for money loss
        function showMoneyLossEffect(amount) {
            // Create money loss text
            const lossText = document.createElement('div');
            lossText.className = 'money-loss';
            lossText.style.position = 'absolute';
            lossText.style.top = '40%';
            lossText.style.left = '50%';
            lossText.style.transform = 'translate(-50%, -50%)';
            lossText.style.fontSize = '36px';
            lossText.style.fontWeight = 'bold';
            lossText.style.color = '#d45b5b';
            lossText.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            lossText.style.zIndex = '30';
            lossText.style.opacity = '0';
            lossText.textContent = `-${amount} ₪`;
            
            document.getElementById('game-container').appendChild(lossText);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes money-loss-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, 0) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            lossText.style.animation = 'money-loss-anim 2s ease-out forwards';
            
            // Create falling coins for large amounts
            if (amount > 1000) {
                const coinCount = Math.min(8, Math.floor(amount / 500));
                
                for (let i = 0; i < coinCount; i++) {
                    const coin = document.createElement('div');
                    coin.className = 'falling-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '20px';
                    coin.style.height = '20px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#d45b5b';
                    coin.style.boxShadow = '0 0 5px rgba(212, 91, 91, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '12px';
                    coin.textContent = '₪';
                    
                    // Position at center of screen initially
                    coin.style.top = '40%';
                    coin.style.left = '50%';
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create dynamic animation for each coin
                    const fallDelay = Math.random() * 0.5;
                    const fallDuration = 1 + Math.random() * 0.5;
                    const horizontalOffset = (Math.random() * 200) - 100; // -100px to 100px
                    
                    // Create specific keyframes for this coin
                    const coinKeyframes = `
                        @keyframes coin-fall-${i} {
                            0% { 
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1); 
                            }
                            100% { 
                                opacity: 0;
                                transform: translate(calc(-50% + ${horizontalOffset}px), calc(-50% + 200px)) scale(0.5) rotate(${Math.random() * 360}deg); 
                            }
                        }
                    `;
                    
                    // Add style for this specific coin
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-fall-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDelay + fallDuration + 0.1) * 1000);
                }
            }
            
            // Remove elements after animation
            setTimeout(() => {
                if (lossText.parentNode) {
                    lossText.parentNode.removeChild(lossText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2000);
        }
        // Hide obstacle dialog and continue game with cleanup
        function hideObstacleDialog() {
            // Hide dialog with fade out animation
            const dialogBox = document.getElementById('obstacle-dialog');
            dialogBox.style.animation = 'obstacle-dialog-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('obstacle-dialog-exit-style')) {
                const style = document.createElement('style');
                style.id = 'obstacle-dialog-exit-style';
                style.textContent = `
                    @keyframes obstacle-dialog-exit {
                        from { 
                            opacity: 1; 
                            transform: translate(-50%, -50%) scale(1); 
                        }
                        to { 
                            opacity: 0; 
                            transform: translate(-50%, -40%) scale(0.95); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Clean up warning elements
            if (currentObstacle && currentObstacle.warningOverlay) {
                currentObstacle.warningOverlay.style.opacity = '0';
                setTimeout(() => {
                    if (currentObstacle.warningOverlay.parentNode) {
                        currentObstacle.warningOverlay.parentNode.removeChild(currentObstacle.warningOverlay);
                    }
                }, 500);
            }
            
            if (currentObstacle && currentObstacle.warningIcon) {
                if (currentObstacle.warningIcon.parentNode) {
                    currentObstacle.warningIcon.parentNode.removeChild(currentObstacle.warningIcon);
                }
            }
            
            // Hide dialog after animation
            setTimeout(() => {
                dialogBox.style.display = 'none';
                currentObstacle = null;
                gamePaused = false;
                persuasionStage = 0;
                
                // Reset ignore button text and style
                document.getElementById('ignore-btn').textContent = "סירוב";
                document.getElementById('ignore-btn').style.fontWeight = 'normal';
                document.getElementById('ignore-btn').style.background = 'var(--success-color)';
            }, 300);
        }
        
        // Collision detection
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }
        
        // Handle obstacle hit
        function hitObstacle(obstacle) {
            // See if enough time has passed since last obstacle dialog
            const now = Date.now();
            if (now - lastObstacleTime < minObstacleInterval) {
                // Too soon for another obstacle dialog
                return true;
            }
            
            // Show obstacle dialog with enhanced animation
            showObstacleDialog(obstacle);
            lastObstacleTime = now;
            
            return true; // Obstacle is handled (will be removed in the main loop)
        }
        
        // Update game state
        function updateGame() {
            if (!gameRunning || gamePaused) return;
            
            // Update day/night cycle first
            updateDayNightCycle();
            
            // Show financial tip periodically
            if (Math.random() < 0.0003 && !financeMessageTimer) { // Approx every 5-6 minutes
                showFinanceTip();
            }
            
            // Update month timer only if player is moving (pressing screen)
            if (isMoving) {
                // Progress at speed adjusted to player condition
                currentMonthTimer += player.currentSpeed / player.baseSpeed;
                
                // Movement instructions - show after 5 seconds of no movement
                if (moveTimer) {
                    clearTimeout(moveTimer);
                    moveTimer = null;
                    document.getElementById('movement-instruction').style.display = 'none';
                }
            } else {
                // Show movement instructions if player doesn't move for a few seconds - shorter time, more prominent
                if (!moveTimer && !tutorialShown) {
                    moveTimer = setTimeout(() => {
                        document.getElementById('movement-instruction').style.display = 'block';
                        // הוספת אפקט הבהוב להגברת הבולטות
                        let blinkCount = 0;
                        const blinkInterval = setInterval(() => {
                            if (blinkCount >= 6 || isMoving) { // הבהוב 3 פעמים (כבוי-דלוק) או עד שהשחקן זז
                                clearInterval(blinkInterval);
                                document.getElementById('movement-instruction').style.opacity = '1';
                                return;
                            }
                            
                            const elem = document.getElementById('movement-instruction');
                            elem.style.opacity = elem.style.opacity === '0.3' ? '1' : '0.3';
                            blinkCount++;
                        }, 500); // הבהוב כל חצי שנייה
                    }, 2000); // קיצור הזמן ל-2 שניות במקום 5
                }
            }
            
            if (currentMonthTimer >= framesPerMonth) {
                currentMonthTimer = 0;
                currentMonth++;
                stats.monthsPlayed++;
                
                // Add monthly income to score with animation
                score += stats.income;
                showMonthlyIncomeEffect();
                
                // Slightly recover mental and physical health each month
                stats.mentalHealth = Math.min(100, stats.mentalHealth + 2);
                stats.physicalHealth = Math.min(100, stats.physicalHealth + 2);
                updatePlayerCondition();
                
                // Reset monthly counters at the beginning of a new month
                monthlyObstacleCounter = {
                    person: 0,
                    ad: 0,
                    food: 0
                };
                
                monthlyPowerupCounter = {
                    money: 0,
                    earlyRise: 0,
                    earlySleep: 0,
                    healthyFood: 0,
                    exercise: 0,
                    companion: 0
                };
                
                // Check win condition
                if (score >= 100000) {
                    winGame();
                    return;
                }
                
                // Update display
                updateDisplay();
                
                // Show month transition animation
                showMonthTransitionEffect();
                
                // Maybe show job offer (15% chance each month)
                if (Math.random() < 0.15) {
                    showJobOffer();
                }
                
                // Create monthly powerups
                const monthlyTypes = ['money', 'earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
                monthlyTypes.forEach(type => {
                    // Schedule powerups throughout the month
                    setTimeout(() => {
                        createCustomPowerup(type);
                    }, getRandomInt(5, monthDuration * 0.7) * 1000);
                });
                
                // Every 2 months, create a companion powerup
                if (currentMonth % 2 === 0) {
                    setTimeout(() => {
                        createCompanion();
                    }, getRandomInt(10, monthDuration * 0.6) * 1000);
                }
                
                // First month achievement
                if (currentMonth === 1 && !achievements.firstMonth.earned) {
                    achievements.firstMonth.earned = true;
                    addAchievement(achievements.firstMonth.text);
                }
                
                // Check savings achievement
                if (score >= 50000 && !achievements.saveHero.earned) {
                    achievements.saveHero.earned = true;
                    addAchievement(achievements.saveHero.text);
                }
                
                // Check mental strength achievement
                if (stats.mentalHealth >= 90 && currentMonth >= 5 && !achievements.mentalStrength.earned) {
                    achievements.mentalStrength.earned = true;
                    addAchievement(achievements.mentalStrength.text);
                }
            }
            
            // Update powerup status
            if (player.powerUp) {
                player.powerUpTime--;
                
                // Update power meter with smoother animation
                const powerFill = document.getElementById('power-meter-fill');
                const powerPercentage = (player.powerUpTime / maxPowerUpTime) * 100;
                powerFill.style.width = `${Math.min(100, powerPercentage)}%`;
                
                // Change color based on time remaining
                if (powerPercentage < 20) {
                    powerFill.style.backgroundColor = 'var(--danger-color)';
                } else if (powerPercentage < 50) {
                    powerFill.style.backgroundColor = 'var(--warning-color)';
                } else {
                    powerFill.style.backgroundColor = 'var(--success-color)';
                }
                
                if (player.powerUpTime <= 0) {
                    player.powerUp = false;
                    player.companion = false;
                    document.getElementById('power-meter').style.display = 'none';
                    showPopupMessage("השפעת החיזוק הסתיימה", 1500);
                }
            }
            
            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                
                // Update position only if player is moving
                if (isMoving) {
                    obstacle.x -= obstacle.speed;
                    
                    // Apply any obstacle-specific animations
                    if (obstacle.bobSpeed) {
                        obstacle.y = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 2;
                    }
                    
                    // For ad obstacles, add pulsing effect
                    if (obstacle.type === 'ad' && obstacle.pulseRate) {
                        obstacle.pulseValue = (Math.sin(Date.now() * obstacle.pulseRate) + 1) / 2; // 0 to 1
                    }
                }
                
                // Check for collision
                if (checkCollision(player, obstacle)) {
                    const survived = hitObstacle(obstacle);
                    obstacles.splice(i, 1);
                    
                    if (!survived) return; // Game over
                }
                
                // Remove if off-screen
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                // Update position only if player is moving
                if (isMoving) {
                    powerup.x -= powerup.speed;
                    
                    // Apply floating animation if available
                    if (powerup.floatSpeed && powerup.originalY) {
                        powerup.y = powerup.originalY + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
                    }
                }
                
                // Check for collision
                if (checkCollision(player, powerup)) {
                    // Apply powerup effect
                    applyPowerup(powerup);
                    powerups.splice(i, 1);
                }
                
                // Remove if off-screen
                if (powerup.x + powerup.width < 0) {
                    powerups.splice(i, 1);
                }
            }
            
            // Maybe create a new obstacle (0.3% chance per frame - slower for longer game)
            if (Math.random() < 0.003 && isMoving) {
                // Ensure there's enough distance from the last obstacle
                let canCreateObstacle = true;
                
                for (let i = 0; i < obstacles.length; i++) {
                    if (obstacles[i].x > canvas.width - 350) { // More space between obstacles
                        canCreateObstacle = false;
                        break;
                    }
                }
                
                if (canCreateObstacle) {
                    createObstacle();
                }
            }
            
            // Maybe create a new powerup (0.1% chance per frame - fewer powerups)
            if (Math.random() < 0.001 && isMoving) {
                // Make sure powerups are spaced out
                let canCreatePowerup = true;
                
                for (let i = 0; i < powerups.length; i++) {
                    if (powerups[i].x > canvas.width - 400) { // More space between powerups
                        canCreatePowerup = false;
                        break;
                    }
                }
                
                if (canCreatePowerup) {
                    createPowerup();
                }
            }
            
            // Process any pending obstacles
            if (pendingObstacles.length > 0 && gameRunning && isMoving) {
                const now = Date.now();
                
                for (let i = pendingObstacles.length - 1; i >= 0; i--) {
                    if (now >= pendingObstacles[i].time) {
                        createObstacle();
                        pendingObstacles.splice(i, 1);
                    }
                }
            }
            
            // Render game
            renderGame();
            
            // Update game message time
            if (gameMessageTime > 0) {
                gameMessageTime--;
                if (gameMessageTime <= 0) {
                    gameMessage = '';
                }
            }
        }
        
        // Monthly income visual effect
        function showMonthlyIncomeEffect() {
            // Create income text effect
            const incomeText = document.createElement('div');
            incomeText.className = 'income-text';
            incomeText.style.position = 'absolute';
            incomeText.style.top = '40%';
            incomeText.style.left = '50%';
            incomeText.style.transform = 'translate(-50%, -50%)';
            incomeText.style.fontSize = '32px';
            incomeText.style.fontWeight = 'bold';
            incomeText.style.color = '#3a7a5f';
            incomeText.style.textShadow = '0 0 10px rgba(58, 122, 95, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            incomeText.style.zIndex = '30';
            incomeText.style.opacity = '0';
            incomeText.textContent = `+${stats.income.toLocaleString()} ש"ח משכורת חודשית`;
            
            document.getElementById('game-container').appendChild(incomeText);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes income-text-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            incomeText.style.animation = 'income-text-anim 2.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (incomeText.parentNode) {
                    incomeText.parentNode.removeChild(incomeText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
            
            // Show falling money for visual reinforcement
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'income-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '30px';
                    coin.style.height = '30px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#3a7a5f';
                    coin.style.boxShadow = '0 0 10px rgba(58, 122, 95, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '18px';
                    coin.textContent = '₪';
                    
                    // Position at top of screen
                    const startX = Math.random() * canvas.width;
                    coin.style.top = '-30px';
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation
                    const fallDuration = 1.5 + Math.random();
                    const fallDelay = Math.random() * 0.5;
                    const rotation = Math.random() * 360;
                    const endX = startX + (Math.random() * 200 - 100);
                    
                    const coinKeyframes = `
                        @keyframes coin-income-${i} {
                            0% { 
                                opacity: 1;
                                transform: translateY(0) rotate(0deg); 
                            }
                            80% {
                                opacity: 1;
                            }
                            100% { 
                                opacity: 0;
                                transform: translateY(${canvas.height}px) translateX(${endX - startX}px) rotate(${rotation}deg); 
                            }
                        }
                    `;
                    
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-income-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDuration + fallDelay + 0.1) * 1000);
                }, i * 100); // Stagger coin creation
            }
        }
        
        // Month transition effect
        function showMonthTransitionEffect() {
            // Create month transition overlay
            const overlay = document.createElement('div');
            overlay.className = 'month-transition';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            overlay.style.zIndex = '40';
            overlay.style.pointerEvents = 'none';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            // Create month text
            const monthText = document.createElement('div');
            monthText.style.fontSize = '48px';
            monthText.style.fontWeight = 'bold';
            monthText.style.color = 'rgba(42, 100, 150, 0)';
            monthText.style.textShadow = '0 0 20px rgba(42, 100, 150, 0.5)';
            monthText.style.opacity = '0';
            monthText.style.transform = 'scale(0.8)';
            monthText.style.transition = 'all 0.5s ease';
            monthText.textContent = monthNames[currentMonth];
            
            overlay.appendChild(monthText);
            document.getElementById('game-container').appendChild(overlay);
            
            // Animate the transition
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                monthText.style.opacity = '1';
                monthText.style.color = 'rgba(42, 100, 150, 1)';
                monthText.style.transform = 'scale(1.2)';
            }, 100);
            
            setTimeout(() => {
                monthText.style.opacity = '0';
                monthText.style.transform = 'scale(0.8)';
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            }, 1500);
            
            // Remove overlay after animation
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            }, 2000);
        }
        // Create a specific type of powerup with enhanced visuals
        function createCustomPowerup(type) {
            let text = '';
            let width = 40;
            let height = 40;
            let value = 1000;
            let healthEffect = 0;
            let mentalEffect = 0;
            let color = '';
            
            switch(type) {
                case 'money':
                    text = "בונוס כספי";
                    value = getRandomInt(1000, 3000);
                    color = "#2a6496"; // Blue
                    break;
                case 'earlyRise':
                    text = "קימה מוקדמת";
                    mentalEffect = 10;
                    color = "#3a7a5f"; // Green
                    break;
                case 'earlySleep':
                    text = "שינה מוקדמת";
                    mentalEffect = 15;
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "תזונה בריאה";
                    healthEffect = 15;
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "פעילות גופנית";
                    healthEffect = 20;
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
                x: canvas.width,
                y: getRandomInt(ground.y - 150, ground.y - 60),
                width: width,
                height: height,
                type: type,
                speed: 4,
                text: text,
                value: value,
                healthEffect: healthEffect,
                mentalEffect: mentalEffect,
                color: color,
                animationOffset: Math.random() * Math.PI * 2,
                floatSpeed: 0.03 + Math.random() * 0.02,
                floatRange: 10 + Math.random() * 5,
                glowing: true,
                originalY: 0
            };
            
            // Store original Y for floating animation
            powerup.originalY = powerup.y;
            
            powerups.push(powerup);
            
            // Visual cue for powerup arrival
            showPowerupArrivalCue(powerup);
        }
        
        // Visual cue for powerup arrival
        function showPowerupArrivalCue(powerup) {
            // Create a subtle flash at the edge where the powerup will appear
            const flash = document.createElement('div');
            flash.className = 'powerup-arrival-flash';
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '20px';
            flash.style.height = `${powerup.height * 1.5}px`;
            flash.style.borderRadius = '10px 0 0 10px';
            flash.style.zIndex = '9';
            flash.style.opacity = '0';
            
            // Set color based on powerup type
            switch(powerup.type) {
                case 'money':
                    flash.style.backgroundColor = 'rgba(42, 100, 150, 0.6)';
                    break;
                case 'earlyRise':
                case 'healthyFood':
                    flash.style.backgroundColor = 'rgba(58, 122, 95, 0.6)';
                    break;
                case 'earlySleep':
                    flash.style.backgroundColor = 'rgba(90, 90, 143, 0.6)';
                    break;
                case 'exercise':
                    flash.style.backgroundColor = 'rgba(211, 135, 62, 0.6)';
                    break;
                default:
                    flash.style.backgroundColor = 'rgba(100, 100, 100, 0.6)';
            }
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define animation for flash
            const style = document.createElement('style');
            style.textContent = `
                @keyframes powerup-arrival-flash {
                    0% { opacity: 0; width: 5px; }
                    50% { opacity: 0.8; width: 20px; }
                    100% { opacity: 0; width: 5px; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            flash.style.animation = 'powerup-arrival-flash 1s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1000);
        }
        
        // Render game with enhanced visuals
        function renderGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw sky with dynamic coloring based on time
            drawDynamicBackground();
            
            // Draw subtle background patterns
            drawBackgroundPatterns();
            
            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, ground.y, 0, canvas.height);
            groundGradient.addColorStop(0, "#adb5bd");
            groundGradient.addColorStop(1, "#6c757d");
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, ground.y, ground.width, ground.height);
            
            // Draw "stable career path" text on the ground
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            ctx.font = "bold 20px 'Open Sans', Arial";
            ctx.textAlign = "center";
            const text = "נתיב קריירה יציב";
            
            // Create pattern with the text repeating across the ground
            const textWidth = ctx.measureText(text).width;
            const repetitions = Math.ceil(canvas.width / (textWidth + 100));
            
            for (let i = 0; i < repetitions; i++) {
                ctx.fillText(text, (textWidth + 100) * i + textWidth/2 + 50, ground.y + 40);
            }
            
            ctx.textAlign = "start";
            
            // Draw path edge with enhanced shadow
            const pathGlow = isDayTime ? 'rgba(73, 80, 87, 0.7)' : 'rgba(73, 80, 87, 0.9)';
            ctx.fillStyle = pathGlow;
            ctx.fillRect(0, ground.y, ground.width, 5);
            
            // Add subtle shadow/highlight to path edge based on time of day
            if (!isDayTime) {
                // Night shadow
                ctx.fillStyle = 'rgba(0, 0, 30, 0.3)';
                ctx.fillRect(0, ground.y + 5, ground.width, 3);
            } else {
                // Day highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(0, ground.y - 1, ground.width, 1);
            }
            
            // Draw player - enhanced style
            drawEnhancedPlayer();
            
            // Draw obstacles with enhanced visuals
            obstacles.forEach(obstacle => {
                switch(obstacle.type) {
                    case 'person':
                        // Draw influencer (negative influence) - more abstract shape with animation
                        ctx.fillStyle = obstacle.color || "#6c757d";
                        
                        // Apply bobbing animation
                        const personY = obstacle.y;
                        
                        // Body as rounded rectangle
                        roundRect(ctx, obstacle.x, personY, obstacle.width, obstacle.height, 10, true, false);
                        
                        // Head
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width/2, personY + obstacle.width/2, obstacle.width/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Negative expression (minimalist)
                        ctx.strokeStyle = isDayTime ? "#e9ecef" : "#f8f9fa";
                        ctx.lineWidth = 2;
                        
                        // Eyes - now with animation
                        const blinkState = Math.floor(Date.now() / 1000) % 5 === 0;
                        
                        if (blinkState) {
                            // Closed eyes (blinking)
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + obstacle.width/3 - 4, personY + obstacle.width/2);
                            ctx.lineTo(obstacle.x + obstacle.width/3 + 4, personY + obstacle.width/2);
                            
                            ctx.moveTo(obstacle.x + obstacle.width*2/3 - 4, personY + obstacle.width/2);
                            ctx.lineTo(obstacle.x + obstacle.width*2/3 + 4, personY + obstacle.width/2);
                        } else {
                            // X eyes (not blinking)
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + obstacle.width/3, personY + obstacle.width/2 - 5);
                            ctx.lineTo(obstacle.x + obstacle.width/3 + 8, personY + obstacle.width/2 + 5);
                            ctx.moveTo(obstacle.x + obstacle.width/3, personY + obstacle.width/2 + 5);
                            ctx.lineTo(obstacle.x + obstacle.width/3 + 8, personY + obstacle.width/2 - 5);
                            
                            ctx.moveTo(obstacle.x + obstacle.width*2/3, personY + obstacle.width/2 - 5);
                            ctx.lineTo(obstacle.x + obstacle.width*2/3 - 8, personY + obstacle.width/2 + 5);
                            ctx.moveTo(obstacle.x + obstacle.width*2/3, personY + obstacle.width/2 + 5);
                            ctx.lineTo(obstacle.x + obstacle.width*2/3 - 8, personY + obstacle.width/2 - 5);
                        }
                        ctx.stroke();
                        
                        // Mouth (animated - sometimes frowning more)
                        const mouthExpression = Math.sin(Date.now() * 0.001) * 3;
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width/2, personY + obstacle.width/2 + 15, 
                                obstacle.width/4, Math.PI, Math.PI * 2, true);
                        ctx.stroke();
                        
                        // Speech bubble occasionally
                        if (Math.random() < 0.01) {
                            drawSpeechBubble(ctx, obstacle.x + obstacle.width + 10, 
                                            personY + obstacle.width/2 - 10, 
                                            obstacle.text, 100, 40);
                        }
                        break;
                        
                    case 'ad':
                        // Draw ad - with pulsing effect
                        const pulseScale = obstacle.pulseValue ? 1 + (obstacle.pulseValue * 0.1) : 1;
                        const adWidth = obstacle.width * pulseScale;
                        const adHeight = obstacle.height * pulseScale;
                        const adX = obstacle.x - (adWidth - obstacle.width) / 2;
                        const adY = obstacle.y - (adHeight - obstacle.height) / 2;
                        
                        // Background with gradient
                        const adGradient = ctx.createLinearGradient(adX, adY, adX + adWidth, adY + adHeight);
                        adGradient.addColorStop(0, "#495057");
                        adGradient.addColorStop(1, "#343a40");
                        ctx.fillStyle = adGradient;
                        
                        roundRect(ctx, adX, adY, adWidth, adHeight, 8, true, false);
                        
                        // Add shiny effect
                        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
                        ctx.beginPath();
                        ctx.moveTo(adX, adY);
                        ctx.lineTo(adX + adWidth, adY);
                        ctx.lineTo(adX, adY + adHeight);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw ad icon with animation
                        ctx.fillStyle = "#e9ecef";
                        ctx.textAlign = "center";
                        ctx.font = "16px 'Open Sans', Arial";
                        ctx.fillText("₪", adX + adWidth/2, adY + adHeight/2 + 5);
                        
                        // Shopping cart icon (animated)
                        ctx.strokeStyle = "#e9ecef";
                        ctx.lineWidth = 1.5;
                        
                        // Animate cart wheels
                        const wheelRotation = Date.now() * 0.01 % (Math.PI * 2);
                        
                        ctx.beginPath();
                        // Cart body
                        ctx.moveTo(adX + adWidth/2 - 10, adY + adHeight/2 + 12);
                        ctx.lineTo(adX + adWidth/2 + 10, adY + adHeight/2 + 12);
                        ctx.lineTo(adX + adWidth/2 + 8, adY + adHeight/2 + 5);
                        ctx.lineTo(adX + adWidth/2 - 8, adY + adHeight/2 + 5);
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Wheels with rotation
                        ctx.beginPath();
                        ctx.arc(adX + adWidth/2 - 5, adY + adHeight/2 + 14, 2, 0 + wheelRotation, Math.PI * 2 + wheelRotation);
                        ctx.arc(adX + adWidth/2 + 5, adY + adHeight/2 + 14, 2, 0 + wheelRotation, Math.PI * 2 + wheelRotation);
                        ctx.fill();
                        
                        // Add sparkle effect on random positions
                        if (Math.random() < 0.1) {
                            const sparkleX = adX + Math.random() * adWidth;
                            const sparkleY = adY + Math.random() * adHeight;
                            
                            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                            ctx.beginPath();
                            ctx.arc(sparkleX, sparkleY, 1, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.textAlign = "start";
                        break;
                        
                    case 'food':
                        // Draw food item - with rotation effect
                        const foodRotation = obstacle.rotationSpeed ? Date.now() * obstacle.rotationSpeed : 0;
                        
                        // Save context for rotation
                        ctx.save();
                        ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                        ctx.rotate(Math.sin(foodRotation) * 0.05); // Subtle rotation
                        ctx.translate(-(obstacle.x + obstacle.width/2), -(obstacle.y + obstacle.height/2));
                        
                        // Draw the food container
                        ctx.fillStyle = obstacle.color || "#6c757d";
                        roundRect(ctx, obstacle.x, obstacle.y, obstacle.width, obstacle.height, 8, true, false);
                        
                        // Steam effect for hot food
                        if (Math.random() < 0.2) {
                            ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                            ctx.lineWidth = 1;
                            
                            const steamX = obstacle.x + obstacle.width/2;
                            const steamY = obstacle.y;
                            const steamHeight = 5 + Math.random() * 5;
                            
                            ctx.beginPath();
                            ctx.moveTo(steamX, steamY);
                            ctx.bezierCurveTo(
                                steamX - 5, steamY - steamHeight/2,
                                steamX + 5, steamY - steamHeight,
                                steamX, steamY - steamHeight
                            );
                            ctx.stroke();
                        }
                        
                        // Draw fork and knife icon
                        ctx.strokeStyle = "#e9ecef";
                        ctx.lineWidth = 2;
                        
                        // Fork
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width/3, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width/3, obstacle.y + obstacle.height/4 * 3);
                        ctx.moveTo(obstacle.x + obstacle.width/3 - 5, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width/3 - 5, obstacle.y + obstacle.height/4 * 2);
                        ctx.moveTo(obstacle.x + obstacle.width/3 + 5, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width/3 + 5, obstacle.y + obstacle.height/4 * 2);
                        ctx.stroke();
                        
                        // Knife
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width*2/3, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width*2/3, obstacle.y + obstacle.height/4 * 3);
                        ctx.moveTo(obstacle.x + obstacle.width*2/3 - 5, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width*2/3 + 5, obstacle.y + obstacle.height/4);
                        ctx.stroke();
                        
                        // Restore context after rotation
                        ctx.restore();
                        break;
                        
                    default:
                        // Default obstacle - minimalist style
                        ctx.fillStyle = obstacle.color || "#6c757d";
                        roundRect(ctx, obstacle.x, obstacle.y, obstacle.width, obstacle.height, 8, true, false);
                        break;
                }
            });
            
            // Draw powerups with enhanced visuals
            powerups.forEach(powerup => {
                let fillColor = powerup.color || "#6c757d";
                
                // Draw the powerup with different shapes based on type
                if (powerup.type === 'money') {
                    // Draw financial bonus - enhanced style
                    
                    // Add glow effect
                    if (powerup.glowing) {
                        ctx.shadowColor = fillColor;
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    ctx.fillStyle = fillColor;
                    roundRect(ctx, powerup.x, powerup.y, powerup.width, powerup.height, 20, true, false);
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Shekel sign with animation
                    ctx.fillStyle = "#e9ecef";
                    ctx.font = "bold 18px 'Open Sans', Arial";
                    ctx.textAlign = "center";
                    
                    // Pulsing animation for the shekel sign
                    const pulseFactor = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                    ctx.font = `bold ${18 * pulseFactor}px 'Open Sans', Arial`;
                    
                    ctx.fillText("₪", powerup.x + powerup.width/2, powerup.y + powerup.height/2 + 6);
                    ctx.textAlign = "start";
                    
                    // Add sparkle effects
                    if (Math.random() < 0.2) {
                        drawSparkle(powerup.x + powerup.width/2, powerup.y + powerup.height/2, 5, fillColor);
                    }
                } else if (powerup.type === 'companion') {
                    // Draw supportive character - enhanced style
                    
                    // Add glow effect
                    if (powerup.glowing) {
                        ctx.shadowColor = fillColor;
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    ctx.fillStyle = fillColor;
                    
                    // Body
                    roundRect(ctx, powerup.x, powerup.y + powerup.height/3, powerup.width, powerup.height*2/3, 8, true, false);
                    
                    // Head
                    ctx.beginPath();
                    ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/4, powerup.width/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Friendly face with animation
                    ctx.strokeStyle = "#e9ecef";
                    ctx.lineWidth = 1.5;
                    
                    // Blinking eyes occasionally
                    const blinkState = Math.floor(Date.now() / 1000) % 4 === 0;
                    
                    if (blinkState) {
                        // Closed eyes (blinking)
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/3 - 2, powerup.y + powerup.height/4);
                        ctx.lineTo(powerup.x + powerup.width/3 + 2, powerup.y + powerup.height/4);
                        
                        ctx.moveTo(powerup.x + powerup.width*2/3 - 2, powerup.y + powerup.height/4);
                        ctx.lineTo(powerup.x + powerup.width*2/3 + 2, powerup.y + powerup.height/4);
                        ctx.stroke();
                    } else {
                        // Open eyes (not blinking)
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/3, powerup.y + powerup.height/4, 2, 0, Math.PI * 2);
                        ctx.arc(powerup.x + powerup.width*2/3, powerup.y + powerup.height/4, 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Animated smile
                    const smileWidth = 0.8 + Math.sin(Date.now() * 0.003) * 0.2;
                    ctx.beginPath();
                    ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/4 + 2, powerup.width/5, 0, Math.PI * smileWidth);
                    ctx.stroke();
                    
                    // Emit particles for companion
                    if (powerup.emitParticles && Math.random() < 0.1) {
                        const particleX = powerup.x + powerup.width/2 + (Math.random() * 20 - 10);
                        const particleY = powerup.y + (Math.random() * 10);
                        
                        drawPowerupParticle(particleX, particleY, fillColor);
                    }
                } else {
                    // Draw other powerups - enhanced icons
                    
                    // Add glow effect
                    if (powerup.glowing) {
                        ctx.shadowColor = fillColor;
                        ctx.shadowBlur = 8;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    ctx.fillStyle = fillColor;
                    roundRect(ctx, powerup.x, powerup.y, powerup.width, powerup.height, 8, true, false);
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Different icons for different powerups
                    ctx.strokeStyle = "#e9ecef";
                    ctx.lineWidth = 2;
                    
                    if (powerup.type === 'earlyRise') {
                        // Animated alarm clock icon
                        const clockTick = Date.now() * 0.01;
                        
                        // Clock face
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/2, powerup.width/3, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Clock hands with animation
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                        ctx.lineTo(
                            powerup.x + powerup.width/2 + Math.cos(clockTick % (Math.PI * 2)) * powerup.width/5,
                            powerup.y + powerup.height/2 + Math.sin(clockTick % (Math.PI * 2)) * powerup.width/5
                        );
                        
                        ctx.moveTo(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                        ctx.lineTo(
                            powerup.x + powerup.width/2 + Math.cos((clockTick / 12) % (Math.PI * 2)) * powerup.width/8,
                            powerup.y + powerup.height/2 + Math.sin((clockTick / 12) % (Math.PI * 2)) * powerup.width/8
                        );
                        ctx.stroke();
                        
                    } else if (powerup.type === 'earlySleep') {
                        // Animated moon icon
                        const moonPulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                        
                        // Moon
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/2, 
                               powerup.width/3 * moonPulse, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Z's for sleep with animation
                        const zOffset = Math.sin(Date.now() * 0.003) * 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/2 + 5, powerup.y + powerup.height/2 - 8 + zOffset);
                        ctx.lineTo(powerup.x + powerup.width/2 - 5, powerup.y + powerup.height/2 - 8 + zOffset);
                        ctx.lineTo(powerup.x + powerup.width/2 + 5, powerup.y + powerup.height/2 + zOffset);
                        ctx.lineTo(powerup.x + powerup.width/2 - 5, powerup.y + powerup.height/2 + zOffset);
                        ctx.stroke();
                        
                    } else if (powerup.type === 'healthyFood') {
                        // Animated apple icon
                        const applePulse = 1 + Math.sin(Date.now() * 0.004) * 0.1;
                        
                        // Apple
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/2 + 2, 
                               powerup.width/3 * applePulse, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Stem with slight movement
                        const stemSway = Math.sin(Date.now() * 0.002) * 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/2, powerup.y + powerup.height/2 - powerup.height/5);
                        ctx.quadraticCurveTo(
                            powerup.x + powerup.width/2 + stemSway, 
                            powerup.y + powerup.height/2 - powerup.height/4,
                            powerup.x + powerup.width/2, 
                            powerup.y + powerup.height/2 - powerup.height/3
                        );
                        ctx.stroke();
                        
                        // Leaf with animation
                        const leafPulse = 1 + Math.sin(Date.now() * 0.006) * 0.2;
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2 + 5, 
                               powerup.y + powerup.height/2 - powerup.height/4, 
                               3 * leafPulse, 0, Math.PI * 2);
                        ctx.stroke();
                        
                    } else if (powerup.type === 'exercise') {
                        // Animated dumbbell icon
                        const dumbbellShake = Math.sin(Date.now() * 0.01) * 1;
                        
                        // Left weight with movement
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/4 + dumbbellShake, 
                               powerup.y + powerup.height/2, 
                               powerup.width/6, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Right weight with movement
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width*3/4 + dumbbellShake, 
                               powerup.y + powerup.height/2, 
                               powerup.width/6, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Handle with movement
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/4 + dumbbellShake, powerup.y + powerup.height/2);
                        ctx.lineTo(powerup.x + powerup.width*3/4 + dumbbellShake, powerup.y + powerup.height/2);
                        ctx.stroke();
                    }
                }
            });
            
            // Draw month progress bar with enhanced style
            const progressWidth = 300;
            const progressHeight = 8;
            const progressX = (canvas.width - progressWidth) / 2;
            const progressY = 60;
            
            // Background with rounded corners and shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 1;
            
            ctx.fillStyle = "rgba(222, 226, 230, 0.6)";
            roundRect(ctx, progressX, progressY, progressWidth, progressHeight, 4, true, false);
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Progress with gradient and animation
            const progress = currentMonthTimer / framesPerMonth;
            
            if (progress > 0) {
                // Create gradient based on time of day
                const progressGradient = ctx.createLinearGradient(progressX, progressY, progressX + progressWidth * progress, progressY);
                
                if (isDayTime) {
                    progressGradient.addColorStop(0, "rgba(42, 100, 150, 0.9)");
                    progressGradient.addColorStop(1, "rgba(58, 122, 95, 0.8)");
                } else {
                    progressGradient.addColorStop(0, "rgba(90, 90, 143, 0.9)");
                    progressGradient.addColorStop(1, "rgba(42, 100, 150, 0.8)");
                }
                
                ctx.fillStyle = progressGradient;
                roundRect(ctx, progressX, progressY, progressWidth * progress, progressHeight, 4, true, false);
                
                // Add subtle pulse effect at the edge of progress
                if (progress > 0.05 && progress < 0.95) {
                    const pulseSize = 3 + Math.sin(Date.now() * 0.01) * 2;
                    ctx.fillStyle = isDayTime ? "rgba(255, 255, 255, 0.5)" : "rgba(200, 200, 250, 0.5)";
                    ctx.beginPath();
                    ctx.arc(progressX + progressWidth * progress, progressY + progressHeight / 2, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw running animation if player is moving
            if (isMoving) {
                // Draw motion lines behind player - more subtle for mature look
                ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.4)" : "rgba(150, 150, 180, 0.4)";
                ctx.lineWidth = 1.5;
                
                const motionX = player.x - 30;
                
                for (let i = 0; i < 4; i++) {
                    const lineY = player.y + 20 + i * 15;
                    const lineLength = 8 + i * 4;
                    
                    // Animate motion lines length based on player speed
                    const animatedLength = lineLength * (0.8 + Math.sin(Date.now() * 0.01 + i) * 0.2);
                    
                    ctx.beginPath();
                    ctx.moveTo(motionX, lineY);
                    ctx.lineTo(motionX - animatedLength, lineY);
                    ctx.stroke();
                }
                
                // Add dust particles at player's feet when moving
                if (Math.random() < 0.2) {
                    createDustParticle();
                }
            }
            
            // Draw game messages if any
            if (gameMessage && gameMessageTime > 0) {
                const alpha = Math.min(1, gameMessageTime / 100);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#495057";
                ctx.font = "18px 'Open Sans', Arial";
                ctx.textAlign = "center";
                ctx.fillText(gameMessage, canvas.width/2, canvas.height/2);
                ctx.textAlign = "start";
                ctx.globalAlpha = 1.0;
            }
            
            // Draw dynamic day/night indicator
            drawDayNightIndicator();
        }
        
        // Draw dynamic background based on time of day
        function drawDynamicBackground() {
            // Sky gradient based on time
            let skyGradient;
            const hour = currentHour + (currentMinute / 60);
            
            skyGradient = ctx.createLinearGradient(0, 0, 0, ground.y);
            
            // Dawn (5-6)
            if (hour >= 5 && hour < 6) {
                const dawnProgress = (hour - 5);
                skyGradient.addColorStop(0, mixColorStrings('#283655', '#FF7F50', dawnProgress));
                skyGradient.addColorStop(1, mixColorStrings('#1a2238', '#FFD700', dawnProgress));
            }
            // Morning (6-10)
            else if (hour >= 6 && hour < 10) {
                skyGradient.addColorStop(0, '#87CEEB');
                skyGradient.addColorStop(1, '#ADD8E6');
            }
            // Day (10-16)
            else if (hour >= 10 && hour < 16) {
                skyGradient.addColorStop(0, '#6CA6CD');
                skyGradient.addColorStop(1, '#87CEEB');
            }
            // Afternoon (16-18)
            else if (hour >= 16 && hour < 18) {
                const afternoonProgress = (hour - 16) / 2;
                skyGradient.addColorStop(0, mixColorStrings('#6CA6CD', '#FF7F50', afternoonProgress));
                skyGradient.addColorStop(1, mixColorStrings('#87CEEB', '#FFD700', afternoonProgress));
            }
            // Sunset (18-19)
            else if (hour >= 18 && hour < 19) {
                const sunsetProgress = (hour - 18);
                skyGradient.addColorStop(0, mixColorStrings('#FF7F50', '#283655', sunsetProgress));
                skyGradient.addColorStop(1, mixColorStrings('#FFD700', '#1a2238', sunsetProgress));
            }
            // Night (19-5)
            else {
                skyGradient.addColorStop(0, '#1a2238');
                skyGradient.addColorStop(1, '#283655');
            }
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add stars at night
            if (hour >= 19 || hour < 5) {
                drawStars();
            }
            // Draw sunrise/sunset rays
            else if ((hour >= 5 && hour < 7) || (hour >= 17 && hour < 19)) {
                drawSunrays();
            }
        }
        
        // Draw stars in night sky
        function drawStars() {
            // Use the stars array created in createStars()
            if (stars.length === 0) {
                createStars();
            }
            
            stars.forEach((star, index) => {
                // Twinkle effect
                const twinkle = 0.5 + Math.sin(Date.now() * 0.001 * star.twinkleSpeed) * 0.5;
                const size = star.size * (0.7 + twinkle * 0.3);
                
                // Draw star
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + twinkle * 0.5})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Occasional larger star with glow
                if (index % 8 === 0) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Draw sunrise/sunset rays
        function drawSunrays() {
            const hour = currentHour + (currentMinute / 60);
            let rayOpacity, rayColor, sunX, sunY;
            
            // Sunrise (5-7)
            if (hour >= 5 && hour < 7) {
                rayOpacity = (hour - 5) / 2; // 0 to 1 during sunrise
                rayColor = 'rgba(255, 215, 0, '; // Golden
                sunX = canvas.width * 0.2;
                sunY = ground.y * 0.8;
            }
            // Sunset (17-19)
            else {
                rayOpacity = 1 - ((hour - 17) / 2); // 1 to 0 during sunset
                rayColor = 'rgba(255, 127, 80, '; // Coral
                sunX = canvas.width * 0.8;
                sunY = ground.y * 0.8;
            }
            
            // Limit opacity
            rayOpacity = Math.min(0.7, Math.max(0, rayOpacity));
            
            // Draw rays
            ctx.save();
            ctx.translate(sunX, sunY);
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const rayLength = 100 + Math.sin(Date.now() * 0.001 + i) * 20;
                
                ctx.rotate(angle);
                ctx.fillStyle = rayColor + rayOpacity + ')';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(rayLength, 10);
                ctx.lineTo(rayLength, -10);
                ctx.closePath();
                ctx.fill();
                ctx.rotate(-angle);
            }
            
            ctx.restore();
        }
        
        // Draw background patterns - enhanced for day/night
        function drawBackgroundPatterns() {
            ctx.fillStyle = isDayTime ? "rgba(222, 226, 230, 0.2)" : "rgba(100, 100, 150, 0.1)";
            
            // Draw subtle grid pattern
            ctx.beginPath();
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, ground.y);
            }
            for (let i = 0; i < ground.y; i += 40) {
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
            }
            ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.05)" : "rgba(100, 100, 150, 0.05)";
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Add subtle visual elements representing financial graph
            ctx.strokeStyle = isDayTime ? 
                "rgba(42, 100, 150, 0.1)" : // Day: Blue
                "rgba(100, 100, 150, 0.1)"; // Night: Purple-blue
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Draw financial graph line in background
            ctx.moveTo(0, ground.y - 100);
            
            // Use current score to influence the graph height
            const scoreInfluence = Math.min(0.5, score / 100000);
            
            for (let x = 50; x < canvas.width; x += 50) {
                // Base graph with randomness
                let y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20;
                
                // Add upward trend based on score
                y -= scoreInfluence * 100;
                
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Add data points to graph
            if (score > 10000) {
                for (let x = 100; x < canvas.width; x += 100) {
                    const y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20 - (scoreInfluence * 100);
                    
                    ctx.fillStyle = isDayTime ? "rgba(42, 100, 150, 0.2)" : "rgba(100, 100, 150, 0.2)";
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function to create dust particles at player's feet
        function createDustParticle() {
            const particle = document.createElement('div');
            particle.className = 'dust-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = isDayTime ? 'rgba(200, 200, 200, 0.6)' : 'rgba(150, 150, 180, 0.6)';
            particle.style.zIndex = '12';
            
            // Position at player's feet
            particle.style.top = `${ground.y}px`;
            particle.style.left = `${player.x + player.width / 2}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.PI + (Math.random() * Math.PI * 0.5);
            const distance = 10 + Math.random() * 20;
            const duration = 0.5 + Math.random() * 0.5;
            
            const particleKeyframes = `
                @keyframes dust-move-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.5);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `dust-move-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw sparkle effect
        function drawSparkle(x, y, size, color) {
            // Draw a simple sparkle star
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * Math.PI * 2);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            const innerSize = size * 0.5;
            const outerSize = size;
            
            // Star shape
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * outerSize, Math.sin(angle) * outerSize);
            }
            ctx.stroke();
            
            // Inner glow
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, 0, innerSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw powerup particle effect
        function drawPowerupParticle(x, y, color) {
            const particle = document.createElement('div');
            particle.className = 'powerup-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '6px';
            particle.style.height = '6px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = color || 'rgba(42, 100, 150, 0.8)';
            particle.style.zIndex = '15';
            
            // Position at source
            particle.style.top = `${y}px`;
            particle.style.left = `${x}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 30;
            const duration = 1 + Math.random() * 1;
            
            const particleKeyframes = `
                @keyframes powerup-particle-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.2);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `powerup-particle-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw day/night indicator
        function drawDayNightIndicator() {
            // Small indicator in corner
            const size = 30;
            const margin = 20;
            const x = canvas.width - size - margin;
            const y = margin;
            
            // Draw background circle
            ctx.fillStyle = isDayTime ? 'rgba(255, 255, 255, 0.6)' : 'rgba(50, 50, 80, 0.6)';
            ctx.beginPath();
            ctx.arc(x, y, size/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw icon based on time
            if (isDayTime) {
                // Sun icon
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Sun rays
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                ctx.lineWidth = 1.5;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerRadius = size/3 + 2;
                    const outerRadius = size/2 - 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        x + Math.cos(angle) * innerRadius,
                        y + Math.sin(angle) * innerRadius
                    );
                    ctx.lineTo(
                        x + Math.cos(angle) * outerRadius,
                        y + Math.sin(angle) * outerRadius
                    );
                    ctx.stroke();
                }
            } else {
                // Moon icon
                ctx.fillStyle = 'rgba(230, 230, 250, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Moon shadow
                ctx.fillStyle = 'rgba(50, 50, 80, 0.6)';
                ctx.beginPath();
                ctx.arc(x + size/8, y - size/8, size/3 - 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Stars
                for (let i = 0; i < 3; i++) {
                    const starX = x + Math.cos(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    const starY = y + Math.sin(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(starX, starY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function for color string mixing
        function mixColorStrings(color1, color2, ratio) {
            // Convert hex to rgb if needed
            const getRGB = (color) => {
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return [r, g, b];
                } else if (color.startsWith('rgb')) {
                    return color.match(/\d+/g).map(Number);
                }
                return [0, 0, 0]; // Fallback
            };
            
            const rgb1 = getRGB(color1);
            const rgb2 = getRGB(color2);
            
            const r = Math.round(rgb1[0] * (1 - ratio) + rgb2[0] * ratio);
            const g = Math.round(rgb1[1] * (1 - ratio) + rgb2[1] * ratio);
            const b = Math.round(rgb1[2] * (1 - ratio) + rgb2[2] * ratio);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        // Draw speech bubble for characters
        function drawSpeechBubble(ctx, x, y, text, maxWidth, maxHeight) {
            // Calculate text metrics and bubble size
            ctx.font = "12px 'Open Sans', Arial";
            const words = text.split(' ');
            const lineHeight = 14;
            let lines = [];
            let currentLine = '';
            
            // Break text into lines
            words.forEach(word => {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine !== '') {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // Limit number of lines to fit maxHeight
            if (lines.length * lineHeight > maxHeight) {
                lines = lines.slice(0, Math.floor(maxHeight / lineHeight) - 1);
                lines.push('...');
            }
            
            const bubbleWidth = maxWidth + 20;
            const bubbleHeight = lines.length * lineHeight + 20;
            const bubbleX = x - 10;
            const bubbleY = y - bubbleHeight / 2;
            
            // Draw bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            
            // Rounded rectangle for bubble
            roundRect(ctx, bubbleX, bubbleY, bubbleWidth, bubbleHeight, 8, true, true);
            
            // Draw pointer
            ctx.beginPath();
            ctx.moveTo(bubbleX, bubbleY + bubbleHeight / 2);
            ctx.lineTo(bubbleX - 10, bubbleY + bubbleHeight / 2 + 5);
            ctx.lineTo(bubbleX, bubbleY + bubbleHeight / 2 + 10);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();
            ctx.stroke();
            
            // Draw text
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.textAlign = 'left';
            
            lines.forEach((line, index) => {
                ctx.fillText(line, bubbleX + 10, bubbleY + 20 + (index * lineHeight));
            });
        }
        
        // Draw enhanced player with animations and visual effects
        function drawEnhancedPlayer() {
            // Use health factor to subtly adjust player appearance, not size
            const healthFactor = stats.physicalHealth / 100;
            const mentalFactor = stats.mentalHealth / 100;
            
            // Calculate player color based on health - subtle shift
            const r = Math.floor(73 + (1 - healthFactor) * 40);
            const g = Math.floor(80 + (1 - healthFactor) * 10);
            const b = Math.floor(87 + (healthFactor) * 10);
            const playerColor = `rgb(${r}, ${g}, ${b})`;
            
            // Add subtle bob animation when moving
            let playerY = player.y;
            if (isMoving) {
                playerY += Math.sin(Date.now() * 0.01) * 2;
            }
            
            // Draw shadow beneath player
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(player.x + player.width/2, ground.y, player.width/2, player.width/8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw player - enhanced style
            ctx.fillStyle = playerColor;
            
            // If player has powerUp, add glow effect
            if (player.powerUp) {
                let glowColor;
                
                switch(player.powerUpType) {
                    case 'earlyRise':
                        glowColor = 'rgba(58, 122, 95, 0.7)'; // Green-blue
                        break;
                    case 'earlySleep':
                        glowColor = 'rgba(90, 90, 143, 0.7)'; // Purple-blue
                        break;
                    case 'healthyFood':
                        glowColor = 'rgba(58, 122, 95, 0.7)'; // Green
                        break;
                    case 'exercise':
                        glowColor = 'rgba(211, 135, 62, 0.7)'; // Orange
                        break;
                    case 'companion':
                        glowColor = 'rgba(42, 100, 150, 0.7)'; // Blue
                        break;
                    default:
                        glowColor = 'rgba(73, 80, 87, 0.7)'; // Default gray
                }
                
                // Add glow with pulsating animation
                const glowSize = 10 + Math.sin(Date.now() * 0.005) * 3;
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = glowSize;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
            
            // Body as simple rounded rectangle with subtle lean forward when moving
            if (isMoving) {
                // Save context for body rotation
                ctx.save();
                ctx.translate(player.x + player.width/2, playerY + player.height/2);
                ctx.rotate(Math.PI * 0.03); // Slight forward lean
                ctx.translate(-(player.x + player.width/2), -(playerY + player.height/2));
            }
            
            roundRect(ctx, player.x, playerY, player.width, player.height, 10, true, false);
            
            if (isMoving) {
                ctx.restore();
            }
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Head with subtle head bob when moving
            const headY = playerY + player.width/2;
            const headBob = isMoving ? Math.sin(Date.now() * 0.01) * 2 : 0;
            
            ctx.beginPath();
            ctx.arc(player.x + player.width/2, headY + headBob, player.width/2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Facial expression based on mental health - dynamic style
            ctx.strokeStyle = "#e9ecef";
            ctx.lineWidth = 2;
            
            // Eyes with occasional blinking
            const blinkState = Math.floor(Date.now() / 1000) % 5 === 0;
            
            if (blinkState) {
                // Closed eyes (blinking)
                ctx.beginPath();
                ctx.moveTo(player.x + player.width/2 - 8, headY + headBob);
                ctx.lineTo(player.x + player.width/2 - 2, headY + headBob);
                
                ctx.moveTo(player.x + player.width/2 + 2, headY + headBob);
                ctx.lineTo(player.x + player.width/2 + 8, headY + headBob);
                ctx.stroke();
            } else {
                // Open eyes (not blinking)
                ctx.beginPath();
                ctx.arc(player.x + player.width/2 - 8, headY + headBob - 3, 2, 0, Math.PI * 2);
                ctx.arc(player.x + player.width/2 + 8, headY + headBob - 3, 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Mouth based on mental state - animated
            const mouthCurveBase = mentalFactor < 0.5 ? -1 : 1; // Sad or happy
            
            // Add slight animation to mouth curve
            const mouthAnimate = isMoving ? 
                Math.sin(Date.now() * 0.01) * 0.3 : // Animate when moving 
                Math.sin(Date.now() * 0.002) * 0.1;  // Subtle animation when idle
            
            const mouthCurve = mouthCurveBase + mouthAnimate;
            
            // Calculate control points for curve
            const mouthWidth = player.width/5;
            const mouthX = player.x + player.width/2;
            const mouthY = headY + headBob + 5;
            
            if (mouthCurve < 0) {
                // Sad expression
                ctx.beginPath();
                ctx.moveTo(mouthX - mouthWidth, mouthY);
                ctx.quadraticCurveTo(mouthX, mouthY + mouthWidth * Math.abs(mouthCurve), mouthX + mouthWidth, mouthY);
                ctx.stroke();
            } else {
                // Happy/neutral expression
                ctx.beginPath();
                ctx.moveTo(mouthX - mouthWidth, mouthY);
                ctx.quadraticCurveTo(mouthX, mouthY - mouthWidth * mouthCurve, mouthX + mouthWidth, mouthY);
                ctx.stroke();
            }
            
            // Draw companion if active - enhanced style
            if (player.companion && player.powerUp) {
                // Calculate companion position with slight offset from player
                const companionX = player.x - 40; 
                const companionY = playerY;
                
                // Add companion animation - follows player with slight delay
                const companionBob = isMoving ? Math.sin((Date.now() - 100) * 0.01) * 2 : 0;
                
                // Add companion shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(companionX + 15, ground.y, 15, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Companion glow effect
                ctx.shadowColor = 'rgba(42, 100, 150, 0.6)';
                ctx.shadowBlur = 8 + Math.sin(Date.now() * 0.01) * 2;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Companion body
                ctx.fillStyle = "#2a6496"; // Blue
                roundRect(ctx, companionX, companionY + companionBob + player.width, 30, player.height - player.width, 8, true, false);
                
                // Companion head
                ctx.beginPath();
                ctx.arc(companionX + 15, companionY + companionBob + player.width/2, player.width/2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Companion face
                ctx.strokeStyle = "#e9ecef";
                ctx.lineWidth = 1.5;
                
                // Eyes with occasional blink
                const companionBlink = Math.floor(Date.now() / 1000) % 6 === 0;
                
                if (companionBlink) {
                    // Closed eyes
                    ctx.beginPath();
                    ctx.moveTo(companionX + 10, companionY + companionBob + player.width/2 - 3);
                    ctx.lineTo(companionX + 15, companionY + companionBob + player.width/2 - 3);
                    
                    ctx.moveTo(companionX + 15, companionY + companionBob + player.width/2 - 3);
                    ctx.lineTo(companionX + 20, companionY + companionBob + player.width/2 - 3);
                    ctx.stroke();
                } else {
                    // Open eyes
                    ctx.beginPath();
                    ctx.arc(companionX + 10, companionY + companionBob + player.width/2 - 3, 2, 0, Math.PI * 2);
                    ctx.arc(companionX + 20, companionY + companionBob + player.width/2 - 3, 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Smile with animation
                const smileAnimate = Math.sin(Date.now() * 0.003) * 0.2;
                
                ctx.beginPath();
                ctx.arc(companionX + 15, companionY + companionBob + player.width/2 + 5, 5, 0, Math.PI * (1 + smileAnimate));
                ctx.stroke();
                
                // Connection line between player and companion
                ctx.strokeStyle = 'rgba(42, 100, 150, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                
                ctx.beginPath();
                ctx.moveTo(companionX + 30, companionY + companionBob + player.height/2);
                ctx.lineTo(player.x, playerY + player.height/2);
                ctx.stroke();
                
                // Reset line dash
                ctx.setLineDash([]);
                
                // Occasional particles between player and companion
                if (Math.random() < 0.05 && isMoving) {
                    const particleX = companionX + 30 + Math.random() * (player.x - companionX - 30);
                    const particleY = companionY + player.height/2 + (Math.random() * 20 - 10);
                    
                    drawPowerupParticle(particleX, particleY, 'rgba(42, 100, 150, 0.6)');
                }
                
                // Speech bubble from companion occasionally
                if (Math.random() < 0.003) {
                    const encouragement = [
                        "אני מאמין בך!",
                        "אתה בדרך הנכונה!",
                        "תמשיך כך!",
                        "יחד נצליח!",
                        "אתה עושה עבודה נהדרת!"
                    ];
                    
                    drawSpeechBubble(
                        ctx, 
                        companionX, 
                        companionY + companionBob, 
                        encouragement[Math.floor(Math.random() * encouragement.length)],
                        100,
                        40
                    );
                }
            }
            
            // Draw thought bubble occasionally with financial wisdom
            if (Math.random() < 0.001 && !isMoving) {
                const thoughts = [
                    "חיסכון קבוע מביא לביטחון פיננסי",
                    "ההוצאות הקטנות מצטברות",
                    "השקעה בעצמי היא ההשקעה הטובה ביותר",
                    "סבלנות היא המפתח להצלחה פיננסית",
                    "לתכנן מראש חוסך כסף בטווח הארוך"
                ];
                
                drawThoughtBubble(
                    ctx,
                    player.x + player.width + 10,
                    playerY,
                    thoughts[Math.floor(Math.random() * thoughts.length)],
                    120,
                    60
                );
            }
        }
        
        // Draw thought bubble
        function drawThoughtBubble(ctx, x, y, text, maxWidth, maxHeight) {
            // Calculate text metrics and bubble size
            ctx.font = "12px 'Open Sans', Arial";
            const words = text.split(' ');
            const lineHeight = 14;
            let lines = [];
            let currentLine = '';
            
            // Break text into lines
            words.forEach(word => {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine !== '') {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // Limit number of lines to fit maxHeight
            if (lines.length * lineHeight > maxHeight) {
                lines = lines.slice(0, Math.floor(maxHeight / lineHeight) - 1);
                lines.push('...');
            }
            
            const bubbleWidth = maxWidth + 20;
            const bubbleHeight = lines.length * lineHeight + 20;
            const bubbleX = x;
            const bubbleY = y - bubbleHeight / 2;
            
            // Draw main bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            
            // Rounded rectangle for bubble with cloud-like edges
            roundRect(ctx, bubbleX, bubbleY, bubbleWidth, bubbleHeight, 12, true, true);
            
            // Draw connecting bubbles
            const bubbleRadius = 8;
            
            // First connecting bubble
            ctx.beginPath();
            ctx.arc(bubbleX - 15, bubbleY + bubbleHeight, bubbleRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Second connecting bubble
            ctx.beginPath();
            ctx.arc(bubbleX - 25, bubbleY + bubbleHeight + 10, bubbleRadius * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Third connecting bubble
            ctx.beginPath();
            ctx.arc(bubbleX - 35, bubbleY + bubbleHeight + 15, bubbleRadius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw text
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.textAlign = 'left';
            
            lines.forEach((line, index) => {
                ctx.fillText(line, bubbleX + 10, bubbleY + 20 + (index * lineHeight));
            });
        }
        
        // Helper function for rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }
        
        // Add achievement notification with enhanced animation
        function addAchievement(text) {
            const achievementsDiv = document.getElementById('achievements');
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.textContent = text;
            achievementsDiv.appendChild(achievement);
            
            // Show achievements panel with animation
            achievementsDiv.style.display = 'block';
            achievementsDiv.style.animation = 'achievement-panel-appear 0.5s ease forwards';
            
            // Add animation style if not already present
            if (!document.getElementById('achievement-panel-style')) {
                const style = document.createElement('style');
                style.id = 'achievement-panel-style';
                style.textContent = `
                    @keyframes achievement-panel-appear {
                        from { 
                            opacity: 0; 
                            transform: translateX(-50%) translateY(-10px); 
                        }
                        to { 
                            opacity: 1; 
                            transform: translateX(-50%) translateY(0); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Display popup message with special styling
            showAchievementPopup(text);
            
            // Add some bonus points
            score += 1000;
            updateDisplay();
            
            // Show coin reward animation
            showCoinAnimation(1000);
            
            // Create achievement-specific particle effect
            createAchievementEffect();
        }
        
        // Special popup for achievements
        function showAchievementPopup(text) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.style.position = 'absolute';
            popup.style.top = '40%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.padding = '15px 30px';
            popup.style.background = 'linear-gradient(135deg, rgba(58, 122, 95, 0.9), rgba(42, 100, 150, 0.9))';
            popup.style.color = 'white';
            popup.style.borderRadius = '8px';
            popup.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.3)';
            popup.style.textAlign = 'center';
            popup.style.zIndex = '50';
            popup.style.opacity = '0';
            popup.style.minWidth = '250px';
            
            // Add medal icon
            popup.innerHTML = `
                <div style="font-size: 40px; margin-bottom: 10px;">🏆</div>
                <div style="font-weight: bold; font-size: 18px; margin-bottom: 5px;">הישג חדש!</div>
                <div>${text}</div>
                <div style="font-size: 14px; margin-top: 10px;">+1,000 ש"ח בונוס</div>
            `;
            
            document.getElementById('game-container').appendChild(popup);
            
            // Define animation for popup
            const style = document.createElement('style');
            style.textContent = `
                @keyframes achievement-popup-anim {
                    0% { 
                        opacity: 0; 
                        transform: translate(-50%, -50%) scale(0.8); 
                    }
                    20% { 
                        opacity: 1; 
                        transform: translate(-50%, -50%) scale(1.1); 
                    }
                    30% { 
                        transform: translate(-50%, -50%) scale(1); 
                    }
                    80% { 
                        opacity: 1; 
                        transform: translate(-50%, -50%) scale(1); 
                    }
                    100% { 
                        opacity: 0; 
                        transform: translate(-50%, -50%) scale(0.9); 
                    }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            popup.style.animation = 'achievement-popup-anim 4s ease-out forwards';
            
            // Play achievement sound effect here if available
            
            // Remove popup after animation
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 4000);
        }
        
        // Create achievement visual effect
        function createAchievementEffect() {
            // Create glowing ring around player
            const ring = document.createElement('div');
            ring.className = 'achievement-ring';
            ring.style.position = 'absolute';
            ring.style.top = `${player.y + player.height / 2}px`;
            ring.style.left = `${player.x + player.width / 2}px`;
            ring.style.width = '0';
            ring.style.height = '0';
            ring.style.borderRadius = '50%';
            ring.style.background = 'radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0) 70%)';
            ring.style.transform = 'translate(-50%, -50%)';
            ring.style.zIndex = '15';
            
            document.getElementById('game-container').appendChild(ring);
            
            // Define animation for ring
            const ringStyle = document.createElement('style');
            ringStyle.textContent = `
                @keyframes achievement-ring-expand {
                    0% { width: 0; height: 0; opacity: 0; }
                    30% { width: 200px; height: 200px; opacity: 0.8; }
                    100% { width: 400px; height: 400px; opacity: 0; }
                }
            `;
            document.head.appendChild(ringStyle);
            
            // Apply animation
            ring.style.animation = 'achievement-ring-expand 2s ease-out forwards';
            
            // Create explosion of particles
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'achievement-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '8px';
                particle.style.height = '8px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = 'rgba(255, 215, 0, 0.8)';
                particle.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                particle.style.zIndex = '16';
                
                // Position at player
                particle.style.top = `${player.y + player.height / 2}px`;
                particle.style.left = `${player.x + player.width / 2}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create specific animation for this particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 200;
                const duration = 1 + Math.random();
                const delay = Math.random() * 0.3;
                
                const particleKeyframes = `
                    @keyframes achievement-particle-${i} {
                        0% { 
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1); 
                        }
                        100% { 
                            opacity: 0;
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5); 
                        }
                    }
                `;
                
                const particleStyle = document.createElement('style');
                particleStyle.textContent = particleKeyframes;
                document.head.appendChild(particleStyle);
                
                // Apply animation with delay
                setTimeout(() => {
                    particle.style.animation = `achievement-particle-${i} ${duration}s ease-out forwards`;
                }, delay * 1000);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (particleStyle.parentNode) {
                        particleStyle.parentNode.removeChild(particleStyle);
                    }
                }, (delay + duration + 0.1) * 1000);
            }
            
            // Remove ring after animation
            setTimeout(() => {
                if (ring.parentNode) {
                    ring.parentNode.removeChild(ring);
                }
                if (ringStyle.parentNode) {
                    ringStyle.parentNode.removeChild(ringStyle);
                }
            }, 2100);
        }
        // Update display with animated transitions
        function updateDisplay() {
            // Update score with smooth animation if significant change
            const scoreDisplay = document.getElementById('score-display');
            const currentScoreText = scoreDisplay.textContent;
            const currentScore = parseInt(currentScoreText.match(/\d+/g).join(''));
            
            if (Math.abs(currentScore - score) > 100) {
                // Animate score change
                animateScoreChange(currentScore, score);
            } else {
                // Small change, just update
                scoreDisplay.textContent = `סך נכסים פיננסיים: ${score.toLocaleString()} ש"ח`;
            }
            
            // Update date display with transition effect
            const dateDisplay = document.getElementById('date-display');
            
            if (dateDisplay.textContent !== monthNames[currentMonth]) {
                // Save original transform
                const originalTransform = dateDisplay.style.transform;
                
                // Fade out
                dateDisplay.style.opacity = '0';
                dateDisplay.style.transform = 'translateY(-5px)';
                
                // After fade out, update text and fade in
                setTimeout(() => {
                    dateDisplay.textContent = monthNames[currentMonth];
                    dateDisplay.style.opacity = '1';
                    dateDisplay.style.transform = originalTransform;
                }, 300);
            }
            
            // Update monthly stats
            document.getElementById('expenses').textContent = stats.expenses.toLocaleString();
            document.getElementById('income').textContent = stats.income.toLocaleString();
            
            // Highlight changes in income or expenses with color flash
            const expensesElem = document.getElementById('expenses');
            const incomeElem = document.getElementById('income');
            
            // Flash expenses if they changed
            if (stats.expenses > parseInt(expensesElem.getAttribute('data-prev-value') || '0')) {
                flashElement(expensesElem, 'rgba(212, 91, 91, 0.2)');
            }
            
            // Flash income if it changed
            if (stats.income > parseInt(incomeElem.getAttribute('data-prev-value') || '0')) {
                flashElement(incomeElem, 'rgba(58, 122, 95, 0.2)');
            }
            
            // Store current values for next comparison
            expensesElem.setAttribute('data-prev-value', stats.expenses);
            incomeElem.setAttribute('data-prev-value', stats.income);
        }
        
        // Animate score change with counting effect
        function animateScoreChange(startScore, endScore) {
            const scoreDisplay = document.getElementById('score-display');
            const duration = 1000; // 1 second animation
            const startTime = Date.now();
            const scoreChange = endScore - startScore;
            
            // Add highlight effect based on score change direction
            if (scoreChange > 0) {
                scoreDisplay.style.color = 'var(--success-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(58, 122, 95, 0.3)';
            } else if (scoreChange < 0) {
                scoreDisplay.style.color = 'var(--danger-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(212, 91, 91, 0.3)';
            }
            
            // Animation function
            function animate() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Easing function for smoother animation
                const easedProgress = progress < 0.5 ? 
                    4 * progress * progress * progress : 
                    1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                // Calculate current value
                const currentValue = Math.round(startScore + scoreChange * easedProgress);
                
                // Update display
                scoreDisplay.textContent = `סך נכסים פיננסיים: ${currentValue.toLocaleString()} ש"ח`;
                
                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Reset style after animation
                    setTimeout(() => {
                        scoreDisplay.style.color = 'var(--primary-color)';
                        scoreDisplay.style.textShadow = 'none';
                    }, 500);
                }
            }
            
            // Start animation
            animate();
        }
        
        // Flash element background color
        function flashElement(element, color) {
            // Save original background
            const originalBg = element.style.backgroundColor;
            const originalTransition = element.style.transition;
            
            // Apply flash
            element.style.transition = 'background-color 0.1s ease-in';
            element.style.backgroundColor = color;
            
            // Remove flash with transition
            setTimeout(() => {
                element.style.transition = 'background-color 0.5s ease-out';
                element.style.backgroundColor = originalBg;
                
                // Reset transition after animation
                setTimeout(() => {
                    element.style.transition = originalTransition;
                }, 500);
            }, 100);
        }
        
        // Show job offer with enhanced visuals
        function showJobOffer() {
            gamePaused = true;
            jobOfferStage = 0;
            
            // Prepare dialog with animation
            const jobOfferDialog = document.getElementById('job-offer');
            jobOfferDialog.style.animation = 'job-offer-appear 0.5s ease forwards';
            
            // Add animation style if not already present
            if (!document.getElementById('job-offer-style')) {
                const style = document.createElement('style');
                style.id = 'job-offer-style';
                style.textContent = `
                    @keyframes job-offer-appear {
                        from {
                            opacity: 0;
                            transform: translate(-50%, -60%) scale(0.9);
                        }
                        to {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Add subtle background overlay
            const overlay = document.createElement('div');
            overlay.className = 'job-offer-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            overlay.style.zIndex = '90';
            overlay.style.opacity = '0';
            overlay.style.transition = 'opacity 0.5s ease';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in overlay
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 100);
            
            // Store overlay reference for cleanup
            jobOfferDialog.dataset.overlay = 'true';
            
            // Show dialog
            jobOfferDialog.style.display = 'block';
            
            // Add career icon animation
            const careerIcon = document.createElement('div');
            careerIcon.className = 'career-icon';
            careerIcon.style.position = 'absolute';
            careerIcon.style.top = '-40px';
            careerIcon.style.left = '50%';
            careerIcon.style.transform = 'translateX(-50%)';
            careerIcon.style.fontSize = '50px';
            careerIcon.style.opacity = '0';
            careerIcon.style.transition = 'all 0.5s ease';
            careerIcon.textContent = '💼';
            
            jobOfferDialog.appendChild(careerIcon);
            
            // Animate icon
            setTimeout(() => {
                careerIcon.style.opacity = '1';
                careerIcon.style.top = '-60px';
            }, 300);
        }
        
        // Show job offer followup with enhanced visuals
        function showJobOfferFollowup() {
            // Hide job offer dialog
            const jobOfferDialog = document.getElementById('job-offer');
            jobOfferDialog.style.animation = 'job-offer-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('job-offer-exit-style')) {
                const style = document.createElement('style');
                style.id = 'job-offer-exit-style';
                style.textContent = `
                    @keyframes job-offer-exit {
                        from {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        to {
                            opacity: 0;
                            transform: translate(-50%, -60%) scale(0.9);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // After exit animation, hide dialog and show followup
            setTimeout(() => {
                jobOfferDialog.style.display = 'none';
                
                // Check if there's a career icon to remove
                const careerIcon = jobOfferDialog.querySelector('.career-icon');
                if (careerIcon) {
                    jobOfferDialog.removeChild(careerIcon);
                }
                
                // Set followup text
                document.getElementById('followup-text').textContent = jobOfferTexts[jobOfferStage];
                
                // Show followup dialog with entrance animation
                const followupDialog = document.getElementById('job-offer-followup');
                followupDialog.style.animation = 'job-followup-appear 0.4s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('job-followup-style')) {
                    const style = document.createElement('style');
                    style.id = 'job-followup-style';
                    style.textContent = `
                        @keyframes job-followup-appear {
                            from {
                                opacity: 0;
                                transform: translate(-50%, -40%) scale(0.95);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                followupDialog.style.display = 'block';
                
                // Add persuasion icon based on stage
                let persuasionIcon = '💰'; // Default money
                
                if (jobOfferStage === 1) persuasionIcon = '📈'; // Growth
                if (jobOfferStage === 2) persuasionIcon = '🚀'; // Career
                if (jobOfferStage === 3) persuasionIcon = '⏱️'; // Time/flexibility
                
                const iconElem = document.createElement('div');
                iconElem.className = 'persuasion-icon';
                iconElem.style.position = 'absolute';
                iconElem.style.top = '-40px';
                iconElem.style.left = '50%';
                iconElem.style.transform = 'translateX(-50%)';
                iconElem.style.fontSize = '40px';
                iconElem.style.opacity = '0';
                iconElem.style.transition = 'all 0.5s ease';
                iconElem.textContent = persuasionIcon;
                
                followupDialog.appendChild(iconElem);
                
                // Animate icon
                setTimeout(() => {
                    iconElem.style.opacity = '1';
                    iconElem.style.top = '-50px';
                }, 300);
            }, 300);
        }
        
        // Game over with enhanced visuals
        function gameOver(reason) {
            gameRunning = false;
            
            // Update game stats
            document.getElementById('game-over-reason').textContent = reason;
            document.getElementById('final-score').textContent = score.toLocaleString();
            document.getElementById('months-played').textContent = stats.monthsPlayed;
            document.getElementById('powerups-collected').textContent = stats.powerupsCollected;
            document.getElementById('obstacles-avoided').textContent = stats.obstaclesFaced;
            
            // Create dramatic overlay
            const overlay = document.createElement('div');
            overlay.className = 'game-over-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            overlay.style.transition = 'background-color 1.5s ease';
            overlay.style.zIndex = '90';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in dark overlay
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
            }, 100);
            
            // Show game over with enhanced animation
            setTimeout(() => {
                const gameOverScreen = document.getElementById('game-over');
                gameOverScreen.style.display = 'block';
                gameOverScreen.style.animation = 'game-over-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('game-over-style')) {
                    const style = document.createElement('style');
                    style.id = 'game-over-style';
                    style.textContent = `
                        @keyframes game-over-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.05);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Add dramatic visual effects
                createGameOverEffect();
            }, 800);
        }
        
        // Create visual effects for game over
        function createGameOverEffect() {
            // Add falling coins/money effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'falling-money';
                    
                    // Randomize coin appearance - dollar, shekel, or coins
                    const coinTypes = ['💰', '💸', '₪', '💵'];
                    const coinText = coinTypes[Math.floor(Math.random() * coinTypes.length)];
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.fontSize = `${20 + Math.random() * 20}px`;
                    coin.style.opacity = '0.7';
                    coin.style.zIndex = '91';
                    coin.style.color = '#d45b5b';
                    coin.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.5)';
                    coin.textContent = coinText;
                    
                    // Position randomly at top
                    const startX = Math.random() * window.innerWidth;
                    coin.style.top = `-50px`;
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation for falling
                    const fallDuration = 3 + Math.random() * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 720;
                    const horizontalMovement = (Math.random() - 0.5) * 100;
                    const delay = Math.random() * 2;
                    
                    // Create keyframes for this specific coin
                    const keyframes = `
                        @keyframes fall-${Date.now()}-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0.7;
                            }
                            80% {
                                opacity: 0.7;
                            }
                            100% {
                                transform: translateY(${window.innerHeight + 100}px) 
                                           translateX(${horizontalMovement}px) 
                                           rotate(${rotationSpeed}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    
                    // Add style for this specific animation
                    const style = document.createElement('style');
                    style.textContent = keyframes;
                    document.head.appendChild(style);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `fall-${Date.now()}-${i} ${fallDuration}s cubic-bezier(0.4, 0, 1, 1) forwards`;
                    }, delay * 1000);
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (style.parentNode) {
                            style.parentNode.removeChild(style);
                        }
                    }, (fallDuration + delay + 0.5) * 1000);
                }, i * 200); // Stagger coin creation
            }
            
            // Add crack in ground effect
            const crack = document.createElement('div');
            crack.className = 'ground-crack';
            crack.style.position = 'absolute';
            crack.style.top = `${ground.y - 10}px`;
            crack.style.left = '50%';
            crack.style.transform = 'translateX(-50%)';
            crack.style.width = '0';
            crack.style.height = '20px';
            crack.style.backgroundColor = '#333';
            crack.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5), 0 0 5px rgba(255, 0, 0, 0.3)';
            crack.style.zIndex = '91';
            
            document.getElementById('game-container').appendChild(crack);
            
            // Create crack animation
            const crackStyle = document.createElement('style');
            crackStyle.textContent = `
                @keyframes crack-grow {
                    0% { width: 0; }
                    60% { width: 60%; }
                    100% { width: 50%; }
                }
            `;
            document.head.appendChild(crackStyle);
            
            // Apply animation
            crack.style.animation = 'crack-grow 1.2s ease-out forwards';
        }
        
        // Win game with enhanced visuals
        function winGame() {
            gameRunning = false;
            
            // Update win stats
            document.getElementById('win-months').textContent = stats.monthsPlayed;
            document.getElementById('win-powerups').textContent = stats.powerupsCollected;
            document.getElementById('win-obstacles').textContent = stats.obstaclesFaced;
            
            // Create celebratory overlay
            const overlay = document.createElement('div');
            overlay.className = 'win-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'radial-gradient(circle, rgba(42, 100, 150, 0) 0%, rgba(42, 100, 150, 0.3) 100%)';
            overlay.style.transition = 'all 1.5s ease';
            overlay.style.zIndex = '90';
            overlay.style.opacity = '0';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in overlay
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 100);
            
            // Create celebration effects
            createWinEffects();
            
            // Show win screen with enhanced animation
            setTimeout(() => {
                const winScreen = document.getElementById('win-screen');
                winScreen.style.display = 'block';
                winScreen.style.animation = 'win-screen-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('win-screen-style')) {
                    const style = document.createElement('style');
                    style.id = 'win-screen-style';
                    style.textContent = `
                        @keyframes win-screen-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.1);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }, 1500);
        }
        
        // Create celebration effects for win
        function createWinEffects() {
            // Create fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createFirework();
                }, i * 300);
            }
            
            // Create golden rain
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    createGoldenRain();
                }, Math.random() * 2000);
            }
            
            // Create floating achievement icons
            const achievementIcons = ['💰', '📈', '🏆', '💪', '📊', '✅', '🎯'];
            
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const icon = document.createElement('div');
                    icon.className = 'floating-achievement';
                    
                    // Style the icon
                    icon.style.position = 'absolute';
                    icon.style.fontSize = `${30 + Math.random() * 20}px`;
                    icon.style.opacity = '0';
                    icon.style.zIndex = '91';
                    icon.textContent = achievementIcons[Math.floor(Math.random() * achievementIcons.length)];
                    
                    // Position randomly
                    icon.style.top = `${Math.random() * (window.innerHeight * 0.7)}px`;
                    icon.style.left = `${Math.random() * window.innerWidth}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(icon);
                    
                    // Define animation
                    const floatDuration = 5 + Math.random() * 3;
                    const floatDistance = 100 + Math.random() * 200;
                    
                    const iconStyle = document.createElement('style');
                    iconStyle.textContent = `
                        @keyframes float-icon-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0;
                            }
                            10% {
                                opacity: 0.9;
                            }
                            90% {
                                opacity: 0.9;
                            }
                            100% {
                                transform: translateY(-${floatDistance}px) rotate(${Math.random() * 40 - 20}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    document.head.appendChild(iconStyle);
                    
                    // Apply animation
                    icon.style.animation = `float-icon-${i} ${floatDuration}s ease-out forwards`;
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (icon.parentNode) {
                            icon.parentNode.removeChild(icon);
                        }
                        if (iconStyle.parentNode) {
                            iconStyle.parentNode.removeChild(iconStyle);
                        }
                    }, floatDuration * 1000 + 100);
                }, i * 500 + Math.random() * 1000);
            }
        }
        
        // Create a firework effect
        function createFirework() {
            // Create firework explosion at random position
            const explosionX = Math.random() * window.innerWidth;
            const explosionY = Math.random() * (window.innerHeight * 0.6);
            
            // Random firework color
            const colors = [
                '255, 215, 0',  // Gold
                '42, 100, 150', // Blue
                '58, 122, 95',  // Green
                '255, 127, 80', // Coral
                '147, 112, 219' // Purple
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Create particles
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'firework-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = `rgba(${color}, 0.8)`;
                particle.style.boxShadow = `0 0 6px rgba(${color}, 0.5)`;
                particle.style.zIndex = '92';
                
                // Position at explosion center
                particle.style.top = `${explosionY}px`;
                particle.style.left = `${explosionX}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create specific animation for this particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 150;
                const duration = 0.8 + Math.random() * 0.6;
                
                const particleKeyframes = `
                    @keyframes firework-particle-${Date.now()}-${i} {
                        0% { 
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1.5); 
                        }
                        100% { 
                            opacity: 0;
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5); 
                        }
                    }
                `;
                
                const particleStyle = document.createElement('style');
                particleStyle.textContent = particleKeyframes;
                document.head.appendChild(particleStyle);
                
                // Apply animation
                particle.style.animation = `firework-particle-${Date.now()}-${i} ${duration}s ease-out forwards`;
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (particleStyle.parentNode) {
                        particleStyle.parentNode.removeChild(particleStyle);
                    }
                }, duration * 1000 + 100);
            }
        }
        
        // Create golden rain for win effect
        function createGoldenRain() {
            const coin = document.createElement('div');
            coin.className = 'golden-rain';
            
            // Style coin
            coin.style.position = 'absolute';
            coin.style.fontSize = `${15 + Math.random() * 10}px`;
            coin.style.opacity = '0.9';
            coin.style.zIndex = '91';
            coin.style.color = '#FFD700';
            coin.style.textShadow = '0 0 5px rgba(255, 215, 0, 0.7)';
            coin.textContent = '₪';
            
            // Position at top with random horizontal placement
            const startX = Math.random() * window.innerWidth;
            coin.style.top = `-20px`;
            coin.style.left = `${startX}px`;
            
            document.getElementById('game-container').appendChild(coin);
            
            // Create animation
            const fallDuration = 3 + Math.random() * 2;
            const swayAmount = 50 + Math.random() * 50;
            const direction = Math.random() > 0.5 ? 1 : -1;
            const rotationAmount = Math.random() * 360;
            
            const keyframes = `
                @keyframes golden-rain-${Date.now()} {
                    0% {
                        transform: translateY(0) rotate(0deg);
                        opacity: 0;
                    }
                    10% {
                        opacity: 0.9;
                    }
                    100% {
                        transform: translateY(${window.innerHeight + 50}px) 
                                   translateX(${swayAmount * direction}px) 
                                   rotate(${rotationAmount}deg);
                        opacity: 0.7;
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = keyframes;
            document.head.appendChild(style);
            
            // Apply animation
            coin.style.animation = `golden-rain-${Date.now()} ${fallDuration}s ease-in forwards`;
            
            // Remove elements after animation
            setTimeout(() => {
                if (coin.parentNode) {
                    coin.parentNode.removeChild(coin);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, fallDuration * 1000 + 100);
        }
