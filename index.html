<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>××©×—×§ ×”××©××¢×ª ×”×¤×™× × ×¡×™×ª</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        /* ×™×™×‘×•× ×¤×•× ×˜ Rubik ×œ×¢×‘×¨×™×ª */
        @import url('https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;600;700&display=swap');
        
        /* ×”×’×“×¨×•×ª ×’×œ×•×‘×œ×™×•×ª ×œ×“×™××œ×•×’×™× */
        .dialog-box, #obstacle-dialog, #powerup-dialog, #job-offer, #job-offer-followup {
            position: absolute;
            z-index: 9999 !important; /* z-index ×’×‘×•×” ×‘××™×•×—×“ */
            pointer-events: auto !important; /* ×•×™×“×•× ×©××™×¨×•×¢×™ ×¢×›×‘×¨ ×™×ª×¤×¡×• */
        }
    
        /* ×©×›×‘×ª ××¤×œ×” ×’×œ×•×‘×œ×™×ª */
        .dialog-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 9998 !important; /* ××ª×—×ª ×œ×“×™××œ×•×’×™× ××š ××¢×œ ×œ×›×œ ×”×™×ª×¨ */
            pointer-events: auto !important; /* ×œ×—×¡×™××ª ××™×¨×•×¢×™× */
        }
    
        :root {
            --primary-color: #2a6496;
            --secondary-color: #4a4a4a;
            --success-color: #3a7a5f;
            --warning-color: #d3873e;
            --danger-color: #d45b5b;
            --background-color: #f8f9fa;
            --card-color: rgba(255, 255, 255, 0.95);
            --text-color: #333333;
            --text-light: #ffffff;
            --day-sky-color-start: #87CEEB;
            --day-sky-color-end: #ADD8E6;
            --night-sky-color-start: #1a2238;
            --night-sky-color-end: #283655;
            --sunset-sky-color-start: #FF7F50;
            --sunset-sky-color-end: #FFD700;
            --sunrise-sky-color-start: #FF7F50;
            --sunrise-sky-color-end: #ADD8E6;
        }
        
        body {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background-color: var(--background-color);
    font-family: 'Rubik', 'Open Sans', 'Segoe UI', sans-serif;
    color: var(--text-color);
    transition: background-color 0.5s ease;
    user-select: none; /* ×× ×™×¢×ª ×¡×™××•×Ÿ ×˜×§×¡×˜ */
    -webkit-user-select: none; /* ×¢×‘×•×¨ ×¡×¤××¨×™ */
    -moz-user-select: none; /* ×¢×‘×•×¨ ×¤×™×™×¨×¤×•×§×¡ */
    -ms-user-select: none; /* ×¢×‘×•×¨ ××§×¡×¤×œ×•×¨×¨/××“×’' */
    -webkit-tap-highlight-color: transparent; /* ×× ×™×¢×ª ×”×‘×”×•×‘ ×‘×œ×—×™×¦×” ×‘××›×©×™×¨×™ ××’×¢ */
}
        
        #game-container {
    position: relative;
    width: 100vw;
    height: 100vh;
    overflow: hidden;
}

/* ×œ×•×— ××—×•×•× ×™× ×××•×—×“ */
.dashboard-container {
    position: absolute;
    top: 80px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 8px;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.15);
    z-index: 20;
    width: 320px;
    text-align: center;
    transition: all 0.3s ease;
    overflow: hidden;
    direction: rtl;
    display: none; /* ×”×¡×ª×¨×ª ×”×“×©×‘×•×¨×“ ×‘×ª×—×™×œ×ª ×”××©×—×§ */
}

@media (max-width: 768px) {
    .dashboard-container {
        width: 85%; /* ×¨×•×—×‘ ×™×—×¡×™ ×œ××¡×š ×‘××§×•× ×¨×•×—×‘ ×§×‘×•×¢ */
        max-width: 280px; /* ×”×’×‘×œ×ª ×¨×•×—×‘ ××§×¡×™××œ×™ */
        font-size: 90%; /* ×”×§×˜× ×ª ×¤×•× ×˜ */
        top: 60px; /* ×”×–×–×” ×œ××¢×œ×” ×™×•×ª×¨ */
    }
}

.dashboard-header {
    background-color: var(--primary-color);
    color: white;
    padding: 12px 15px;
    font-weight: 600;
    font-size: 18px;
    border-radius: 8px 8px 0 0;
    cursor: pointer;
    position: relative;
}

.dashboard-header:after {
    content: 'â–¼';
    position: absolute;
    right: 15px;
    transition: transform 0.3s;
}

.dashboard-collapsed .dashboard-header:after {
    transform: rotate(180deg);
}

.dashboard-collapsed .dashboard-content {
    display: none;
}

@media (max-width: 768px) {
    .dashboard-header {
        padding: 8px 12px;
        font-size: 16px;
    }
}

.dashboard-content {
    padding: 15px;
}

.dashboard-section {
    margin-bottom: 15px;
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding-bottom: 12px;
}

@media (max-width: 768px) {
    .dashboard-content {
        padding: 10px 8px;
    }
    
    .dashboard-section {
        margin-bottom: 8px;
        padding-bottom: 8px;
    }
}

.dashboard-section:last-child {
    margin-bottom: 0;
    border-bottom: none;
    padding-bottom: 0;
}

.section-title {
    font-weight: 600;
    margin-bottom: 8px;
    color: var(--secondary-color);
    font-size: 16px;
}

.finance-info {
    display: flex;
    flex-direction: column;
    gap: 5px;
    font-size: 14px;
}

.finance-row {
    display: flex;
    justify-content: space-between;
    width: 100%;
}

.finance-col {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.health-info {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

@media (max-width: 768px) {
    .section-title {
        font-size: 14px;
        margin-bottom: 5px;
    }
    
    .finance-info {
        gap: 3px;
        font-size: 12px;
    }
    
    .health-info {
        gap: 5px;
    }
    
    .finance-row {
        flex-direction: column;
        gap: 8px;
    }
}

.health-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    margin-bottom: 4px;
}

.health-bar .label {
    width: 60px;
    text-align: right;
    font-size: 14px;
}

.health-bar .bar {
    flex-grow: 1;
    height: 10px;
    background-color: #e9ecef;
    border-radius: 5px;
    overflow: hidden;
}

@media (max-width: 768px) {
    .health-bar .bar {
        height: 8px;
        border-radius: 4px;
    }
}

.clock-section {
    display: flex;
    justify-content: space-between;
    align-items: center;
}

.day-clock-container {
    display: flex;
    flex-direction: column;
    align-items: center;
}

.speed-indicator-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    margin-right: 10px;
}

#dashboard-speed-indicator {
    font-size: 16px;
    font-weight: bold;
    padding: 3px 8px;
    border-radius: 4px;
    background-color: rgba(58, 122, 95, 0.8);
    color: white;
}

#dashboard-speed-indicator.medium {
    background-color: rgba(214, 177, 45, 0.9);
}

#dashboard-speed-indicator.slow {
    background-color: rgba(211, 135, 62, 0.9);
}

#dashboard-speed-indicator.very-slow {
    background-color: rgba(212, 91, 91, 0.9);
}

@media (max-width: 768px) {
    .clock-section {
        flex-direction: column;
        gap: 10px;
    }
    
    .speed-indicator-container {
        margin-right: 0;
    }
    
    #dashboard-speed-indicator {
        font-size: 14px;
        padding: 2px 6px;
    }
}

#day-clock {
    font-size: 28px;
    font-weight: bold;
    background-color: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 5px 15px;
    border-radius: 5px;
    margin-top: 5px;
}

@media (max-width: 768px) {
    #day-clock {
        font-size: 20px;
        padding: 3px 10px;
        margin-top: 3px;
    }
}

#game-canvas {
    position: absolute;
    top: 0;
    left: 0;
    touch-action: none;
    transition: filter 2s ease; /* Smooth transition for day/night filter */
}
        
.game-display {
    position: absolute;
    padding: 10px 15px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 5px;
    font-size: 16px;
    font-weight: 600;
    z-index: 10;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: all 0.3s ease;
}
        
#score-display {
    position: static;
    padding: 0;
    background-color: transparent;
    box-shadow: none;
    color: white;
    font-size: 18px;
    text-align: center;
}
        
#date-display {
    top: 15px;
    left: 15px;
    color: var(--secondary-color);
}
        
#monthly-stats {
    display: none; /* ×”×¡×ª×¨×ª ×”×ª×™×‘×” ×”××§×•×¨×™×ª */
}

/* ×”×¡×ª×¨×ª ×ª×™×‘×ª ×”×‘×¨×™××•×ª ×”××§×•×¨×™×ª */
.health-bars {
    display: none;
}
        
        #monthly-stats div {
            margin-bottom: 5px;
        }
        
        #tutorial-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    padding: 35px; /* ×”×’×“×œ× ×• ××ª ×”×¤×“×™× ×’ ×-25px ×œ-35px */
    background-color: var(--card-color);
    border-radius: 12px; /* ×”×’×“×œ× ×• ××ª ×¢×™×’×•×œ ×”×¤×™× ×•×ª ×-8px ×œ-12px */
    text-align: center;
    z-index: 100;
    max-width: 90%; /* ×”×’×“×œ× ×• ××ª ×”×¨×•×—×‘ ×”××§×¡×™××œ×™ ×-80% ×œ-90% */
    min-width: 350px; /* ×”×•×¡×¤× ×• ×¨×•×—×‘ ××™× ×™××œ×™ ×—×“×© */
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.2); /* ×”×’×“×œ× ×• ××ª ×”×¦×œ */
    line-height: 1.7; /* ×”×’×“×œ× ×• ××ª ×”××¨×•×•×— ×‘×™×Ÿ ×”×©×•×¨×•×ª ×-1.6 ×œ-1.7 */
    font-size: 18px; /* ×”×•×¡×¤× ×• ×’×•×“×œ ×˜×§×¡×˜ ×’×“×•×œ ×™×•×ª×¨ */
}

.tutorial-screen {
    animation: fade-in 0.5s ease;
}

.next-btn {
    margin-top: 25px; /* ×”×’×“×œ× ×• ×-15px ×œ-25px */
    padding: 12px 30px; /* ×”×’×“×œ× ×• ×-8px 20px ×œ-12px 30px */
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 6px; /* ×”×’×“×œ× ×• ×-4px ×œ-6px */
    cursor: pointer;
    font-size: 18px; /* ×”×’×“×œ× ×• ×-16px ×œ-18px */
    font-weight: 600;
    transition: background-color 0.3s, transform 0.1s;
    min-width: 140px; /* ×”×•×¡×¤× ×• ×¨×•×—×‘ ××™× ×™××œ×™ */
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1); /* ×”×•×¡×¤× ×• ×¦×œ */
}

/* ×¡×’× ×•×Ÿ × ×¤×¨×“ ×œ×›×¤×ª×•×¨ "×”×ª×—×œ" */
#start-btn {
    padding: 14px 35px; /* ×”×’×“×œ× ×• ××ª ×”×¤×“×™× ×’ */
    font-size: 20px; /* ×”×’×“×œ× ×• ××ª ×’×•×“×œ ×”×˜×§×¡×˜ */
    min-width: 160px; /* ×”×’×“×œ× ×• ××ª ×”×¨×•×—×‘ ×”××™× ×™××œ×™ */
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15); /* ×¦×œ ×—×–×§ ×™×•×ª×¨ */
}

.next-btn:hover {
    background-color: #1e5180;
    transform: translateY(-3px); /* ×”×’×“×œ× ×• ××¤×§×˜ ×”×¨×™×—×•×£ ×-2px ×œ-3px */
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15); /* ×”×’×“×œ× ×• ××ª ×”×¦×œ ×‘×¨×™×—×•×£ */
}

.gender-buttons {
    display: flex;
    justify-content: center;
    gap: 20px;
    margin-top: 25px;
}

.gender-btn {
    padding: 12px 30px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 6px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: background-color 0.3s, transform 0.1s;
    min-width: 140px;
    box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
}

.gender-btn:hover {
    background-color: #1e5180;
    transform: translateY(-3px);
    box-shadow: 0 5px 10px rgba(0, 0, 0, 0.15);
}

@keyframes fade-in {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}
        
.dialog-box {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--card-color);
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 25px;
    text-align: center;
    z-index: 100;
    display: none;
    width: 80%;
    max-width: 450px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
    line-height: 1.6;
    animation: dialog-appear 0.3s ease-out forwards;
    font-family: 'Rubik', sans-serif;
    direction: rtl;
}

/* ×”×’×“×¨×ª ×™×™×©×•×¨ ×œ×›×•×ª×¨×•×ª ×‘×“×™××œ×•×’×™× */
.dialog-box h3 {
    text-align: center;
}

/* ×”×’×“×¨×ª ×™×™×©×•×¨ ×œ×˜×§×¡×˜ ×‘×“×™××œ×•×’×™× */
.dialog-box p {
    text-align: right;
}
        
@keyframes dialog-appear {
    from {
        opacity: 0;
        transform: translate(-50%, -40%) scale(0.9);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
}
        
        .dialog-box h3 {
    margin-top: 0;
    color: var(--primary-color);
    font-weight: 700;
    font-size: 22px;
    margin-bottom: 18px;
}

.dialog-box p {
    margin: 16px 0;
    font-size: 18px;
    line-height: 1.6;
}
        
.dialog-box button {
    margin: 12px 8px;
    padding: 12px 24px;
    background-color: var(--primary-color);
    color: white;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-size: 18px;
    font-weight: 600;
    transition: background-color 0.3s, transform 0.15s, box-shadow 0.3s;
    min-width: 120px;
    box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
}

.dialog-box button:hover {
    background-color: #1e5180;
    transform: translateY(-3px);
    box-shadow: 0 6px 12px rgba(42, 100, 150, 0.2);
}

/* ×”×¡×¨×ª ×¡×’× ×•× ×•×ª ×©×•× ×™× ×œ×›×¤×ª×•×¨×™ '×œ×' */
/* 
.dialog-box button.no-btn {
    background-color: var(--danger-color);
}

.dialog-box button.no-btn:hover {
    background-color: #c04848;
}
*/

/* ××™×›×œ ×œ×›×¤×ª×•×¨×™× ×‘×“×™××œ×•×’×™× - ×”×•×¡×£ ×–××ª ×›×”×’×“×¨×” ×—×“×©×” */
.dialog-buttons {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-top: 20px;
}

/* ×”×ª×××•×ª ×œ××™×›×œ ×”×›×¤×ª×•×¨×™× ×‘××•×‘×™×™×œ */
@media (max-width: 768px) {
    .dialog-buttons {
        gap: 10px;
        margin-top: 15px;
    }
}
        
#obstacle-dialog {
    position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            animation: bounce-in 0.5s ease-out forwards;
        }
        
        @keyframes bounce-in {
            0% {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -48%);
            }
            100% {
                transform: translate(-50%, -50%);
            }
        }
        
        #obstacle-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #obstacle-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #obstacle-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }
        
        #ignore-btn, #accept-btn {
    background-color: var(--primary-color);
    color: white;
}

#ignore-btn:hover, #accept-btn:hover {
    background-color: #1e5180;
    transform: translateY(-2px);
}
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(50, 50, 50, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: fade-in 0.7s ease-out forwards;
        }
        
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #game-over h2,
        #win-screen h2 {
            font-size: 24px;
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        #game-over button,
        #win-screen button {
            margin-top: 25px;
            padding: 12px 28px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
        }
        
        #game-over button:hover,
        #win-screen button:hover {
            background-color: #1e5180;
            transform: translateY(-2px);
        }
        
        #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 100, 150, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: scale-in 0.6s ease-out forwards;
        }
        
        @keyframes scale-in {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .popup-message {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: rgba(50, 50, 50, 0.9);
            color: white;
            border-radius: 25px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 20;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .power-meter {
            position: absolute;
            bottom: 25px;
            left: 20px;
            width: 200px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            overflow: hidden;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .power-meter-fill {
            height: 100%;
            background-color: var(--success-color);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .status-effect {
            position: absolute;
            top: 50%;  /* Center vertically */
            left: 50%;  /* Center horizontally */
            transform: translate(-50%, 150px);  /* Adjust vertical position */
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
            margin: 0 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 15;
            animation: status-effect-appear 0.4s ease forwards;
        }
        
        @keyframes status-effect-appear {
            from {
                opacity: 0;
                transform: translate(-50%, 170px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 150px);
            }
        }
        
        #status-negative {
            background-color: rgba(212, 91, 91, 0.9);
        }
        
        #status-weight {
            background-color: rgba(211, 135, 62, 0.9);
        }
        
        #speed-indicator {
    position: absolute;
    bottom: 25px;
    right: 20px;
    padding: 8px 15px;
    background-color: rgba(50, 50, 50, 0.8);
    color: white;
    border-radius: 5px;
    font-size: 14px;
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
    transition: background-color 0.3s ease;
    display: none; /* ×”×¡×ª×¨×ª ×”××—×•×•×Ÿ ×”××§×•×¨×™ */
}
        
        #movement-instruction {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            display: none;
            z-index: 25;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 80%;
            animation: pulse 1.5s infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Health indicators in center */
        .health-bars {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            width: 260px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .health-bar {
            margin-bottom: 15px;
        }
        
        .health-bar .label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--secondary-color);
        }
        
        .health-bar .bar {
            width: 100%;
            height: 12px;
            background-color: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .health-bar .fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #physical-health-fill {
            background-color: var(--success-color);
        }
        
        #mental-health-fill {
            background-color: var(--primary-color);
        }
        
        .day-clock-container {
            margin-top: 15px;
            text-align: center;
        }
        
        #day-clock {
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            display: inline-block;
            margin-top: 5px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        #day-clock:hover {
            transform: scale(1.05);
        }
        
        .clock-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 18px;
        }
        .finance-tip {
    position: absolute;
    bottom: 25px;
    left: 50%;
    transform: translateX(-50%);
    padding: 10px 20px;
    background-color: rgba(42, 100, 150, 0.85);
    color: white;
    border-radius: 5px;
    font-size: 14px;
    max-width: 80%;
    text-align: center;
    line-height: 1.4;
    opacity: 0;
    transition: opacity 0.5s;
    z-index: 15;
    box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
}

/* ×¡×’× ×•×Ÿ ×œ×›×¤×ª×•×¨ ×”×—×¥ ×œ×”×ª×§×“××•×ª */
#forward-arrow-button {
    position: absolute;
    right: 30px;
    top: 70%; /* ×©×™× ×•×™ ×-50% ×œ-70% ×›×“×™ ×œ×”×•×¨×™×“ ××ª ×”×›×¤×ª×•×¨ ×œ××˜×” */
    transform: translateY(-50%);
    width: 65px; /* ×”×’×“×œ×ª ×”×›×¤×ª×•×¨ ××¢×˜ */
    height: 65px;
    cursor: pointer;
    z-index: 50;
    filter: drop-shadow(0 0 10px rgba(42, 100, 150, 0.8)); /* ×¦×œ ×—×–×§ ×™×•×ª×¨ */
    touch-action: manipulation;
    transition: transform 0.3s, filter 0.3s; /* ×”×•×¡×¤×ª ××¤×§×˜ ××¢×‘×¨ ×—×œ×§ */
    display: none; /* ×”×¡×ª×¨×ª ×›×¤×ª×•×¨ ×”×—×¥ ×‘×ª×—×™×œ×ª ×”××©×—×§ */
    user-select: none; /* ×× ×™×¢×ª ×‘×—×™×¨×ª ×˜×§×¡×˜ */
    -webkit-user-select: none; /* ×¢×‘×•×¨ ×¡×¤××¨×™ */
    -moz-user-select: none; /* ×¢×‘×•×¨ ×¤×™×™×¨×¤×•×§×¡ */
    -ms-user-select: none; /* ×¢×‘×•×¨ ××§×¡×¤×œ×•×¨×¨/××“×’' */
}

/* ×× ×™××¦×™×” ××•×©×›×ª ×™×•×ª×¨ ×œ×›×¤×ª×•×¨ */
@keyframes pulse-attention {
    0% { transform: translateY(-50%) scale(1); filter: drop-shadow(0 0 10px rgba(42, 100, 150, 0.8)); }
    50% { transform: translateY(-50%) scale(1.15); filter: drop-shadow(0 0 15px rgba(255, 215, 0, 0.8)); }
    100% { transform: translateY(-50%) scale(1); filter: drop-shadow(0 0 10px rgba(42, 100, 150, 0.8)); }
}

/* ×× ×™××¦×™×” ×—×“×©×” ×¢×‘×•×¨ ×¤×¢×•×œ×ª "×œ×—×¥ ×•×”×—×–×§" */
@keyframes press-and-hold {
    0% { transform: translateY(-50%) scale(1); }
    50% { transform: translateY(-50%) scale(0.92); }
    100% { transform: translateY(-50%) scale(1); }
}

/* ×›××©×¨ ×”×›×¤×ª×•×¨ × ×œ×—×¥ */
#forward-arrow-button:active {
    animation: press-and-hold 2s infinite;
}

/* ×× ×™××¦×™×” ×—×“×©×” ×©×ª×•×¤×¢×œ ×›××©×¨ ×”×©×—×§×Ÿ ×œ× ×–×– */
.attention-needed {
    animation: pulse-attention 1.5s infinite;
}

/* ×¢×™×¦×•×‘ ×—×“×© ×œ×›×¤×ª×•×¨ ×¢×¦××• */
#forward-arrow-button svg {
    width: 100%;
    height: 100%;
}

#forward-arrow-button circle {
    fill: rgba(42, 100, 150, 0.9); /* ×¨×§×¢ ×›×”×” ×™×•×ª×¨ */
    stroke: rgba(255, 255, 255, 0.7); /* ×”×•×¡×¤×ª ×§×• ××ª××¨ */
    stroke-width: 2px;
}

#forward-arrow-button path {
    fill: white;
    transform: scale(1.2); /* ×”×’×“×œ×ª ×”×—×¥ ×¢×¦××• */
}

@media (max-width: 768px) {
    #forward-arrow-button {
        right: 20px;
        width: 70px;
        height: 70px;
    }
}

#powerup-dialog {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background-color: var(--card-color);
    border: 1px solid #dee2e6;
    border-radius: 8px;
    padding: 25px;
    text-align: center;
    z-index: 100;
    display: none;
    width: 80%;
    max-width: 450px;
    box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
    animation: slide-in 0.4s ease forwards;
}
        
        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #powerup-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #powerup-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #powerup-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 80px;
        }
        
        #powerup-yes-btn, #powerup-no-btn {
    background-color: var(--primary-color);
    color: white;
}

#powerup-yes-btn:hover, #powerup-no-btn:hover {
    background-color: #1e5180;
    transform: translateY(-2px);
}
        
        /* Sun and Moon */
        #sun {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #FFD700 40%, rgba(255, 215, 0, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            z-index: 5;
            opacity: 1;
            transition: all 2s ease;
        }
        
        #moon {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #E6E6FA 40%, rgba(230, 230, 250, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(230, 230, 250, 0.5);
            z-index: 5;
            opacity: 0;
            transition: all 2s ease;
        }
        
        /* Moon shadow effect */
        #moon::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            width: 45px;
            height: 45px;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.1) 40%, rgba(0, 0, 0, 0) 70%);
            border-radius: 50%;
        }
        
        /* Stars in night sky */
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 2s ease;
            animation: twinkle 3s infinite alternate;
            z-index: 4;
        }
        
        @keyframes twinkle {
            from { opacity: 0.2; }
            to { opacity: 0.8; }
        }
        
        /* Weather effects */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            z-index: 6;
            transition: all 1s ease;
            opacity: 0;
        }
        
        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
        }
        
        .bird {
            position: absolute;
            z-index: 6;
            transition: all 0.5s ease;
            opacity: 0;
        }
        
        /* Day/Night cycle overlay */
        #day-night-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 30, 0);
            z-index: 3;
            pointer-events: none;
            transition: background-color 2s ease;
        }
        
        @media (max-width: 768px) {
    .game-display {
        font-size: 14px;
        padding: 8px 12px;
    }
    
    .dialog-box {
        width: 90%;
        max-width: 420px;
        padding: 25px;
    }
    
    .dialog-box h3 {
        font-size: 20px;
        margin-bottom: 15px;
    }
    
    .dialog-box p {
        font-size: 16px;
        line-height: 1.5;
        margin: 12px 0;
    }
    
    .dialog-box button {
        padding: 10px 20px;
        font-size: 16px;
        margin: 10px 6px;
        min-width: 110px;
    }
    
    #tutorial-message {
        font-size: 16px; /* ×”×’×“×œ× ×• ×-14px ×œ-16px */
        max-width: 95%;
        padding: 25px; /* ×”×’×“×œ× ×• ×-20px ×œ-25px */
        min-width: 300px; /* ×”×•×¡×¤× ×• ×¨×•×—×‘ ××™× ×™××œ×™ */
    }
    
    .tutorial-screen h3 {
        font-size: 20px; /* ×”×’×“×œ× ×• ×-18px ×œ-20px */
    }
    
    .tutorial-screen p {
        font-size: 16px; /* ×”×’×“×œ× ×• ×-14px ×œ-16px */
    }
    
    .next-btn {
        padding: 10px 20px; /* ×”×’×“×œ× ×• ×-8px 16px ×œ-10px 20px */
        font-size: 16px; /* ×”×’×“×œ× ×• ×-14px ×œ-16px */
        min-width: 120px; /* ×”×•×¡×¤× ×• ×¨×•×—×‘ ××™× ×™××œ×™ */
    }
    
    .power-meter {
        width: 150px;
        height: 10px;
    }
    
    #obstacle-dialog {
        width: 90%;
        max-width: 400px;
        padding: 20px;
    }
    
    #obstacle-dialog p {
        font-size: 14px;
    }
    
    .health-bars {
        width: 220px;
        padding: 12px;
        top: 100px;
    }
    
    .finance-tip {
        font-size: 12px;
        padding: 8px 16px;
    }
    
    #day-clock {
        font-size: 20px;
        padding: 4px 12px;
    }
    
    #sun, #moon {
        width: 40px;
        height: 40px;
        right: 60px;
        top: 40px;
    }
    
    /* ×”×•×¡×¤×ª ×”×’×“×¨×•×ª ×¢×‘×•×¨ ××§×˜×¢ ×”×©×¢×•×Ÿ ×•××—×•×•×Ÿ ×”×§×¦×‘ ×‘××•×‘×™×™×œ */
    .clock-section {
        flex-direction: row; /* ×ª××™×“ ×œ×”×¦×™×’ ×‘×××•×–×Ÿ */
        justify-content: space-between;
        gap: 5px; /* ××¨×•×•×— ×§×˜×Ÿ ×™×•×ª×¨ ×‘××•×‘×™×™×œ */
    }
    
    .speed-indicator-container {
        margin-right: 0;
    }
    
    /* ×”×§×˜× ×ª ×’×•×“×œ ×”×˜×§×¡×˜ ×‘××•×‘×™×™×œ */
    .clock-section .label {
        font-size: 12px;
    }
}
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <!-- Day/Night cycle overlay -->
        <div id="day-night-overlay"></div>
        
        <!-- Sun and Moon -->
        <div id="sun"></div>
        <div id="moon"></div>
        
        <div id="date-display" class="game-display">××¨×¥ 2025</div>
        
        <!-- ×ª×™×‘×ª ×œ×•×— ×”××—×•×•× ×™× ×”×××•×—×“×ª -->
        <div class="dashboard-container">
            <!-- ×›×•×ª×¨×ª ×”×œ×•×— -->
            <div class="dashboard-header">
                <div id="score-display">×¡×š × ×›×¡×™× ×¤×™× × ×¡×™×™×: <span id="score-value">0</span> ×©"×—</div>
            </div>
            
            <div class="dashboard-content">
                <!-- ××™×“×¢ ×¤×™× × ×¡×™ -->
<div class="dashboard-section finance-section">
    <div class="section-title">××™×“×¢ ×¤×™× × ×¡×™</div>
    <div class="finance-info">
        <div class="finance-row">
            <div class="finance-col">
                <div>× ×›×¡×™× ×¤×™× × ×¡×™×™×: <span id="assets">0</span> ×©"×—</div>
            </div>
            <div class="finance-col">
                <div>×”×•×¦××•×ª ×—×•×“×©×™×•×ª: <span id="expenses">0</span> ×©"×—</div>
                <div>×”×›× ×¡×” ×—×•×“×©×™×ª: <span id="income">5,000</span> ×©"×—</div>
            </div>
        </div>
    </div>
</div>
                
                <!-- ××™×“×¢ ×‘×¨×™××•×ª×™ -->
                <div class="dashboard-section health-section">
                    <div class="section-title">×‘×¨×™××•×ª</div>
                    <div class="health-info">
                        <div class="health-bar">
                            <div class="label">×¤×™×–×™×ª</div>
                            <div class="bar">
                                <div id="physical-health-fill" class="fill" style="width: 100%;"></div>
                            </div>
                        </div>
                        <div class="health-bar">
                            <div class="label">×× ×˜×œ×™×ª</div>
                            <div class="bar">
                                <div id="mental-health-fill" class="fill" style="width: 100%;"></div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- ×©×¢×•×Ÿ ×™×•××™ ×•×§×¦×‘ ×”×ª×§×“××•×ª -->
<div class="dashboard-section clock-section">
    <div class="day-clock-container">
        <div class="label">×™××™× ×©× ×•×ª×¨×• <span class="clock-icon">ğŸ“…</span></div>
        <div id="day-clock">30</div>
    </div>
    <div class="speed-indicator-container">
        <div class="label">×§×¦×‘ ×”×ª×§×“××•×ª</div>
        <div id="dashboard-speed-indicator">××•×¤×˜×™××œ×™×ª</div>
    </div>
</div>
            </div>
        </div>
        
        <div id="power-meter" class="power-meter">
            <div id="power-meter-fill" class="power-meter-fill"></div>
        </div>
        
        <div id="popup-message" class="popup-message"></div>
        <div id="finance-tip" class="finance-tip"></div>
        
        <div id="status-negative" class="status-effect">×”×©×¤×¢×” ×× ×˜×œ×™×ª: ×—×œ×©</div>
<div id="status-weight" class="status-effect">××¦×‘ ×’×•×¤× ×™: ×›×‘×“</div>
<div id="speed-indicator">××”×™×¨×•×ª: ×¨×’×™×œ×”</div>

<!-- ×›×¤×ª×•×¨ ×”×ª×§×“××•×ª -->
<div id="forward-arrow-button">
    <svg width="65" height="65" viewBox="0 0 65 65">
        <circle cx="32.5" cy="32.5" r="30" fill="rgba(42, 100, 150, 0.9)" stroke="rgba(255, 255, 255, 0.7)" stroke-width="2" />
        <text x="32.5" y="28" fill="rgba(255, 255, 255, 0.9)" font-size="11" text-anchor="middle" dominant-baseline="middle" style="pointer-events: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;">×œ×—×¥</text>
<text x="32.5" y="40" fill="rgba(255, 255, 255, 0.9)" font-size="10" text-anchor="middle" dominant-baseline="middle" style="pointer-events: none; user-select: none; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none;">×•×”×—×–×§</text>
    </svg>
</div>

<!-- ×“×™××œ×•×’ ×”×¤××•×•×¨-××¤×™× -->
<div id="powerup-dialog" class="dialog-box">
    <h3 id="powerup-title">âš¡ × ×ª×§×œ×ª ×‘×”×–×“×× ×•×ª ×œ×©×™×¤×•×¨!</h3>
    <p id="powerup-text">×”×× ×¢×©×™×ª ××™××•×Ÿ ×›×‘×¨ ×”×™×•×?</p>
    <div class="dialog-buttons">
        <button id="powerup-yes-btn">×›×Ÿ</button>
        <button id="powerup-no-btn">×œ×</button>
    </div>
</div>
        
<!-- ×“×™××œ×•×’ ×”××›×©×•×œ -->
<div id="obstacle-dialog" class="dialog-box">
    <h3 id="obstacle-title">âš–ï¸ ×”×ª××•×“×“×•×ª ×¢× ×“×™×œ××” ×¤×™× × ×¡×™×ª</h3>
    <p id="obstacle-text">×”×× ×œ×‘×—×•×¨ ×‘×”×•×¦××” ××™×™×“×™×ª ××• ×œ×”××©×™×š ×‘×ª×•×›× ×™×ª ×”×—×™×¡×›×•×Ÿ?</p>
    <div class="dialog-buttons">
        <button id="ignore-btn">×¡×™×¨×•×‘</button>
        <button id="accept-btn">×”×¡×›××”</button>
    </div>
</div>
        
<div id="tutorial-message">
    <!-- ×‘×›×œ ×¤×¢× ×™×•×¦×’ ×¨×§ ××—×“ ××”××¡×›×™× ×”×‘××™× -->
    <div class="tutorial-screen" id="tutorial-screen-1">
        <h3>ğŸ® ×‘×¨×•×›×™× ×”×‘××™× ×œ××©×—×§ ×”××©××¢×ª ×”×¤×™× × ×¡×™×ª</h3>
        <button class="next-btn">×”×‘×</button>
    </div>
    
    <div class="tutorial-screen" id="tutorial-screen-2" style="display: none;">
        <h3>××” ×”××™×Ÿ ×©×œ×š?</h3>
        <div class="gender-buttons">
            <button class="gender-btn" id="male-btn">×’×‘×¨</button>
            <button class="gender-btn" id="female-btn">××™×©×”</button>
        </div>
    </div>
    
    <div class="tutorial-screen" id="tutorial-screen-3" style="display: none;">
        <p>ğŸ¯ ×”××˜×¨×” ×©×œ×š ×”×™× ×œ×¦×‘×•×¨ 100,000 ×©"×— ×‘×××¦×¢×•×ª ×”×ª××“×” ×•×”×—×œ×˜×•×ª ×¤×™× × ×¡×™×•×ª ×—×›××•×ª.</p>
        <button class="next-btn">×”×‘×</button>
    </div>
            
            <div class="tutorial-screen" id="tutorial-screen-3" style="display: none;">
                <p>ğŸ‘‰ ×œ×—×¥ ×¢×œ ×›×¤×ª×•×¨ ×”×—×¥ ×©×‘×¦×“ ×™××™×Ÿ ×›×“×™ ×œ×”×ª×§×“× ×‘×“×¨×š ×”×¤×™× × ×¡×™×ª. ×›×›×œ ×©×ª×ª×§×“×, ×”×™××™× ×™×—×œ×¤×• ×•×‘×¡×•×£ ×”×—×•×“×© ×ª×§×‘×œ ××©×›×•×¨×ª.</p>
                <button class="next-btn">×”×‘×</button>
            </div>
            
            <div class="tutorial-screen" id="tutorial-screen-4" style="display: none;">
                <p>ğŸ’° ××ª×” ××¨×•×•×™×— 5,000 ×©"×— ×‘×—×•×“×© ××”×¢×‘×•×“×” ×”×™×¦×™×‘×” ×©×œ×š, ××š ×ª×™×ª×§×œ ×‘×“×™×œ××•×ª ×•×¤×™×ª×•×™×™× ×œ××•×¨×š ×”×“×¨×š.</p>
                <button class="next-btn">×”×‘×</button>
            </div>
            
            <div class="tutorial-screen" id="tutorial-screen-5" style="display: none;">
                <p>ğŸƒâ€â™‚ï¸ ×§×¦×‘ ×”×”×ª×§×“××•×ª ×©×œ×š ××•×©×¤×¢ ××”××¦×‘ ×”×¤×™×–×™ ×•×”×× ×˜×œ×™.</p>
                <button class="next-btn">×”×‘×</button>
            </div>
            
            <div class="tutorial-screen" id="tutorial-screen-6" style="display: none;">
                <p>ğŸ ×–×›×•×¨ - ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª ×”×™× ××¨×ª×•×Ÿ, ×œ× ×¡×¤×¨×™× ×˜. × ×“×¨×©×ª ××©××¢×ª ×•×”×ª××“×” ×œ××•×¨×š ×–××Ÿ.</p>
                <button id="start-btn">×”×ª×—×œ</button>
            </div>
        </div>
        
        <div id="job-offer" class="dialog-box">
            <h3>ğŸ’¼ ×”×–×“×× ×•×ª ×§×¨×™×™×¨×” ×—×“×©×”</h3>
            <p>×”×× ×œ×‘×—×•×¨ ×‘×§×¨×™×™×¨×” ×¢× ×©×›×¨ ×’×‘×•×” ×™×•×ª×¨ ××š ×¤×—×•×ª ×™×¦×™×‘×•×ª?</p>
            <div class="dialog-buttons">
                <button id="yes-btn">ğŸ‘ ×›×Ÿ</button>
                <button id="no-btn">ğŸ‘ ×œ×</button>
            </div>
        </div>
        
        <div id="job-offer-followup" class="dialog-box">
            <h3>ğŸ¤” ×©×§×•×œ ×©×•×‘ ××ª ×”×—×œ×˜×ª×š</h3>
            <p id="followup-text">×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×“×—×•×ª ×”×–×“×× ×•×ª ×–×•?</p>
            <div class="dialog-buttons">
                <button id="followup-yes-btn">ğŸ‘ ×›×Ÿ</button>
                <button id="followup-no-btn">ğŸ‘ ×œ×</button>
            </div>
        </div>
        
        <div id="game-over">
            <h2>ğŸ˜“ × ×™×”×•×œ ×¤×™× × ×¡×™ ×›×•×©×œ</h2>
            <p id="game-over-reason"></p>
            <p>ğŸ’¸ ×¦×‘×¨×ª ×¡×š ×©×œ <span id="final-score">0</span> ×©"×— ×‘× ×›×¡×™× ×¤×™× × ×¡×™×™×</p>
            <div id="game-stats">
                <p>ğŸ“… ×ª×§×•×¤×” ×©× ×•×”×œ×”: <span id="months-played">0</span> ×—×•×“×©×™×</p>
                <p>ğŸ’ª ×”×¨×’×œ×™× ×¤×™× × ×¡×™×™× ×—×™×•×‘×™×™×: <span id="powerups-collected">0</span></p>
                <p>ğŸ›¡ï¸ ×“×™×œ××•×ª ×¤×™× × ×¡×™×•×ª ×©× ×¤×ª×¨×•: <span id="obstacles-avoided">0</span></p>
            </div>
            <p class="lesson">ğŸ’¡ ×œ×§×—: ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª ×“×•×¨×©×ª ××©××¢×ª, ×ª×›× ×•×Ÿ ××¨×•×š ×˜×•×•×— ×•×”×—×œ×˜×•×ª ××•×©×›×œ×•×ª.</p>
            <button id="restart-btn">ğŸ”„ × ×™×¡×™×•×Ÿ ×—×“×©</button>
        </div>
        
        <div id="win-screen">
            <h2>ğŸ† ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª ×”×•×©×’×”!</h2>
            <p>ğŸ‰ ×”×¦×œ×—×ª ×œ×¦×‘×•×¨ 100,000 ×©"×— ×‘× ×›×¡×™× ×¤×™× × ×¡×™×™×!</p>
            <p>ğŸ‘ ×›×œ ×”×›×‘×•×“ ×¢×œ ×”××©××¢×ª ×”×¢×¦××™×ª, ×”×”×ª××“×” ×•×§×‘×œ×ª ×”×”×—×œ×˜×•×ª ×”× ×›×•× ×•×ª.</p>
            <div id="win-stats">
                <p>â±ï¸ ×ª×§×•×¤×ª ×¦×‘×™×¨×ª ×”× ×›×¡×™×: <span id="win-months">0</span> ×—×•×“×©×™×</p>
                <p>ğŸ’ª ×”×¨×’×œ×™× ×¤×™× × ×¡×™×™× ×—×™×•×‘×™×™×: <span id="win-powerups">0</span></p>
                <p>ğŸ›¡ï¸ ×“×™×œ××•×ª ×¤×™× × ×¡×™×•×ª ×©× ×¤×ª×¨×•: <span id="win-obstacles">0</span></p>
            </div>
            <p class="lesson">ğŸ’¡ ×–×›×•×¨: ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª ×”×™× ×ª×”×œ×™×š ××ª××©×š ×”×“×•×¨×© ×”×ª××“×” ×•×”×—×œ×˜×•×ª ××•×©×›×œ×•×ª.</p>
            <button id="play-again-btn">ğŸ”„ × ×™×¡×™×•×Ÿ × ×•×¡×£</button>
        </div>
    </div>
    <script>
        
        // Canvas and context setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to cover the window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game variables
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let currentMonth = 0;
        let tutorialShown = true;
        let isMoving = false; // Movement control
        let moveTimer = null; // For instruction display timing
        let financeMessageTimer = null; // For finance tips display
        
        // Day/Night cycle variables
        let currentHour = 5; // Starting at 5:00 AM
        let currentMinute = 0;
        let dayProgress = 0; // 0 to 1 for day cycle
        let isDayTime = true;
        let timeMultiplier = 2.4; // 2.4 hours per real second (24h in 10 seconds)
        let lastTimeUpdate = Date.now();
        let stars = [];
        let clouds = [];
        let birds = [];

        // ××©×ª× ×™ ×™×•× - ×™×××” = 10 ×©× ×™×•×ª ×‘××¦×‘ ××•×¤×˜×™××œ×™
const dayMilliseconds = {
    perfect: 10000, // 10 ×©× ×™×•×ª ×œ×™×××” ×‘××¦×‘ ××•×¤×˜×™××œ×™
    current: 10000   // ×™×›×•×œ ×œ×”×©×ª× ×•×ª ×‘×”×ª×× ×œ×‘×¨×™××•×ª
};
        
        // Create stars
        function createStars() {
            stars = [];
            const starCount = Math.min(50, Math.floor(window.innerWidth * window.innerHeight / 10000)); // Adjust based on screen size
            
            for (let i = 0; i < starCount; i++) {
                const star = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * 0.7), // Only in the sky area
                    size: Math.random() * 2 + 1, // 1-3px
                    twinkleSpeed: Math.random() * 2 + 1 // Variation in twinkle speed
                };
                stars.push(star);
            }
        }
        
        // Create clouds
        function createClouds() {
            clouds = [];
            const cloudCount = Math.min(5, Math.floor(window.innerWidth / 400)); // Adjust based on screen width
            
            for (let i = 0; i < cloudCount; i++) {
                createCloud();
            }
        }
        
        // Create a single cloud
        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            // Random cloud size and position
            const size = Math.random() * 40 + 60; // 60-100px
            const top = Math.random() * (canvas.height * 0.3) + 50; // Top half of sky
            const left = Math.random() * canvas.width;
            
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size / 2}px`;
            cloud.style.top = `${top}px`;
            cloud.style.left = `${left}px`;
            
            // Create cloud shape with pseudo-elements
            cloud.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3)';
            
            // Speed will determine how fast the cloud moves across the screen
            const speed = Math.random() * 0.05 + 0.01; // pixels per millisecond
            cloud.dataset.speed = speed;
            cloud.dataset.position = left;
            
            document.getElementById('game-container').appendChild(cloud);
            clouds.push(cloud);
            
            // Set initial opacity based on time of day
            updateCloudVisibility();
        }
        
        // Create birds
        function createBirds() {
            birds = [];
            const birdCount = Math.min(3, Math.floor(window.innerWidth / 500)); // Adjust based on screen width
            
            for (let i = 0; i < birdCount; i++) {
                if (Math.random() < 0.7) { // 70% chance to create a bird
                    createBird();
                }
            }
        }
        
        // Create a single bird
        function createBird() {
            const bird = document.createElement('div');
            bird.className = 'bird';
            
            // Create SVG for bird
            const birdSize = Math.random() * 10 + 15; // 15-25px
            bird.innerHTML = `
                <svg width="${birdSize}" height="${birdSize}" viewBox="0 0 100 100">
                    <path d="M10,50 Q30,30 50,50 Q70,30 90,50" stroke="#333" fill="transparent" stroke-width="5"/>
                </svg>
            `;
            
            // Random position
            const top = Math.random() * (canvas.height * 0.4) + 50; // Upper half of sky
            const left = -birdSize;
            
            bird.style.top = `${top}px`;
            bird.style.left = `${left}px`;
            
            // Speed will determine how fast the bird moves across the screen
            const speed = Math.random() * 0.08 + 0.05; // pixels per millisecond
            bird.dataset.speed = speed;
            bird.dataset.position = left;
            
            document.getElementById('game-container').appendChild(bird);
            birds.push(bird);
            
            // Only show birds during the day
            bird.style.opacity = isDayTime ? '1' : '0';
        }
        
        // Update clouds position
        function updateClouds(deltaTime) {
            clouds.forEach((cloud, index) => {
                let position = parseFloat(cloud.dataset.position);
                const speed = parseFloat(cloud.dataset.speed);
                
                position += speed * deltaTime;
                
                // Reset cloud when it goes off screen
                if (position > canvas.width + parseFloat(cloud.style.width)) {
                    position = -parseFloat(cloud.style.width);
                }
                
                cloud.dataset.position = position;
                cloud.style.left = `${position}px`;
            });
        }
        
        // Update birds position
        function updateBirds(deltaTime) {
            birds.forEach((bird, index) => {
                let position = parseFloat(bird.dataset.position);
                const speed = parseFloat(bird.dataset.speed);
                
                position += speed * deltaTime;
                
                // Remove bird when it goes off screen
                if (position > canvas.width + 50) {
                    document.getElementById('game-container').removeChild(bird);
                    birds.splice(index, 1);
                    
                    // Maybe create a new bird
                    if (Math.random() < 0.3 && isDayTime) {
                        setTimeout(createBird, Math.random() * 5000 + 2000);
                    }
                } else {
                    bird.dataset.position = position;
                    bird.style.left = `${position}px`;
                    
                    // Make bird flap by changing the SVG occasionally
                    if (Math.random() < 0.05) {
                        const path = bird.querySelector('path');
                        if (path) {
                            const flap = Math.random() < 0.5 ? 
                                "M10,50 Q30,20 50,50 Q70,20 90,50" : 
                                "M10,50 Q30,40 50,50 Q70,40 90,50";
                            path.setAttribute('d', flap);
                        }
                    }
                }
            });
            
            // Occasionally add new birds during the day
            if (birds.length < 3 && Math.random() < 0.001 && isDayTime) {
                createBird();
            }
        }
        
        // Update cloud visibility based on time of day
        function updateCloudVisibility() {
            const cloudOpacity = isDayTime ? 0.8 : 0.3; // Less visible at night
            
            clouds.forEach(cloud => {
                cloud.style.opacity = cloudOpacity;
                // Change cloud color for night
                if (isDayTime) {
                    cloud.style.background = "rgba(255, 255, 255, 0.7)";
                } else {
                    cloud.style.background = "rgba(200, 200, 220, 0.5)";
                }
            });
        }
        
        // Update birds visibility based on time of day
        function updateBirdsVisibility() {
            birds.forEach(bird => {
                // Birds only appear during day
                bird.style.opacity = isDayTime ? '1' : '0';
                
                // Remove birds at night
                if (!isDayTime) {
                    setTimeout(() => {
                        if (birds.includes(bird)) {
                            document.getElementById('game-container').removeChild(bird);
                            birds.splice(birds.indexOf(bird), 1);
                        }
                    }, 2000);
                }
            });
        }
        
        // Update day/night cycle
function updateDayNightCycle() {
    // ×‘×“×™×§×” ××§×™×¤×” ×™×•×ª×¨ ×©×œ ××¦×‘ ×”××©×—×§
    if (!gameRunning || gamePaused) {
        return;
    }
    
    // ×‘×“×™×§×” ×× ×”×©×—×§×Ÿ ×–×– - ×× ×œ×, ××™×Ÿ ×”×ª×§×“××•×ª ×‘×–××Ÿ
    if (!isMoving) {
        // ×¢×“×™×™×Ÿ × ×¢×“×›×Ÿ ××ª ×ª×¦×•×’×ª ×”×™××™× ×’× ×× ×”×©×—×§×Ÿ ×œ× ×–×–
        updateClockDisplay();
        return;
    }
    
    // ×‘×“×™×§×” ××•×¨×—×‘×ª ×©×œ lastTimeUpdate
    if (!lastTimeUpdate || isNaN(lastTimeUpdate)) {
        console.log("Resetting lastTimeUpdate");
        lastTimeUpdate = Date.now();
        return;
    }

    const now = Date.now();
    const deltaTime = now - lastTimeUpdate;
    
    // ×‘×“×™×§×” ××—××™×¨×” ×™×•×ª×¨ ×©×œ deltaTime
    if (deltaTime <= 0 || deltaTime > 1000) {
        console.log(`Invalid deltaTime: ${deltaTime}ms, resetting timer`);
        lastTimeUpdate = now;
        return;
    }
    
    lastTimeUpdate = now; // ×¢×“×›×•×Ÿ ×”×–××Ÿ ×”××—×¨×•×Ÿ ××—×¨×™ ×”×‘×“×™×§×•×ª

    try {
        // ×‘×“×™×§×ª ×ª×§×™× ×•×ª ×©×œ dayMilliseconds
        if (!dayMilliseconds || !dayMilliseconds.current || dayMilliseconds.current <= 0) {
            console.error("Invalid dayMilliseconds:", dayMilliseconds);
            return;
        }

        // ×—×™×©×•×‘ ×–××Ÿ ×‘×”×ª×× ×œ××”×™×¨×•×ª ×”×™×•× ×”× ×•×›×—×™×ª
        const secondsElapsed = deltaTime / 1000;
        const totalDayTimeInSeconds = dayMilliseconds.current / 1000;
        const hoursElapsed = secondsElapsed * (24 / totalDayTimeInSeconds);

        // ×‘×“×™×§×” ××•×¨×—×‘×ª ×©×œ ×ª×§×™× ×•×ª ×”×—×™×©×•×‘
        if (isNaN(hoursElapsed) || !isFinite(hoursElapsed) || hoursElapsed < 0) {
            console.error("Invalid hoursElapsed calculation:", {
                secondsElapsed,
                totalDayTimeInSeconds,
                hoursElapsed
            });
            return;
        }

        // Update minutes first
        currentMinute += hoursElapsed * 60;

        // If minutes exceed 60, increment hour
        while (currentMinute >= 60) {
            currentMinute -= 60;
            currentHour++;

            // Reset hour after 24
            if (currentHour >= 24) {
                currentHour = 0;
                // ×”×•×¨×“×ª 5% ××”×‘×¨×™××•×ª ×”×¤×™×–×™×ª ×•×”×× ×˜×œ×™×ª ×‘×¡×•×£ ×›×œ ×™×××”
                decreaseHealthPerDay();
            }

            // Check for day/night transition
            if (currentHour === 18) {
                transitionToNight();
            } else if (currentHour === 5) {
                transitionToDay();
            }
        }

        // Format days remaining display
        updateClockDisplay();
        
        // Update day progress (0-1 for full day)
        dayProgress = (currentHour + (currentMinute / 60)) / 24;

        // Update sky color based on time
        updateSkyColor();
        
        // Update sun/moon position
        updateCelestialBodies();
        
        // Update environment elements
        updateClouds(deltaTime);
        updateBirds(deltaTime);
    } catch (error) {
        console.error("Error in updateDayNightCycle:", error, {
            currentHour,
            currentMinute,
            dayProgress,
            deltaTime
        });
    }
}

// ×¢×¨×›×™× ×œ×©××™×¨×ª ××¦×‘ ×”×‘×¨×™××•×ª ×”×§×•×“×
let lastPhysicalHealthTier = 100;
let lastMentalHealthTier = 100;

// ×¤×•× ×§×¦×™×” ×œ×”×•×¨×“×ª ×”×‘×¨×™××•×ª ×”×¤×™×–×™×ª ×•×”×× ×˜×œ×™×ª ×‘×›×œ ×™×××”
function decreaseHealthPerDay() {
    // ×©××•×¨ ××ª ×”×¢×¨×›×™× ×”× ×•×›×—×™×™× ×œ×¤× ×™ ×”×©×™× ×•×™
    const prevPhysical = stats.physicalHealth;
    const prevMental = stats.mentalHealth;
    
    // ×”×•×¨×“×ª 5% ××”×‘×¨×™××•×ª ×”×¤×™×–×™×ª ×•×”×× ×˜×œ×™×ª
    stats.physicalHealth = Math.max(0, stats.physicalHealth - 5);
    stats.mentalHealth = Math.max(0, stats.mentalHealth - 5);
    
    // ×¢×“×›×•×Ÿ ××¦×‘ ×”×©×—×§×Ÿ ×‘×”×ª×× ×œ×©×™× ×•×™×™× ×‘×‘×¨×™××•×ª
    updatePlayerCondition();
    
    // ×‘×“×•×§ ×× ×”×‘×¨×™××•×ª ×™×¨×“×” ××ª×—×ª ×œ×¡×£ ××©××¢×•×ª×™ (80%, 60%, 40%, 20%)
    // ×•×¨×§ ××– ×”×¦×’ ×”×•×“×¢×”
    const checkHealthTier = (value) => {
        if (value <= 20) return 1;
        if (value <= 40) return 2;
        if (value <= 60) return 3;
        if (value <= 80) return 4;
        return 5;
    };
    
    const newPhysicalTier = checkHealthTier(stats.physicalHealth);
    const newMentalTier = checkHealthTier(stats.mentalHealth);
    
    // ×”×¦×’ ×”×•×“×¢×” ×•×”×“×™××œ×•×’ ×¨×§ ×× ×™×¨×“ ×œ×¨××” ×—×“×©×” ×©×œ ×‘×¨×™××•×ª
    let physicalHealthDegraded = false;
    
    if (newPhysicalTier < checkHealthTier(prevPhysical) || newMentalTier < checkHealthTier(prevMental)) {
        let message = "";
        
        if (newPhysicalTier < checkHealthTier(prevPhysical) && newPhysicalTier <= 3) {
            message = "×”×‘×¨×™××•×ª ×”×¤×™×–×™×ª ×©×œ×š ××ª×“×¨×“×¨×ª. ××•××œ×¥ ×œ×¤×¢×•×œ ×œ×©×™×¤×•×¨!";
            physicalHealthDegraded = true;
        }
        
        if (newMentalTier < checkHealthTier(prevMental) && newMentalTier <= 3) {
            message = message ? "×”×‘×¨×™××•×ª ×©×œ×š ××ª×“×¨×“×¨×ª. ×©×™× ×œ×‘ ×œ×˜×¤×œ ×‘×¢×¦××š!" : 
                               "×”×‘×¨×™××•×ª ×”×× ×˜×œ×™×ª ×©×œ×š ××ª×“×¨×“×¨×ª. ××•××œ×¥ ×œ×¤×¢×•×œ ×œ×©×™×¤×•×¨!";
        }
        
        if (message) {
            showPopupMessage(message, 3000);
            
            // ×”×¦×’ ×ª×™×‘×ª ×“×•-×©×™×— ×œ×’×‘×™ ×‘×¨×™××•×ª ×¤×™×–×™×ª ×× ×”×™× ×–×• ×©×”×ª×“×¨×“×¨×”
            if (physicalHealthDegraded) {
                setTimeout(() => {
                    showHealthDialog();
                }, 3500); // ×”×¦×’ ××ª ×”×“×™××œ×•×’ ××—×¨×™ ×©×”×”×•×“×¢×” ×”×§×•×“××ª × ×¢×œ××ª
            }
        }
    }
}

// ×¤×•× ×§×¦×™×” ×œ×”×¦×’×ª ×ª×™×‘×ª ×“×•-×©×™×— ×œ×©×™×¤×•×¨ ×”×‘×¨×™××•×ª
function showHealthDialog() {
    // ×”×©×”×” ××ª ×”××©×—×§ ×‘×–××Ÿ ×”×¦×’×ª ×ª×™×‘×ª ×”×“×•-×©×™×—
    gamePaused = true;
    isMoving = false; // ×¢×¦×™×¨×ª ×”×ª× ×•×¢×” ×‘××•×¤×Ÿ ××•×—×œ×˜
    
    // ×™×¦×™×¨×ª ×©×›×‘×ª ×”××¤×œ×” ×××—×•×¨×™ ×”×“×™××œ×•×’
    const dialogOverlay = createDialogOverlay();
    
    // ×™×¦×™×¨×ª ×ª×™×‘×ª ×”×“×•-×©×™×—
    const healthDialog = document.createElement('div');
    healthDialog.className = 'dialog-box';
    healthDialog.id = 'health-dialog';
    healthDialog.style.zIndex = '100';
    
    // ×ª×•×›×Ÿ ×ª×™×‘×ª ×”×“×•-×©×™×—
    healthDialog.innerHTML = `
        <h3>ğŸ’ª ×‘×¨×™××•×ª ×•××™×–×•×Ÿ ×¤×™× × ×¡×™</h3>
        <p>×”×× ××ª×” ×“×•××’ ×œ×©××•×¨ ×¢×œ ×”×‘×¨×™××•×ª ×”×¤×™×–×™×ª ×©×œ×š?</p>
        <div class="dialog-buttons">
            <button id="health-priority-no">×§×•×“× ×›×œ × ×¢×©×” ×›×¡×£, ××—×¨×™ ×–×” × ×“××’ ×œ×‘×¨×™××•×ª</button>
            <button id="health-priority-yes">×‘×¨×™××•×ª ×•×›×¡×£ â€“ ×”×•×œ×›×•×ª ×‘×™×—×“</button>
        </div>
    `;
    
    // ×”×•×¡×¤×ª ×ª×™×‘×ª ×”×“×•-×©×™×— ×œ××©×—×§
    document.getElementById('game-container').appendChild(healthDialog);
    
    // ×”×•×¡×¤×ª ×××–×™× ×™ ××™×¨×•×¢×™× ×œ×›×¤×ª×•×¨×™ ×ª×™×‘×ª ×”×“×•-×©×™×—
    document.getElementById('health-priority-no').addEventListener('click', function() {
        // ×‘×—×™×¨×” ×‘××¤×©×¨×•×ª 1: ×œ× ×œ×©×¤×¨ ××ª ×”×‘×¨×™××•×ª
        closeHealthDialog(dialogOverlay, healthDialog);
        showPopupMessage("×”×—×œ×˜×ª ×œ×”×ª××§×“ ×‘×›×¡×£. ×”×‘×¨×™××•×ª ×©×œ×š ×œ× ×”×©×ª×¤×¨×”.", 3000);
    });
    
    document.getElementById('health-priority-yes').addEventListener('click', function() {
        // ×‘×—×™×¨×” ×‘××¤×©×¨×•×ª 2: ×œ×©×¤×¨ ××ª ×”×‘×¨×™××•×ª
        closeHealthDialog(dialogOverlay, healthDialog);
        
        // ×©×™×¤×•×¨ ×”×‘×¨×™××•×ª ×”×¤×™×–×™×ª ×‘-20%
        stats.physicalHealth = Math.min(100, stats.physicalHealth + 20);
        
        // ×¢×“×›×•×Ÿ ××¦×‘ ×”×©×—×§×Ÿ
        updatePlayerCondition();
        
        // ×”×¦×’×ª ×”×•×“×¢×” ×¢×œ ×©×™×¤×•×¨ ×”×‘×¨×™××•×ª
        showPopupMessage("×”×—×œ×˜×ª ×œ×©×œ×‘ ×‘×¨×™××•×ª ×•×›×¡×£. ×”×‘×¨×™××•×ª ×”×¤×™×–×™×ª ×©×œ×š ×”×©×ª×¤×¨×” ×‘-20%!", 3000);
        
        // ××¤×§×˜ ×•×™×–×•××œ×™ ×œ×©×™×¤×•×¨ ×‘×¨×™××•×ª
        showPhysicalBoostEffect();
    });
}

// ×¤×•× ×§×¦×™×” ×œ×¡×’×™×¨×ª ×ª×™×‘×ª ×”×“×•-×©×™×— ×©×œ ×”×‘×¨×™××•×ª
function closeHealthDialog(overlay, dialog) {
    // ×”×¡×¨×ª ×ª×™×‘×ª ×”×“×•-×©×™×— ×•×”×©×›×‘×” ×”×©×§×•×¤×”
    if (overlay && overlay.parentNode) {
        overlay.parentNode.removeChild(overlay);
    }
    
    if (dialog && dialog.parentNode) {
        dialog.parentNode.removeChild(dialog);
    }
    
    // ×”××©×š ×”××©×—×§
    gamePaused = false;
}

// Format and update days remaining display
function updateClockDisplay() {
    // ×—×™×©×•×‘ ×™××™× ×©× ×•×ª×¨×• ×¢×œ ×¤×™ ×”×ª×§×“××•×ª ×”×—×•×“×©
    const totalDaysInMonth = 30; // ××¡×¤×¨ ×§×‘×•×¢ ×©×œ ×™××™× ×‘×—×•×“×©
    const progress = currentMonthTimer / framesPerMonth; // ×”×ª×§×“××•×ª ×”×—×•×“×© (0-1)
    const daysElapsed = Math.floor(progress * totalDaysInMonth); // ××¡×¤×¨ ×™××™× ×©×¢×‘×¨×•
    const daysRemaining = totalDaysInMonth - daysElapsed; // ×™××™× ×©× ×•×ª×¨×•
    
    document.getElementById('day-clock').textContent = daysRemaining;
    
    // Visual effect on day change
    if (daysRemaining < (lastDaysRemaining || totalDaysInMonth)) {
        document.getElementById('day-clock').style.transform = 'scale(1.1)';
        setTimeout(() => {
            document.getElementById('day-clock').style.transform = 'scale(1)';
        }, 300);
        lastDaysRemaining = daysRemaining;
    }
}

// ××©×ª× ×” ×’×œ×•×‘×œ×™ ×œ×©××™×¨×ª ××¡×¤×¨ ×”×™××™× ×”××—×¨×•×Ÿ ×©×”×•×¦×’
let lastDaysRemaining = 30;
        
        // Update sky color based on time
        function updateSkyColor() {
            let skyColor;
            const hour = currentHour + (currentMinute / 60);
            
            // Day sky (6-17)
            if (hour >= 6 && hour < 17) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start');
            }
            // Sunset (17-19)
            else if (hour >= 17 && hour < 19) {
                const progress = (hour - 17) / 2; // 0-1 for sunset
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--sunset-sky-color-start'),
                    progress
                );
            }
            // Night (19-5)
            else if (hour >= 19 || hour < 5) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--night-sky-color-start');
            }
            // Sunrise (5-6)
            else {
                const progress = (hour - 5); // 0-1 for sunrise
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--sunrise-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    progress
                );
            }
            
            // Apply sky color in draw background
            ctx.fillStyle = skyColor;
        }
        
        // Helper for color mixing
        function mixColors(color1, color2, ratio) {
            color1 = color1.trim();
            color2 = color2.trim();
            
            // Simple mixing for hex or rgb colors
            if (color1.startsWith('#')) {
                // Convert hex to rgb
                const r1 = parseInt(color1.substr(1, 2), 16);
                const g1 = parseInt(color1.substr(3, 2), 16);
                const b1 = parseInt(color1.substr(5, 2), 16);
                
                const r2 = parseInt(color2.substr(1, 2), 16);
                const g2 = parseInt(color2.substr(3, 2), 16);
                const b2 = parseInt(color2.substr(5, 2), 16);
                
                const r = Math.round(r1 * (1 - ratio) + r2 * ratio);
                const g = Math.round(g1 * (1 - ratio) + g2 * ratio);
                const b = Math.round(b1 * (1 - ratio) + b2 * ratio);
                
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Assume rgb format
                return color1; // Simplified - would need regex for proper rgb mixing
            }
        }
        
        // Update sun and moon positions
        function updateCelestialBodies() {
            const sunElement = document.getElementById('sun');
            const moonElement = document.getElementById('moon');
            
            // Calculate positions - circular path in sky
            const skyWidth = canvas.width;
            const skyHeight = canvas.height * 0.6; // Top 60% is sky
            
            // Sun moves from left to right during day (5-19)
            if (currentHour >= 5 && currentHour < 19) {
                const sunProgress = (currentHour - 5) / 14; // 0-1 for sun path
                
                // Circular path for sun - moves in an arc
                const sunX = skyWidth * sunProgress;
                const sunY = skyHeight * 0.5 * Math.sin(Math.PI * sunProgress) + 50;
                
                sunElement.style.left = `${sunX}px`;
                sunElement.style.top = `${sunY}px`;
                
                // Set sun opacity based on time (fade during sunset/sunrise)
                if (currentHour >= 17) { // Sunset
                    const fadeProgress = (currentHour + currentMinute/60 - 17) / 2;
                    sunElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else if (currentHour < 6) { // Sunrise
                    const fadeProgress = (currentHour + currentMinute/60 - 5);
                    sunElement.style.opacity = Math.min(1, fadeProgress);
                } else {
                    sunElement.style.opacity = '1';
                }
                
                // Hide moon during day
                moonElement.style.opacity = '0';
                
                // Stars invisible during day
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
            } 
            // Moon moves from left to right during night (19-5)
            else {
                const moonProgress = (currentHour >= 19) ? 
                    (currentHour - 19) / 10 : // Evening (19-24)
                    (currentHour + 5) / 10;  // Morning (0-5)
                
                // Circular path for moon
                const moonX = skyWidth * moonProgress;
                const moonY = skyHeight * 0.3 * Math.sin(Math.PI * moonProgress) + 50;
                
                moonElement.style.left = `${moonX}px`;
                moonElement.style.top = `${moonY}px`;
                
                // Set moon opacity (fade during transitions)
                if (currentHour >= 19 && currentHour < 20) { // Dusk
                    const fadeProgress = (currentHour + currentMinute/60 - 19);
                    moonElement.style.opacity = Math.min(1, fadeProgress);
                } else if (currentHour >= 4 && currentHour < 5) { // Dawn
                    const fadeProgress = (currentHour + currentMinute/60 - 4);
                    moonElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else {
                    moonElement.style.opacity = '1';
                }
                
                // Hide sun during night
                sunElement.style.opacity = '0';
                
                // Stars visible at night
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
            }
        }
        
        // Transition to night
        function transitionToNight() {
            if (isDayTime) {
                isDayTime = false;
                
                // Fade in night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0.3)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Create stars if they don't exist
                if (document.querySelectorAll('.star').length === 0) {
                    createStarsElements();
                }
                
                // Show stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(0.8)';
                
                // Update UI elements for night
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.25)';
                });
            }
        }
        
        // Transition to day
        function transitionToDay() {
            if (!isDayTime) {
                isDayTime = true;
                
                // Fade out night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Hide stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(1)';
                
                // Update UI elements for day
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                });
                
                // Maybe create some birds for the new day
                if (birds.length < 2 && Math.random() < 0.5) {
                    createBird();
                }
            }
        }
        
        // Create star elements in DOM
        function createStarsElements() {
            createStars(); // Generate star data
            
            stars.forEach(star => {
                const starElement = document.createElement('div');
                starElement.className = 'star';
                starElement.style.width = `${star.size}px`;
                starElement.style.height = `${star.size}px`;
                starElement.style.left = `${star.x}px`;
                starElement.style.top = `${star.y}px`;
                
                // Custom twinkle animation
                starElement.style.animationDuration = `${star.twinkleSpeed}s`;
                
                document.getElementById('game-container').appendChild(starElement);
            });
        }
        // Game statistics
        let stats = {
            monthsPlayed: 0,
            powerupsCollected: 0,
            obstaclesAvoided: 0,
            obstaclesFaced: 0,
            expenses: 0,
            income: 5000,  // Starting monthly income
            mentalHealth: 100, // Mental state affects progress speed
            physicalHealth: 100 // Physical state affects progress speed
        };
        
        // Financial questions and answers as obstacles
const financialQuestions = [
    {
        question: "ğŸ” ×›××” ×›×¡×£ ×‘×©× ×” ×™×•×¦×™× ××“× ×©××§×¦×” 50 ×©\"×— ×œ×™×•× ×œ××¨×•×—×•×ª ×—×•×¥?",
        correctAnswer: "×›-18,000 ×©\"×— ×‘×©× ×”",
        wrongAnswer: "×›-10,000 ×©\"×— ×‘×©× ×”",
        explanation: "50 ×©\"×— ×›×¤×•×œ 365 ×™××™× ×©×•×•×” 18,250 ×©\"×— ×‘×©× ×”"
    },
    {
        question: "ğŸ’° ××™×–×” ××—×•×– ××”×¦×¢×™×¨×™× ×©×—×•×¡×›×™× 20% ××”×›× ×¡×ª× ××’×™×¢×™× ×œ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª ×ª×•×š 5 ×©× ×™×?",
        correctAnswer: "70% ××”×¦×¢×™×¨×™×",
        wrongAnswer: "30% ××”×¦×¢×™×¨×™×",
        explanation: "×—×™×¡×›×•×Ÿ ×¢×§×‘×™ ×©×œ 20% ××”×”×›× ×¡×” ××•×‘×™×œ ×œ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª"
    },
    {
        question: "ğŸ“ˆ ×”×©×§×¢×” ×©×œ 500 ×©\"×— ×‘×—×•×“×© ×”×—×œ ××’×™×œ 23 ×™×›×•×œ×” ×œ×”×’×™×¢ ×œ×›××” ×‘×’×™×œ ×¤×¨×™×©×”?",
        correctAnswer: "×›××™×œ×™×•×Ÿ ×©\"×—",
        wrongAnswer: "×›-500,000 ×©\"×—",
        explanation: "×›×•×— ×”×¨×™×‘×™×ª ×“×¨×™×‘×™×ª ×œ××•×¨×š ×©× ×™× ×¨×‘×•×ª"
    },
    {
        question: "ğŸ›¡ï¸ ×§×¨×Ÿ ×—×™×¨×•× ××™×“×™××œ×™×ª ×¦×¨×™×›×” ×œ×›×¡×•×ª ×›××” ×—×•×“×©×™ ×”×•×¦××•×ª?",
        correctAnswer: "3-6 ×—×•×“×©×™×",
        wrongAnswer: "×—×•×“×© ××—×“ ×‘×œ×‘×“",
        explanation: "3-6 ×—×•×“×©×™× ×××¤×©×¨×™× ×”×ª××•×“×“×•×ª ×¢× ××©×‘×¨×™× ×¤×™× × ×¡×™×™×"
    },
    {
        question: "ğŸ“Š ×”×•×¦××•×ª ×§×‘×•×¢×•×ª ×œ× ×¦×¨×™×›×•×ª ×œ×¢×œ×•×ª ×¢×œ ××™×–×” ××—×•×– ××”×”×›× ×¡×” ×”×—×•×“×©×™×ª × ×˜×•?",
        correctAnswer: "50%",
        wrongAnswer: "70%",
        explanation: "××’×‘×œ×ª 50% ×××¤×©×¨×ª ×’××™×©×•×ª ×›×œ×›×œ×™×ª ×•×—×™×¡×›×•×Ÿ"
    },
    {
        question: "ğŸ”‘ ××” ××”×‘××™× ×”×•× ××¤×ª×— ×œ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª?",
        correctAnswer: "×”×™×× ×¢×•×ª ××”×œ×•×•××•×ª ×¦×¨×›× ×™×•×ª ×‘×¨×™×‘×™×ª ×’×‘×•×”×”",
        wrongAnswer: "×œ×§×™×—×ª ×”×œ×•×•××•×ª ×œ×¦×•×¨×š ×”×©×§×¢×•×ª ××”×™×¨×•×ª",
        explanation: "×”×œ×•×•××•×ª ×‘×¨×™×‘×™×ª ×’×‘×•×”×” ×©×•×—×§×•×ª ××ª ×”×”×›× ×¡×” ×”×¤× ×•×™×”"
    },
    {
        question: "ğŸ·ï¸ ×¨×›×™×©×ª ××•×¦×¨×™× ××©×•××©×™× ×™×›×•×œ×” ×œ×—×¡×•×š ×¢×“ ×›××” ××—×•×–×™× ××¢×œ×•×ª× ×”×—×“×©×”?",
        correctAnswer: "×¢×“ 70%",
        wrongAnswer: "×¢×“ 40%",
        explanation: "××•×¦×¨×™× ××©×•××©×™× ×‘××¦×‘ ×˜×•×‘ ×™×›×•×œ×™× ×œ×—×¡×•×š ×¢×“ 70% ××”×¢×œ×•×ª"
    },
    {
        question: "ğŸš— ××” × ×›×•×Ÿ ×œ×’×‘×™ ×œ×™×¡×™× ×’ ×ª×¤×¢×•×œ×™ ×œ×¨×›×‘ ×‘×”×©×•×•××” ×œ×¨×›×™×©×” ×™×©×™×¨×”?",
        correctAnswer: "×œ×¨×•×‘ ×™×§×¨ ×™×•×ª×¨ ×‘×˜×•×•×— ×”××¨×•×š",
        wrongAnswer: "×ª××™×“ ××©×ª×œ× ×™×•×ª×¨ ××¨×›×™×©×” ×™×©×™×¨×”",
        explanation: "×¢×œ×•×ª ×”×œ×™×¡×™× ×’ ×”××¦×˜×‘×¨×ª ×œ××•×¨×š ×–××Ÿ ×’×‘×•×”×” ××¨×›×™×©×”"
    },
    {
        question: "ğŸ‘µ ××” × ×›×•×Ÿ ×œ×’×‘×™ ×”×¤×¨×©×” ×œ×¤× ×¡×™×”?",
        correctAnswer: "×”×¤×¨×©×” ×‘×’×™×œ ××•×§×“× ××’×“×™×œ×” ××©××¢×•×ª×™×ª ××ª ×”×—×™×¡×›×•×Ÿ ×”×¡×•×¤×™",
        wrongAnswer: "×¢×“×™×£ ×œ×”×ª×—×™×œ ×œ×”×¤×¨×™×© ×œ×¤× ×¡×™×” ×¨×§ ××—×¨×™ ×’×™×œ 40",
        explanation: "×›×›×œ ×©××ª×—×™×œ×™× ××•×§×“× ×™×•×ª×¨, ×›×š ×’×“×œ ×”×—×™×¡×›×•×Ÿ ×”×¡×•×¤×™"
    },
    {
        question: "ğŸ“ ×‘×“×™×§×” ×©×œ ×”×”×•×¦××•×ª ×”×—×•×“×©×™×•×ª ××—×ª ×œ×¨×‘×¢×•×Ÿ ×™×›×•×œ×” ×œ×—×¡×•×š ×›××” ×›×¡×£?",
        correctAnswer: "×××•×ª ×©×§×œ×™×",
        wrongAnswer: "×¢×©×¨×•×ª ×©×§×œ×™× ×‘×œ×‘×“",
        explanation: "×–×™×”×•×™ ×”×•×¦××•×ª ××™×•×ª×¨×•×ª ×•×—×™×¡×›×•×Ÿ ×‘×”×•×¦××•×ª ×§×‘×•×¢×•×ª"
    }
];
        
        // Total months of simulation - extended game time
        const totalMonths = 24; // March 2025 to March 2027
        const monthNames = [
            "××¨×¥ 2025", "××¤×¨×™×œ 2025", "×××™ 2025", "×™×•× ×™ 2025", "×™×•×œ×™ 2025", 
            "××•×’×•×¡×˜ 2025", "×¡×¤×˜××‘×¨ 2025", "××•×§×˜×•×‘×¨ 2025", "× ×•×‘××‘×¨ 2025", "×“×¦××‘×¨ 2025",
            "×™× ×•××¨ 2026", "×¤×‘×¨×•××¨ 2026", "××¨×¥ 2026", "××¤×¨×™×œ 2026", "×××™ 2026", 
            "×™×•× ×™ 2026", "×™×•×œ×™ 2026", "××•×’×•×¡×˜ 2026", "×¡×¤×˜××‘×¨ 2026", "××•×§×˜×•×‘×¨ 2026", 
            "× ×•×‘××‘×¨ 2026", "×“×¦××‘×¨ 2026", "×™× ×•××¨ 2027", "×¤×‘×¨×•××¨ 2027", "××¨×¥ 2027"
        ];
        
        // Month duration increased to 5 minutes per month (300 seconds)
        const monthDuration = 300; // 5 minutes (300 seconds) per month
        const framesPerSecond = 60;
        const frameTime = 1000 / framesPerSecond;
        const framesPerMonth = monthDuration * framesPerSecond;
        let currentMonthTimer = 0;

        // Monthly counters to limit obstacle and powerup appearances
let monthlyObstacleCounter = {
    person: 0,
    ad: 0,
    food: 0,
    thought: 0,
    companion_msg: 0,
    financial_question: 0
};

let monthlyPowerupCounter = {
    money: 0,
    earlyRise: 0,
    earlySleep: 0,
    healthyFood: 0,
    exercise: 0,
    companion: 0
};
      
        // Power-up variables
        const maxPowerUpTime = 900; // 15 seconds at 60fps
        let gameMessage = '';
        let gameMessageTime = 0;
        
        // Player variables
        const player = {
    x: canvas.width * 0.2,
    y: canvas.height * 0.7,
    width: 50,
    height: 80,
    baseSpeed: 5, // Base speed
    currentSpeed: 5, // Current speed affected by player condition
    powerUp: false,
    powerUpTime: 0,
    powerUpType: '',
    companion: false,
    weight: 1, // Increases with unhealthy food, affects speed
    mentalStrength: 1, // Decreases with negative mental effects, affects speed
    emojiChar: 'ğŸ™‚', // Default player emoji
    companionEmojiChar: null, // Will be set when companion is active
    lastHealthCheck: 0 // To track health changes for emoji updates
};
        
        // Ground variables
        const ground = {
            y: canvas.height * 0.8,
            width: canvas.width,
            height: canvas.height * 0.2
        };
        
        // Current powerup in dialog
        let currentPowerup = null;
        let powerupFollowupQuestions = [];
        let powerupFollowupIndex = 0;
        
        // Arrays for game objects
        let obstacles = [];
        let powerups = [];
        let pendingObstacles = [];  // For delayed creation
        
        // Obstacle dialog variables
        let currentObstacle = null;
        let lastObstacleTime = 0;
        const minObstacleInterval = 5000; // Minimum time between obstacle dialogs (5 seconds)
        let persuasionStage = 0; // Current persuasion stage
        let persuasionTexts = []; // Persuasion texts per obstacle
        
        // Job offer variables
        let jobOfferStage = 0;
        const jobOfferTexts = [
            "×”×× ××ª×” ×‘×˜×•×— ×©×‘×¨×¦×•× ×š ×œ×“×—×•×ª ×”×–×“×× ×•×ª ×–×•?",
            "×”×©×›×¨ ×’×‘×•×” ×‘-25% ×•×ª× ××™ ×”×¡×•×¦×™××œ×™×™× ××©×•×¤×¨×™×",
            "×”×”×–×“×× ×•×ª ×œ×”×ª×¤×ª×—×•×ª ××§×¦×•×¢×™×ª ××©××¢×•×ª×™×ª ×™×•×ª×¨",
            "×”×¢×‘×•×“×” ××¦×™×¢×” ×’××™×©×•×ª ×¨×‘×” ×™×•×ª×¨ ×‘×©×¢×•×ª ×”×¢×‘×•×“×”"
        ];
        
        // Bonus questions for financial bonus powerup
const bonusQuestions = [
    { 
        question: "â° ×”×× ×”×’×¢×ª ×œ×¢×‘×•×“×” ×‘×–××Ÿ ×›×œ ×”×©×‘×•×¢?", 
        positiveEffect: "âœ… ×××™× ×•×ª ×•×“×™×™×§× ×•×ª ×”× ×¢×¨×›×™× ×—×©×•×‘×™× ×œ××¢×¡×™×§",
        negativeEffect: "âŒ ××™×—×•×¨×™× ×¤×•×’×¢×™× ×‘×ª×“××™×ª ×”××§×¦×•×¢×™×ª ×©×œ×š"
    },
    { 
        question: "ğŸ“‹ ×”×× ×¡×™×™××ª ××ª ×›×œ ×”××©×™××•×ª ×©×œ×š ×œ×¤× ×™ ×”×“×“×œ×™×™×Ÿ?", 
        positiveEffect: "âœ… ×¢××™×“×” ×‘×™×¢×“×™× ××•×›×™×—×” ×™×¢×™×œ×•×ª ×•××§×¦×•×¢×™×•×ª",
        negativeEffect: "âŒ ××™ ×¢××™×“×” ×‘×–×× ×™× ×¤×•×’×¢×ª ×‘×”×¢×¨×›×ª ×”×‘×™×¦×•×¢×™× ×©×œ×š"
    },
    { 
        question: "ğŸ¤ ×”×× ×¢×–×¨×ª ×œ×¢××™×ª×™× ×œ×¢×‘×•×“×” ×”×©×‘×•×¢?", 
        positiveEffect: "âœ… ×¢×‘×•×“×ª ×¦×•×•×ª ×˜×•×‘×” × ×œ×§×—×ª ×‘×—×©×‘×•×Ÿ ×‘×”×¢×¨×›×ª ×¢×•×‘×“×™×",
        negativeEffect: "âŒ ×©×™×ª×•×£ ×¤×¢×•×œ×” ××•×’×‘×œ ××§×˜×™×Ÿ ××ª ×”×¢×¨×š ×©×œ×š ×œ××¨×’×•×Ÿ"
    },
    { 
        question: "ğŸ’¡ ×”×× ×”×‘××ª ×¨×¢×™×•×Ÿ ×—×“×© ××• ×”×¦×¢×ª ×™×™×¢×•×œ ×œ×¢×‘×•×“×”?", 
        positiveEffect: "âœ… ×™×•×–××” ×•×™×¦×™×¨×ª×™×•×ª ××•×‘×™×œ×•×ª ×œ×§×™×“×•× ××§×¦×•×¢×™",
        negativeEffect: "âŒ ×¤×¡×™×‘×™×•×ª ×‘×¢×‘×•×“×” ××’×‘×™×œ×” ××ª ×¤×•×˜× ×¦×™××œ ×”×§×™×“×•× ×©×œ×š"
    },
    { 
        question: "ğŸ“š ×”×× ×”×©×§×¢×ª ×–××Ÿ ×‘×”×¨×—×‘×ª ×”×™×“×¢ ×”××§×¦×•×¢×™ ×©×œ×š?", 
        positiveEffect: "âœ… ×”×ª×¤×ª×—×•×ª ××™×©×™×ª ××’×“×™×œ×” ××ª ×¢×¨×›×š ×‘×©×•×§ ×”×¢×‘×•×“×”",
        negativeEffect: "âŒ ×§×™×‘×¢×•×Ÿ ××§×¦×•×¢×™ ××’×‘×™×œ ××ª ×”××¤×©×¨×•×™×•×ª ×”×¢×ª×™×“×™×•×ª ×©×œ×š"
    }
];
        
        // Helper for random number generation
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // Show popup message with enhanced visuals
function showPopupMessage(message, duration = 2000) {
    const popup = document.getElementById('popup-message');
    
    // ×‘×“×™×§×” ×× ×›×‘×¨ ×™×© ××™××•×’'×™ ×‘×ª×—×™×œ×ª ×”×”×•×“×¢×”
    if (!/^\p{Emoji}/u.test(message)) {
        // ×‘×—×™×¨×ª ××™××•×’'×™ ××§×¨××™ ××ª××™× ×œ×¤×™ ×ª×•×›×Ÿ ×”×”×•×“×¢×”
        let emoji = "";
        
        if (message.includes("×‘×•× ×•×¡") || message.includes("×ª×’××•×œ")) {
            emoji = "ğŸ’° ";
        } else if (message.includes("×¢×™×“×•×“") || message.includes("×—×‘×¨")) {
            emoji = "ğŸ‘ ";
        } else if (message.includes("×—×™×–×•×§ ×¤×¢×™×œ") || message.includes("×—×™×–×•×§")) {
            emoji = "âš¡ ";
        } else if (message.includes("×”×—×œ×˜×” ×¤×™× × ×¡×™×ª")) {
            emoji = "ğŸ§  ";
        } else if (message.includes("×ª×©×•×‘×” × ×›×•× ×”")) {
            emoji = "âœ… ";
        } else if (message.includes("×ª×©×•×‘×” ×©×’×•×™×”")) {
            emoji = "âŒ ";
        } else if (message.includes("×”×©×¤×¢×ª ×”×—×™×–×•×§ ×”×¡×ª×™×™××”")) {
            emoji = "â±ï¸ ";
        } else if (message.includes("××™××¦×ª") || message.includes("××™××•×¥")) {
            emoji = "ğŸ’­ ";
        } else {
            // ××™××•×’'×™× ×›×œ×œ×™×™× ×œ××§×¨×” ×©××™×Ÿ ×”×ª×××” ×¡×¤×¦×™×¤×™×ª
            const generalEmojis = ["ğŸ“Œ", "â„¹ï¸", "ğŸ””", "ğŸ’¬", "ğŸ“£"];
            emoji = generalEmojis[Math.floor(Math.random() * generalEmojis.length)] + " ";
        }
        
        // ×”×•×¡×¤×ª ×”××™××•×’'×™ ×‘×ª×—×™×œ×ª ×”×”×•×“×¢×”
        message = emoji + message;
    }
    
    popup.textContent = message;
    popup.style.opacity = '1';
    popup.style.transform = 'translateX(-50%) translateY(-10px)';
    
    setTimeout(() => {
        popup.style.opacity = '0';
        popup.style.transform = 'translateX(-50%) translateY(0px)';
    }, duration);
}
        
        // Update player's speed based on mental and physical health
        function updatePlayerCondition() {
    // Calculate weight effect (physical health)
    let weightEffect = 1;
    if (stats.physicalHealth < 80) {
        weightEffect = 0.9;
        document.getElementById('status-weight').style.display = 'block';
        document.getElementById('status-weight').textContent = "××¦×‘ ×’×•×¤× ×™: ×™×¨×•×“";
    } else if (stats.physicalHealth < 60) {
        weightEffect = 0.7;
        document.getElementById('status-weight').style.display = 'block';
        document.getElementById('status-weight').textContent = "××¦×‘ ×’×•×¤× ×™: ×œ×§×•×™";
    } else if (stats.physicalHealth < 40) {
        weightEffect = 0.5;
        document.getElementById('status-weight').style.display = 'block';
        document.getElementById('status-weight').textContent = "××¦×‘ ×’×•×¤× ×™: ×—××•×¨";
    } else {
        document.getElementById('status-weight').style.display = 'none';
    }
    
    // Calculate mental effect
    let mentalEffect = 1;
    if (stats.mentalHealth < 80) {
        mentalEffect = 0.9;
        document.getElementById('status-negative').style.display = 'block';
        document.getElementById('status-negative').textContent = "××¦×‘ ×× ×˜×œ×™: ×™×¨×•×“";
    } else if (stats.mentalHealth < 60) {
        mentalEffect = 0.7;
        document.getElementById('status-negative').style.display = 'block';
        document.getElementById('status-negative').textContent = "××¦×‘ ×× ×˜×œ×™: ×œ×§×•×™";
    } else if (stats.mentalHealth < 40) {
        mentalEffect = 0.5;
        document.getElementById('status-negative').style.display = 'block';
        document.getElementById('status-negative').textContent = "××¦×‘ ×× ×˜×œ×™: ×—××•×¨";
    } else {
        document.getElementById('status-negative').style.display = 'none';
    }
    
    // Update player speed
player.currentSpeed = player.baseSpeed * weightEffect * mentalEffect;

// Update dashboard speed indicator only
const dashboardSpeedIndicator = document.getElementById('dashboard-speed-indicator');

let speedText, speedClass;

if (player.currentSpeed < player.baseSpeed * 0.6) {
    speedText = '××™×˜×™×ª ×××•×“';
    speedClass = 'very-slow';
} else if (player.currentSpeed < player.baseSpeed * 0.8) {
    speedText = '××™×˜×™×ª';
    speedClass = 'slow';
} else if (player.currentSpeed < player.baseSpeed * 0.95) {
    speedText = '×‘×™× ×•× ×™×ª';
    speedClass = 'medium';
} else {
    speedText = '××•×¤×˜×™××œ×™×ª';
    speedClass = '';
}

// Update dashboard speed indicator
if (dashboardSpeedIndicator) {
    dashboardSpeedIndicator.textContent = speedText;
    
    // Reset classes
    dashboardSpeedIndicator.classList.remove('very-slow', 'slow', 'medium');
    
    // Add appropriate class if needed
    if (speedClass) {
        dashboardSpeedIndicator.classList.add(speedClass);
    }
}
            
            // Update health bars with animation
            const physicalFill = document.getElementById('physical-health-fill');
            const mentalFill = document.getElementById('mental-health-fill');
            
            // Save current width for transition
            const currentPhysicalWidth = parseFloat(physicalFill.style.width) || 100;
            const currentMentalWidth = parseFloat(mentalFill.style.width) || 100;
            
            // Apply smooth transition if significant change
            if (Math.abs(currentPhysicalWidth - stats.physicalHealth) > 5) {
                physicalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { physicalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            if (Math.abs(currentMentalWidth - stats.mentalHealth) > 5) {
                mentalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { mentalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            // Set new values
            physicalFill.style.width = `${stats.physicalHealth}%`;
            mentalFill.style.width = `${stats.mentalHealth}%`;
            
            // Update color based on health level
            if (stats.physicalHealth < 40) {
                physicalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.physicalHealth < 70) {
                physicalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                physicalFill.style.backgroundColor = 'var(--success-color)';
            }
            
            if (stats.mentalHealth < 40) {
                mentalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.mentalHealth < 70) {
                mentalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                mentalFill.style.backgroundColor = 'var(--primary-color)';
            }

            // ×¢×“×›×•×Ÿ ××”×™×¨×•×ª ×”×™×•× ×‘×”×ª×× ×œ×‘×¨×™××•×ª
            updateDaySpeed();
        }

// ×¤×•× ×§×¦×™×” ×œ×¢×“×›×•×Ÿ ×”××™××•×’'×™ ×©×œ ×”×©×—×§×Ÿ ×‘×”×ª×× ×œ××¦×‘ ×”×ª× ×•×¢×” ×•×”×‘×¨×™××•×ª
function updatePlayerEmoji() {
    const healthFactor = stats.physicalHealth / 100;
    const mentalFactor = stats.mentalHealth / 100;
    
    if (!isMoving) {
        // When player isn't moving, always show standing emoji
        const standingEmojis = ["ğŸ§â€â™‚ï¸", "ğŸ§â€â™€ï¸"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    } else if (healthFactor > 0.7 && mentalFactor > 0.7) {
        // Excellent health - running
        const runningEmojis = ["ğŸƒâ€â™‚ï¸", "ğŸƒâ€â™€ï¸"];
        player.emojiChar = runningEmojis[Math.floor(Math.random() * runningEmojis.length)];
    } else if (healthFactor > 0.4 && mentalFactor > 0.4) {
        // Good health - walking
        const walkingEmojis = ["ğŸš¶â€â™‚ï¸", "ğŸš¶â€â™€ï¸"];
        player.emojiChar = walkingEmojis[Math.floor(Math.random() * walkingEmojis.length)];
    } else {
        // Poor health - standing
        const standingEmojis = ["ğŸ§â€â™‚ï¸", "ğŸ§â€â™€ï¸"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    }
}

        // ×¢×“×›×•×Ÿ ××”×™×¨×•×ª ×”×™×•× ×‘×”×ª×× ×œ×‘×¨×™××•×ª
function updateDaySpeed() {
    // ×—×™×©×•×‘ ×ª×•×¡×¤×ª ×©× ×™×•×ª ×‘×”×ª×× ×œ×™×¨×™×“×” ×‘×‘×¨×™××•×ª
    // ×‘×¨×™××•×ª ×¤×™×–×™×ª: ×›×œ × ×§×•×“×” ××ª×—×ª ×œ-90 ××•×¡×™×¤×” 1000 ××™×œ×™×©× ×™×•×ª (×©× ×™×™×” ××—×ª)
    const physicalHealthPenalty = Math.max(0, 90 - stats.physicalHealth);
    
    // ×‘×¨×™××•×ª ×× ×˜×œ×™×ª: ×›×œ × ×§×•×“×” ××ª×—×ª ×œ-90 ××•×¡×™×¤×” 1000 ××™×œ×™×©× ×™×•×ª (×©× ×™×™×” ××—×ª)
    const mentalHealthPenalty = Math.max(0, 90 - stats.mentalHealth);
    
    // ×—×™×©×•×‘ ×–××Ÿ ×™×•× × ×•×›×—×™
    dayMilliseconds.current = dayMilliseconds.perfect + (physicalHealthPenalty + mentalHealthPenalty) * 1000;
}
        
        // Create obstacle with improved visuals
function createObstacle() {
    const types = ['person', 'ad', 'food', 'financial_question'];
    // Filter types that already appeared twice this month
    const availableTypes = types.filter(type => monthlyObstacleCounter[type] < 2);
    
    // If no available types, exit function
    if (availableTypes.length === 0) return;
    
    const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
    
    // Update counter for the selected type
    monthlyObstacleCounter[type]++;
    
    let obstacle;
    
    if (type === 'person') {
        const negativeComments = [
            "×§×©×” ×œ×—×¡×•×š ×¢× ××©×›×•×¨×ª ×›××• ×©×œ×š",
            "××ª×” ×œ× ×ª×¦×œ×™×— ×œ×”×’×™×¢ ×œ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª",
            "×¨×•×‘ ×”×× ×©×™× ×œ× ××¦×œ×™×—×™× ×œ×—×¡×•×š",
            "××ª×” ××¤×¡×¤×¡ ×”× ××•×ª ×‘×’×œ×œ ×”×§××¦× ×•×ª ×©×œ×š",
            "×—×™×¡×›×•×Ÿ ×–×” ×œ××¢××“ ×¡×•×¦×™×•-××§×•× ×•××™ ×’×‘×•×”",
            "××£ ×¤×¢× ×œ× ×ª×’×™×¢ ×œ×™×¢×“ ×©×œ 100,000",
            "×—×™×™× ×¨×§ ×¤×¢× ××—×ª, ××œ ×ª×—×¡×•×š ×œ×™×•× ×¡×’×¨×™×¨"
        ];
        
        // Persuasive texts for negative people with updated options
        const persuasiveTexts = [
            {
                text: "×–×” ×œ× ××¤×©×¨×™ ×œ×—×¡×•×š ×¢× ××©×›×•×¨×ª ×›××• ×©×™×© ×œ×š",
                acceptOption: "××ª×” ×¦×•×“×§, ××—×¡×•×š ×›×©××¨×•×•×™×— ×™×•×ª×¨",
                ignoreOption: "×—×™×¡×›×•×Ÿ ×–×” ×¢× ×™×™×Ÿ ×©×œ ××©××¢×ª, ×œ× ×¨×§ ××©×›×•×¨×ª"
            },
            {
                text: "× ×•, ×•××” ×ª×¢×©×” ×©×ª×’×™×¢ ×œ-100,000 ×©×´×—?",
                acceptOption: "××™×Ÿ ×œ×™ ×‘×××ª ×ª×›× ×™×ª, ×–×” ×¡×ª× ××¡×¤×¨",
                ignoreOption: "××”×¤×•×š ××•×ª×• ×œ×”×©×§×¢×” ×©×ª×‘×˜×™×— ×œ×™ ×—×•×¤×© ×›×œ×›×œ×™"
            },
            {
                text: "××£ ×¤×¢× ×œ× ×ª×’×™×¢ ×œ×™×¢×“ ×©×œ 100,000 ×‘×—×™×¡×›×•×Ÿ",
                acceptOption: "× ×™×¡×™×ª×™ ×‘×¢×‘×¨ ×•×œ× ×”×¦×œ×—×ª×™, ×§×©×” ××“×™",
                ignoreOption: "×›×œ ×—×™×¡×›×•×Ÿ ××§×¨×‘ ××•×ª×™ ×œ×™×¢×“, ××ª×¢×œ× ××§×•×œ×•×ª ×©×œ×™×œ×™×™×"
            }
        ];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 80,
            width: 50,
            height: 80,
            type: type,
            speed: 4 + (currentMonth * 0.1),
            text: negativeComments[getRandomInt(0, negativeComments.length - 1)],
            value: getRandomInt(500, 1000), // Cost if hit
            mentalEffect: getRandomInt(5, 15), // How much it will reduce mental health
            persuasiveTexts: persuasiveTexts,
            obstacleTitle: "×‘×™× ×™× ×•...",
            initialText: "××ª×” ××¤×¡×¤×¡ ××ª ×”×—×™×™× ×‘×’×œ×œ ×”×§××¦× ×•×ª ×©×œ×š.",
            acceptOption: "××ª×” ×¦×•×“×§, ××•×œ×™ ×× ×™ ×‘×××ª ××’×–×™×",
            ignoreOption: "×× ×™ ×‘×•× ×” ××ª ×”×¢×ª×™×“ ×©×œ×™, ×œ× ××¤×¡×¤×¡",
            // Visual properties
            color: "#6c757d",
            animationOffset: Math.random() * Math.PI * 2, // For bobbing animation
            bobSpeed: 0.05 + Math.random() * 0.03
        };
    } else if (type === 'ad') {
        // Persuasive texts for ads - updated for "easy money" theme
        const persuasiveTexts = [
            {
                text: "ğŸ’¸ ×”×”×–×“×× ×•×ª ×”×–××ª ×¢×•××“×ª ×œ×”×™×¢×œ×!",
                ignoreOption: "×œ× ×ª×¦×œ×™×— ×œ×”×œ×—×™×¥ ××•×ª×™.",
                acceptOption: "××¡×•×¨ ×œ×™ ×œ×¤×¡×¤×¡ ××ª ×–×”!"
            },
            {
                text: "ğŸš€ ×ª×™×”×™×” ×—×›×, ×–×” ×›×¡×£ ×¢×œ ×”×¨×¦×¤×”",
                ignoreOption: "×× ×™ ×œ× ××ª×¨×’×©",
                acceptOption: "×× ×™ ×—×™×™×‘ ××ª ×–×”!"
            },
            {
                text: "âš  ×–××ª ×”×”×–×“×× ×•×ª ×©×œ×š ×œ×©× ×•×ª ××ª ×”×—×™×™× ×©×œ×š",
                ignoreOption: "×”×—×œ×˜×” ×¡×•×¤×™×ª: ×× ×™ ×“×•×—×” ××ª ×”×”×¦×¢×”",
                acceptOption: "×¡×•×£ ×¡×•×£ ×”×—×™×™× ×©×œ×™ ×™×¨××• ××—×¨×ª!"
            }
        ];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 70,
            width: 60,
            height: 70,
            type: type,
            speed: 5 + (currentMonth * 0.15),
            text: "××œ ×ª×¤×¡×¤×¡! ×”×–×“×× ×•×ª ×—×™×™×š ×œ×™×™×¦×¨ ×”×›× ×¡×” ××›×œ ××§×•×, ×‘×›×œ ×–××Ÿ, ×•×œ×œ× ××××¥!",
            value: getRandomInt(1000, 3000),
            persuasiveTexts: persuasiveTexts,
            obstacleTitle: "ğŸ“¢ ×¨×•×¦×” ×œ×”×¨×•×•×™×— ×›×¡×£ ×§×œ?",
            initialText: "××œ ×ª×¤×¡×¤×¡! ×”×–×“×× ×•×ª ×—×™×™×š ×œ×™×™×¦×¨ ×”×›× ×¡×” ××›×œ ××§×•×, ×‘×›×œ ×–××Ÿ, ×•×œ×œ× ××××¥!",
            ignoreOption: "×× ×™ ×œ× ××ª×¤×ª×”",
            acceptOption: "××¢× ×™×™×Ÿ ××•×ª×™!",
            // Visual properties
            color: "#495057",
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.08 + Math.random() * 0.04, // Ads move more erratically
            pulseRate: 0.03 + Math.random() * 0.02 // For pulsing effect
        };
    } else if (type === 'food') {
        const foodTypes = [
            "×”×–×× ×ª ××©×œ×•×— ××•×œ ×‘×™×©×•×œ ×‘×™×ª×™",
            "×§×¤×” ×•×××¤×” ×¢×œ ×”×“×¨×š",
            "××–×•×Ÿ ××”×™×¨ ×œ×¢×•××ª ×¡×•×¤×¨ ×–×•×œ",
            "×‘×™×œ×•×™ ×—×‘×¨×ª×™ ×©×“×•×¨×© ×”×•×¦××” ×›×¡×¤×™×ª"
        ];
        
        // Persuasive texts for food - updated to be more tempting
        const persuasiveTexts = [
            {
                text: "ğŸ• ××ª×” ×¢×•×‘×“ ×§×©×”. ××” ×©×•×•×” ×”×›×¡×£ ×©××ª×” ×—×•×¡×š ×× ×œ× ×ª×”× ×” ××× ×•?",
                ignoreOption: "×©×œ×™×˜×” ×¢×¦××™×ª ×—×©×•×‘×” ×™×•×ª×¨ ××¤×™× ×•×§ ×¨×’×¢×™",
                acceptOption: "××ª×” ×¦×•×“×§, ×× ×™ ×¦×¨×™×š ×œ×™×”× ×•×ª ×§×¦×ª..."
            },
            {
                text: "ğŸ¥³ ××¡×•×¨ ×œ×¤×¡×¤×¡ ×—×•×•×™×•×ª ×‘×—×™×™×!",
                ignoreOption: "×”×”× ××” ×©×œ×™ ×”×™× ×”×—×•×–×§×” ×©×œ×™",
                acceptOption: "×—×•×•×™×” ×©×•×•×” ××ª ×”×”×•×¦××”!"
            },
            {
                text: "ğŸ© ×–×• ×¨×§ ×¤×¢× ××—×ª. ××—×¨ ×ª×—×–×•×¨ ×œ×—×¡×•×š ×›×¨×’×™×œ.",
                ignoreOption: "×”'×¤×¢× ×”××—×ª' ×”×–×• ××¦×˜×‘×¨×ª ×œ×¡×›×•××™× ×’×“×•×œ×™×",
                acceptOption: "× ×›×•×Ÿ, ×¤×¢× ××—×ª ×œ× ×ª×©× ×” ×›×œ×•×"
            }
        ];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 60,
            width: 50,
            height: 60,
            type: type,
            speed: 3 + (currentMonth * 0.1),
            text: foodTypes[getRandomInt(0, foodTypes.length - 1)],
            value: getRandomInt(300, 1200),
            weightEffect: getRandomInt(5, 15), // How much it will reduce physical health
            persuasiveTexts: persuasiveTexts,
            obstacleTitle: "ğŸ” ×¤×™× ×•×§ ×§×˜×Ÿ ×œ× ×™×¤×™×œ ××•×ª×š, × ×›×•×Ÿ?",
            initialText: "×™×•× ××¨×•×š ×•××ª×™×© ×¢×‘×¨ ×¢×œ×™×š, ×•××™×Ÿ ×œ×š ×›×•×— ×œ×‘×©×œ.",
            ignoreOption: "×× ×™ × ×©××¨ ×—×–×§ â€“ ××‘×©×œ ×•××•×›×œ ×‘×‘×™×ª", 
            acceptOption: "×™××œ×œ×”, ××’×™×¢ ×œ×™ ×¤×™× ×•×§ â€“ ××–××™×Ÿ ××©×œ×•×—",
            // Visual properties
            color: "#6c757d",
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.04 + Math.random() * 0.02, // Food moves more slowly
            rotationSpeed: Math.random() * 0.01 // Slight rotation
        };
    } else if (type === 'financial_question') {
        // ×‘×—×¨ ×©××œ×” ××§×¨××™×ª ××”×××’×¨
        const questionIndex = getRandomInt(0, financialQuestions.length - 1);
        const question = financialQuestions[questionIndex];
        
        obstacle = {
            x: canvas.width,
            y: ground.y - 70,
            width: 60,
            height: 70,
            type: type,
            speed: 4 + (currentMonth * 0.1),
            text: question.question,
            value: 1000, // ×ª×’××•×œ ×›×¡×¤×™ ×¢×‘×•×¨ ×ª×©×•×‘×” × ×›×•× ×”
            questionData: question,
            obstacleTitle: "×©××œ×” ×¤×™× × ×¡×™×ª",
            initialText: question.question,
            // Visual properties
            color: "#3a7a5f", // ×™×¨×•×§
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.05 + Math.random() * 0.03
        };
    }
    
    // ×‘×“×™×§×” ×× ×”××›×©×•×œ ×”×—×“×© ××ª× ×’×© ×¢× ××•×‘×™×™×§×˜×™× ×§×™×™××™×
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // ×‘××™×“×ª ×”×¦×•×¨×š, ×©× ×” ××ª ××™×§×•× ×”-Y ×©×œ ×”××›×©×•×œ
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 100; // ×©×™× ×•×™ ××§×¨××™ ×‘×’×•×‘×” ×‘×˜×•×•×— +-50 ×¤×™×§×¡×œ×™×
            obstacle.y = ground.y - obstacle.height - Math.abs(yOffset);
        }
        
        // ×‘×“×•×§ ×× ×”××™×§×•× ×”×—×“×© ×¤× ×•×™
        validPosition = !isPositionOccupied(obstacle);
        attempts++;
    }
    
    obstacles.push(obstacle);
    
    // Add floating question mark above new financial question obstacle
    if (type === 'financial_question') {
        const questionMark = document.createElement('div');
        questionMark.className = 'floating-question-mark';
        questionMark.style.position = 'absolute';
        questionMark.style.fontSize = '24px';
        questionMark.style.fontWeight = 'bold';
        questionMark.style.color = '#3a7a5f';
        questionMark.style.textShadow = '0 0 8px rgba(58, 122, 95, 0.6)';
        questionMark.style.top = `${obstacle.y - 25}px`;
        questionMark.style.left = `${obstacle.x + obstacle.width/2}px`;
        questionMark.style.transform = 'translateX(-50%)';
        questionMark.style.zIndex = '20';
        questionMark.style.opacity = '0';
        questionMark.textContent = '?';
        
        document.getElementById('game-container').appendChild(questionMark);
        
        // Define animation
        const animStyle = document.createElement('style');
        animStyle.textContent = `
            @keyframes float-question-${Date.now()} {
                0% { transform: translateX(-50%) translateY(0); opacity: 0; }
                20% { transform: translateX(-50%) translateY(-10px); opacity: 1; }
                80% { transform: translateX(-50%) translateY(-10px); opacity: 1; }
                100% { transform: translateX(-50%) translateY(-20px); opacity: 0; }
            }
        `;
        document.head.appendChild(animStyle);
        
        // Apply animation
        questionMark.style.animation = `float-question-${Date.now()} 3s ease-out forwards`;
        
        // Remove after animation
        setTimeout(() => {
            if (questionMark.parentNode) {
                questionMark.parentNode.removeChild(questionMark);
            }
            if (animStyle.parentNode) {
                animStyle.parentNode.removeChild(animStyle);
            }
        }, 3000);
    }
    
    // Show subtle visual cue for obstacle approach
    const flash = document.createElement('div');
    flash.style.position = 'absolute';
    flash.style.right = '0';
    flash.style.top = `${obstacle.y}px`;
    flash.style.width = '10px';
    flash.style.height = `${obstacle.height}px`;
    flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
    flash.style.borderRadius = '5px 0 0 5px';
    flash.style.zIndex = '8';
    flash.style.animation = 'flash-warning 0.5s ease forwards';
    
    document.getElementById('game-container').appendChild(flash);
    
    // Define the animation keyframes
    const style = document.createElement('style');
    style.textContent = `
        @keyframes flash-warning {
            0% { opacity: 0.8; }
            100% { opacity: 0; right: 10px; }
        }
    `;
    document.head.appendChild(style);
    
    // Remove the flash element after animation
    setTimeout(() => {
        if (flash.parentNode) {
            flash.parentNode.removeChild(flash);
        }
    }, 500);
}
        
        // Create powerup with enhanced visuals
function createPowerup() {
    // ×”×¡×¨ 'money' ××”×¡×•×’×™× ×”×¨×’×™×œ×™×
    const types = ['earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
    
    // ×‘×“×•×§ ×× ××¤×©×¨ ×œ×”×•×¡×™×£ ×‘×•× ×•×¡ ×›×¡×¤×™ (×¤×¢× ×‘×—×•×“×©)
    if (currentMonth > 0 && monthlyPowerupCounter['money'] === 0) {
        // 20% ×¡×™×›×•×™ ×œ×”×•×¡×™×£ ×‘×•× ×•×¡ ×›×¡×¤×™
        if (Math.random() < 0.2) {
            types.push('money');
        }
    }
    
    // Filter types that already appeared twice this month
    const availableTypes = types.filter(type => monthlyPowerupCounter[type] < 2);
    
    // If no available types, exit function
    if (availableTypes.length === 0) return;
    
    const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
    
    // Update counter for the selected type
    monthlyPowerupCounter[type]++;
    
    let text = '';
    let width = 40;
    let height = 40;
    let value = 1000;
    let color = '';
    
    switch(type) {
        case 'money':
            text = "×‘×•× ×•×¡ ×›×¡×¤×™";
            value = getRandomInt(1000, 3000);
            color = "#2a6496"; // Blue
            break;
        case 'earlyRise':
            text = "×§×™××” ××•×§×“××ª";
            color = "#3a7a5f"; // Green
            break;
                case 'earlySleep':
                    text = "×©×™× ×” ××•×§×“××ª";
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "×ª×–×•× ×” ×‘×¨×™××”";
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª";
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
                x: canvas.width,
                y: getRandomInt(ground.y - 150, ground.y - 60),
                width: width,
                height: height,
                type: type,
                speed: 4, // Slower speed for longer game
                text: text,
                value: value,
                healthEffect: type === 'healthyFood' || type === 'exercise' ? 10 : 0, // Improve physical health
                mentalEffect: type === 'earlySleep' || type === 'earlyRise' ? 10 : 0, // Improve mental health
                color: color,
                animationOffset: Math.random() * Math.PI * 2, // For floating animation
                floatSpeed: 0.03 + Math.random() * 0.02,
                floatRange: 10 + Math.random() * 5, // How far it floats up/down
                glowing: true, // Add glow effect
                originalY: 0 // Store original Y for floating animation
            };
            
            // Store original Y for floating animation
    powerup.originalY = powerup.y;
    
    // ×‘×“×™×§×” ×× ×”×¤××•×•×¨-××¤ ×”×—×“×© ××ª× ×’×© ×¢× ××•×‘×™×™×§×˜×™× ×§×™×™××™×
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // ×‘××™×“×ª ×”×¦×•×¨×š, ×©× ×” ××ª ××™×§×•× ×”-Y ×©×œ ×”×¤××•×•×¨-××¤
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 120; // ×©×™× ×•×™ ××§×¨××™ ×‘×’×•×‘×” 
            powerup.y = getRandomInt(ground.y - 150, ground.y - 60) + yOffset;
            powerup.originalY = powerup.y; // ×¢×“×›×•×Ÿ ×”-originalY ×’× ×›×Ÿ
        }
        
        // ×‘×“×•×§ ×× ×”××™×§×•× ×”×—×“×© ×¤× ×•×™
        validPosition = !isPositionOccupied(powerup);
        attempts++;
    }
    
    powerups.push(powerup);
            
            // Show subtle visual cue for powerup approach
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '10px';
            flash.style.height = `${powerup.height}px`;
            flash.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
            flash.style.borderRadius = '5px 0 0 5px';
            flash.style.zIndex = '8';
            flash.style.animation = 'flash-powerup 0.5s ease forwards';
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define the animation keyframes if not already defined
            if (!document.getElementById('powerup-flash-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-flash-style';
                style.textContent = `
                    @keyframes flash-powerup {
                        0% { opacity: 0.8; }
                        100% { opacity: 0; right: 10px; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the flash element after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 500);
        }
        // Create companion with enhanced visuals
function createCompanion() {
    // Check if companion already appeared twice this month
    if (monthlyPowerupCounter.companion >= 2) return;
    
    // Update companion counter
    monthlyPowerupCounter.companion++;
    
    const companion = {
        x: canvas.width,
        y: ground.y - 70,
        width: 40,
        height: 70,
        speed: 4,
        type: 'companion',
        text: "×ª××™×›×” ×—×‘×¨×ª×™×ª ×‘×“×¨×š ×”×¤×™× × ×¡×™×ª",
        color: "#2a6496", // Blue
        animationOffset: Math.random() * Math.PI * 2,
        floatSpeed: 0.02,
        floatRange: 5,
        originalY: ground.y - 70,
        glowing: true,
        emitParticles: true // Special effect for companions
    };
    
    // ×‘×“×™×§×” ×× ×”××œ×•×•×” ×”×—×“×© ××ª× ×’×© ×¢× ××•×‘×™×™×§×˜×™× ×§×™×™××™×
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // ×‘××™×“×ª ×”×¦×•×¨×š, ×©× ×” ××ª ××™×§×•× ×”-Y ×©×œ ×”××œ×•×•×”
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 80; // ×©×™× ×•×™ ××§×¨××™ ×‘×’×•×‘×” ×‘×˜×•×•×— ×§×˜×Ÿ ×™×•×ª×¨
            companion.y = ground.y - 70 + yOffset;
            companion.originalY = companion.y; // ×¢×“×›×•×Ÿ ×”-originalY ×’× ×›×Ÿ
        }
        
        // ×‘×“×•×§ ×× ×”××™×§×•× ×”×—×“×© ×¤× ×•×™
        validPosition = !isPositionOccupied(companion);
        attempts++;
    }
    
    powerups.push(companion);
    showPopupMessage("×ª××™×›×” ×—×‘×¨×ª×™×ª ××ª×§×¨×‘×ª!", 2000);
            
            // Add sound or visual cue for companion
            const companionAlert = document.createElement('div');
            companionAlert.style.position = 'absolute';
            companionAlert.style.top = '50%';
            companionAlert.style.left = '50%';
            companionAlert.style.transform = 'translate(-50%, -50%)';
            companionAlert.style.color = 'white';
            companionAlert.style.fontSize = '24px';
            companionAlert.style.padding = '15px 30px';
            companionAlert.style.borderRadius = '8px';
            companionAlert.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
            companionAlert.style.zIndex = '50';
            companionAlert.style.animation = 'companion-alert 1.5s forwards';
            companionAlert.textContent = 'ğŸ‘« ×ª××™×›×” ×—×‘×¨×ª×™×ª ××ª×§×¨×‘×ª!';
            
            document.getElementById('game-container').appendChild(companionAlert);
            
            // Add animation style if not already present
            if (!document.getElementById('companion-alert-style')) {
                const style = document.createElement('style');
                style.id = 'companion-alert-style';
                style.textContent = `
                    @keyframes companion-alert {
                        0% { opacity: 0; transform: translate(-50%, -70%); }
                        20% { opacity: 1; transform: translate(-50%, -50%); }
                        80% { opacity: 1; transform: translate(-50%, -50%); }
                        100% { opacity: 0; transform: translate(-50%, -30%); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the alert element after animation
            setTimeout(() => {
                if (companionAlert.parentNode) {
                    companionAlert.parentNode.removeChild(companionAlert);
                }
            }, 1500);
        }
        
        // Show powerup dialog with enhanced animation
function showPowerupDialog(powerup) {
    gamePaused = true;
    isMoving = false; // ×¢×¦×™×¨×ª ×”×ª× ×•×¢×” ×‘××•×¤×Ÿ ××•×—×œ×˜
    currentPowerup = powerup;
    powerupFollowupIndex = 0;
    
    // Set question based on powerup type
let question = "";
const powerupTitle = document.getElementById('powerup-title');
const ignoreBtn = document.getElementById('powerup-no-btn');
const acceptBtn = document.getElementById('powerup-yes-btn');

switch(powerup.type) {
    case 'exercise':
        powerupTitle.textContent = "ğŸ‹ï¸ ×©××œ×ª ×™×“×¢: ×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª";
        question = "×›×™×¦×“ ×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª ×¡×“×™×¨×” ×ª×•×¨××ª ×œ×™×¦×™×‘×•×ª ×¤×™× × ×¡×™×ª?";
        
        // ×¢×¨×‘×•×‘ ×¡×“×¨ ×”××¤×©×¨×•×™×•×ª ×‘××•×¤×Ÿ ××§×¨××™
        if(Math.random() < 0.5) {
            acceptBtn.textContent = "××¡×¤×§×ª ×—×•×¡×Ÿ ×× ×˜×œ×™ ×œ×¢××•×“ ××•×œ ×¤×™×ª×•×™×™× ×›×œ×›×œ×™×™×";
            ignoreBtn.textContent = "××™×Ÿ ×§×©×¨ ×‘×™×Ÿ ×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª ×œ×”×ª× ×”×œ×•×ª ×¤×™× × ×¡×™×ª";
            powerup.correctButton = 'powerup-yes-btn';
        } else {
            acceptBtn.textContent = "××™×Ÿ ×§×©×¨ ×‘×™×Ÿ ×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª ×œ×”×ª× ×”×œ×•×ª ×¤×™× × ×¡×™×ª";
            ignoreBtn.textContent = "××¡×¤×§×ª ×—×•×¡×Ÿ ×× ×˜×œ×™ ×œ×¢××•×“ ××•×œ ×¤×™×ª×•×™×™× ×›×œ×›×œ×™×™×";
            powerup.correctButton = 'powerup-no-btn';
        }
        
        powerup.explanation = "×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª ××—×–×§×ª ××ª ×”×™×›×•×œ×ª ×œ×”×ª××•×“×“ ×¢× ×œ×—×¦×™× ×•×œ×”×™×× ×¢ ××”×•×¦××•×ª ××™××¤×•×œ×¡×™×‘×™×•×ª";
        powerupFollowupQuestions = [];
        break;
    case 'healthyFood':
        powerupTitle.textContent = "ğŸ¥— ×©××œ×ª ×™×“×¢: ×ª×–×•× ×” ×‘×¨×™××”";
        question = "×œ××” ×ª×–×•× ×” ×‘×¨×™××” ×¢×•×–×¨×ª ×œ×—×¡×•×š ×›×¡×£?";
        
        if(Math.random() < 0.5) {
            acceptBtn.textContent = "××•× ×¢×ª ×”×•×¦××•×ª ×¨×¤×•××™×•×ª ×¢×ª×™×“×™×•×ª ×•××¤×—×™×ª×” ××›×™×œ×” ×¨×’×©×™×ª";
            ignoreBtn.textContent = "×›×“×™ ×œ×§× ×•×ª ××•×¦×¨×™× ××•×¨×’× ×™×™× ×™×§×¨×™× ×•×ª×•×¡×¤×™ ×ª×–×•× ×” ×™×•×§×¨×ª×™×™×";
            powerup.correctButton = 'powerup-yes-btn';
        } else {
            acceptBtn.textContent = "×›×“×™ ×œ×§× ×•×ª ××•×¦×¨×™× ××•×¨×’× ×™×™× ×™×§×¨×™× ×•×ª×•×¡×¤×™ ×ª×–×•× ×” ×™×•×§×¨×ª×™×™×";
            ignoreBtn.textContent = "××•× ×¢×ª ×”×•×¦××•×ª ×¨×¤×•××™×•×ª ×¢×ª×™×“×™×•×ª ×•××¤×—×™×ª×” ××›×™×œ×” ×¨×’×©×™×ª";
            powerup.correctButton = 'powerup-no-btn';
        }
        
        powerup.explanation = "×ª×–×•× ×” ×‘×¨×™××” ××©×¤×¨×ª ×‘×¨×™××•×ª ×œ×˜×•×•×— ××¨×•×š ×•××¤×—×™×ª×” ×”×•×¦××•×ª ×¢×œ ×˜×™×¤×•×œ×™× ×¨×¤×•××™×™×";
        powerupFollowupQuestions = [];
        break;
        case 'earlyRise':
    powerupTitle.textContent = "ğŸŒ… ×©××œ×ª ×™×“×¢: ×§×™××” ××•×§×“××ª";
    question = "××™×–×• ×”×©×¤×¢×” ×™×© ×œ×§×™××” ××•×§×“××ª ×¢×œ ×”×ª× ×”×œ×•×ª ×¤×™× × ×¡×™×ª?";
    
    if(Math.random() < 0.5) {
        acceptBtn.textContent = "××¡×¤×§×ª ×–××Ÿ ×œ×ª×›× ×•×Ÿ ×™×•××™ ×•×‘× ×™×™×ª ×”×¨×’×œ×™ ×—×™×¡×›×•×Ÿ";
        ignoreBtn.textContent = "××™×Ÿ ×§×©×¨ ×‘×™×Ÿ ×©×¢×ª ×”×§×™××” ×œ×”×ª× ×”×œ×•×ª ×”×¤×™× × ×¡×™×ª";
        powerup.correctButton = 'powerup-yes-btn';
    } else {
        acceptBtn.textContent = "××™×Ÿ ×§×©×¨ ×‘×™×Ÿ ×©×¢×ª ×”×§×™××” ×œ×”×ª× ×”×œ×•×ª ×”×¤×™× × ×¡×™×ª";
        ignoreBtn.textContent = "××¡×¤×§×ª ×–××Ÿ ×œ×ª×›× ×•×Ÿ ×™×•××™ ×•×‘× ×™×™×ª ×”×¨×’×œ×™ ×—×™×¡×›×•×Ÿ";
        powerup.correctButton = 'powerup-no-btn';
    }
    
    powerup.explanation = "×§×™××” ××•×§×“××ª ××•× ×¢×ª ×œ×—×¦×™× ×©×œ ×–××Ÿ ×©×’×•×¨××™× ×œ×”×•×¦××•×ª ×œ× ××—×•×©×‘×•×ª";
    powerupFollowupQuestions = [];
    break;
case 'earlySleep':
    powerupTitle.textContent = "ğŸ˜´ ×©××œ×ª ×™×“×¢: ×©×™× ×” ××¡×¤×§×ª";
    question = "×›×™×¦×“ ×©×™× ×” ××¡×¤×§×ª ××©×¤×™×¢×” ×¢×œ ×”×—×œ×˜×•×ª ×¤×™× × ×¡×™×•×ª?";
    
    if(Math.random() < 0.5) {
        acceptBtn.textContent = "××‘×˜×™×—×” ××•×— ×¦×œ×•×œ ×œ×§×‘×œ×ª ×”×—×œ×˜×•×ª ×¤×™× × ×¡×™×•×ª ××—×•×©×‘×•×ª";
        ignoreBtn.textContent = "×œ× ××©×¤×™×¢×” ×›×œ×œ - ×”×—×œ×˜×•×ª ×¤×™× × ×¡×™×•×ª ×”×Ÿ ×ª××™×“ ×¨×¦×™×•× ×œ×™×•×ª";
        powerup.correctButton = 'powerup-yes-btn';
    } else {
        acceptBtn.textContent = "×œ× ××©×¤×™×¢×” ×›×œ×œ - ×”×—×œ×˜×•×ª ×¤×™× × ×¡×™×•×ª ×”×Ÿ ×ª××™×“ ×¨×¦×™×•× ×œ×™×•×ª";
        ignoreBtn.textContent = "××‘×˜×™×—×” ××•×— ×¦×œ×•×œ ×œ×§×‘×œ×ª ×”×—×œ×˜×•×ª ×¤×™× × ×¡×™×•×ª ××—×•×©×‘×•×ª";
        powerup.correctButton = 'powerup-no-btn';
    }
    
    powerup.explanation = "×©×™× ×” ××™×›×•×ª×™×ª ×××¤×©×¨×ª ×—×©×™×‘×” ×‘×”×™×¨×” ×•××¤×—×™×ª×” ×§× ×™×•×ª ××™××¤×•×œ×¡×™×‘×™×•×ª";
    powerupFollowupQuestions = [];
    break;
case 'money':
    powerupTitle.textContent = "ğŸ’¼ ×”×¢×¨×›×ª ×‘×™×¦×•×¢×™× ×ª×¢×¡×•×§×ª×™×ª";
    question = "×”×× × ×ª×ª ×¡×™×‘×” ×”×—×•×“×© ×œ×× ×”×œ ×©×œ×š ×œ×ª×ª ×œ×š ×‘×•× ×•×¡ ×›×¡×¤×™?";
    // Set followup questions for bonus
    powerupFollowupQuestions = [...bonusQuestions];
    // Shuffle the questions to get random ones each time
    for (let i = powerupFollowupQuestions.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [powerupFollowupQuestions[i], powerupFollowupQuestions[j]] = 
        [powerupFollowupQuestions[j], powerupFollowupQuestions[i]];
    }
    // Limit to 3 random questions
    powerupFollowupQuestions = powerupFollowupQuestions.slice(0, 3);
    
    // Reset button text
    acceptBtn.textContent = "×›×Ÿ";
    ignoreBtn.textContent = "×œ×";
    break;
case 'companion':
    powerupTitle.textContent = "ğŸ‘« ×©××œ×ª ×™×“×¢: ×ª××™×›×” ×—×‘×¨×ª×™×ª";
    question = "××“×•×¢ ×—×©×•×‘ ×©×™×”×™×” ××™×ª×š ×—×‘×¨ ×‘×“×¨×š ×œ××˜×¨×•×ª ×”×¤×™× × ×¡×™×•×ª ×©×œ×š?";
    
    if(Math.random() < 0.5) {
        acceptBtn.textContent = "×”×¦×•×¨×š ×‘×”×•×¦××•×ª ×¨×’×©×™×•×ª ×•×¤×™×¦×•×™×™× ×¢×¦××™×™× ×™×•×¨×“ ××©××¢×•×ª×™×ª";
        ignoreBtn.textContent = "×›×“×™ ×©×™×”×™×” ×¢× ××™ ×œ×‘×–×‘×– ×›×¡×£ ×•×œ×”×©×•×•×™×¥ ×‘×¨×›×™×©×•×ª ×—×“×©×•×ª";
        powerup.correctButton = 'powerup-yes-btn';
    } else {
        acceptBtn.textContent = "×›×“×™ ×©×™×”×™×” ×¢× ××™ ×œ×‘×–×‘×– ×›×¡×£ ×•×œ×”×©×•×•×™×¥ ×‘×¨×›×™×©×•×ª ×—×“×©×•×ª";
        ignoreBtn.textContent = "×”×¦×•×¨×š ×‘×”×•×¦××•×ª ×¨×’×©×™×•×ª ×•×¤×™×¦×•×™×™× ×¢×¦××™×™× ×™×•×¨×“ ××©××¢×•×ª×™×ª";
        powerup.correctButton = 'powerup-no-btn';
    }
    
    powerup.explanation = "×œ×™×•×•×™ ×—×‘×¨×ª×™ ××—×–×§ ××ª ×”×™×›×•×œ×ª ×œ×“×—×•×ª ×¡×™×¤×•×§×™× ×•××•× ×¢ ×‘×–×‘×•×– ××™×•×ª×¨ ×¢×œ ×¤×™×¦×•×™×™× ×¨×’×©×™×™×";
    powerupFollowupQuestions = [];
    break;
    }
    
    // Set dialog content
    document.getElementById('powerup-text').textContent = question;
    
    // Add special styling based on powerup type
    const dialogBox = document.getElementById('powerup-dialog');
    
    // Reset any previous custom styling
    dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
    
    // Add type-specific styling
    switch(powerup.type) {
        case 'exercise':
            dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
            break;
        case 'healthyFood':
            dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)';
            break;
        case 'money':
            dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.3)';
            break;
        case 'companion':
            dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.4)';
            break;
    }
    
    // ×™×¦×™×¨×ª ×©×›×‘×ª ×”××¤×œ×” ×××—×•×¨×™ ×”×“×™××œ×•×’
    const dialogOverlay = createDialogOverlay();
    currentPowerup.dialogOverlay = dialogOverlay;
    
    // ×©×™× ×•×™ ×”Ö¾z-index ×›×“×™ ×œ×”×‘×˜×™×— ×©×”×“×™××œ×•×’ ×™×”×™×” ××¢×œ ×©×›×‘×ª ×”××¤×œ×”
    dialogBox.style.zIndex = '100';
    
    // Show dialog
    dialogBox.style.display = 'block';
}
        
        // Handle powerup yes response
function powerupYesResponse() {
    if (!currentPowerup) return;
    
    // If this is a bonus with followup questions
    if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
        // Show positive feedback
        showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].positiveEffect, 2500);
        
        // Show next question
        const questionText = document.getElementById('powerup-text');
        questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
        
        // Reset button text for followup questions
        document.getElementById('powerup-yes-btn').textContent = "×›×Ÿ";
        document.getElementById('powerup-no-btn').textContent = "×œ×";
        
        powerupFollowupIndex++;
        return;
    }
    
    // Check if the answer is correct (for all except money)
    if (currentPowerup.type !== 'money' && currentPowerup.correctButton) {
        if (currentPowerup.correctButton === 'powerup-yes-btn') {
            // Answer is correct
            showPopupMessage("×ª×©×•×‘×” × ×›×•× ×”!", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // Apply the powerup effect based on the type
            stats.powerupsCollected++;
            
            // Apply power-up effects after showing feedback
            setTimeout(() => {
                applyPowerupEffect(currentPowerup);
            }, 1000);
        } else {
            // Answer is wrong
            showPopupMessage("×ª×©×•×‘×” ×©×’×•×™×”", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // No power-up benefit for wrong answer
        }
        
        // ×”×¡×¨×ª ×©×›×‘×ª ×”××¤×œ×”
        if (currentPowerup && currentPowerup.dialogOverlay) {
            if (currentPowerup.dialogOverlay.parentNode) {
                currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
            }
        }
        
        // Hide dialog
        const dialogBox = document.getElementById('powerup-dialog');
        dialogBox.style.display = 'none';
        currentPowerup = null;
        gamePaused = false;
        
        // Update display
        updatePlayerCondition();
        updateDisplay();
        
        return;
    }
    
    // Apply the powerup effect based on the type for money
    stats.powerupsCollected++;
    
    if (currentPowerup.type === 'money') {
        let bonusAmount = currentPowerup.value;
        // If player answered followup questions, provide bigger bonus
        if (powerupFollowupQuestions.length > 0) {
            bonusAmount = Math.round(bonusAmount * (1 + 0.2 * powerupFollowupIndex));
        }
        
        score += bonusAmount;
        stats.income += bonusAmount / 5; // Distribute the bonus over time
        
        // Enhance the bonus popup with animation
        showCoinAnimation(bonusAmount);
        showPopupMessage(`×§×™×‘×œ×ª ×‘×•× ×•×¡ ×©×œ ${bonusAmount} ×©"×—!`, 2000);
    }
    
    // ×”×¡×¨×ª ×©×›×‘×ª ×”××¤×œ×”
    if (currentPowerup && currentPowerup.dialogOverlay) {
        if (currentPowerup.dialogOverlay.parentNode) {
            currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
        }
    }
    
    // Hide dialog
    const dialogBox = document.getElementById('powerup-dialog');
    dialogBox.style.display = 'none';
    currentPowerup = null;
    gamePaused = false;
    
    // Update display
    updatePlayerCondition();
    updateDisplay();
}

// Apply power-up effect (helper function)
function applyPowerupEffect(powerup) {
    switch(powerup.type) {
        case 'earlyRise':
        case 'earlySleep':
            player.powerUp = true;
            player.powerUpTime = maxPowerUpTime;
            player.powerUpType = powerup.type;
            document.getElementById('power-meter').style.display = 'block';
            
            // Improve mental health
            stats.mentalHealth = Math.min(100, stats.mentalHealth + powerup.mentalEffect);
            
            // Enhanced visual effect
            showMentalBoostEffect();
            showPopupMessage(`×—×™×–×•×§ ×¤×¢×™×œ: ${powerup.type === 'earlyRise' ? '× ×™×”×•×œ ×–××Ÿ ×™×¢×™×œ' : '×”×¨×’×œ×™ ×©×™× ×” ×˜×•×‘×™×'}`, 2000);
            break;
        case 'healthyFood':
        case 'exercise':
            player.powerUp = true;
            player.powerUpTime = maxPowerUpTime;
            player.powerUpType = powerup.type;
            document.getElementById('power-meter').style.display = 'block';
            
            // Improve physical health
            stats.physicalHealth = Math.min(100, stats.physicalHealth + powerup.healthEffect);
            
            // Enhanced visual effect
            showPhysicalBoostEffect();
            showPopupMessage(`×—×™×–×•×§ ×¤×¢×™×œ: ${powerup.type === 'healthyFood' ? '×ª×–×•× ×” ×××•×–× ×ª' : '×›×•×©×¨ ×’×•×¤× ×™'}`, 2000);
            break;
        case 'companion':
            player.companion = true;
            player.powerUp = true;
            player.powerUpTime = maxPowerUpTime * 2; // Companion lasts longer
            player.powerUpType = 'companion';
            document.getElementById('power-meter').style.display = 'block';
            
            // Companion helps with both mental and physical health
            stats.mentalHealth = Math.min(100, stats.mentalHealth + 15);
            stats.physicalHealth = Math.min(100, stats.physicalHealth + 15);
            
            // Enhanced visual effect
            showCompanionJoinEffect();
            showPopupMessage("×ª××™×›×” ×—×‘×¨×ª×™×ª ××—×–×§×ª ××ª ×”×—×•×¡×Ÿ ×”××™×©×™!", 2500);
            break;
    }
}
        
        // Helper function for coin animation
        function showCoinAnimation(amount) {
            // Create 5-10 animated coins based on amount size
            const coinCount = Math.min(10, Math.max(5, Math.floor(amount / 500)));
            
            for (let i = 0; i < coinCount; i++) {
                const coin = document.createElement('div');
                coin.className = 'animated-coin';
                
                // Style the coin
                coin.style.position = 'absolute';
                coin.style.width = '30px';
                coin.style.height = '30px';
                coin.style.borderRadius = '50%';
                coin.style.backgroundColor = '#FFD700';
                coin.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.7)';
                coin.style.zIndex = '30';
                coin.style.display = 'flex';
                coin.style.justifyContent = 'center';
                coin.style.alignItems = 'center';
                coin.style.color = '#333';
                coin.style.fontWeight = 'bold';
                coin.style.fontSize = '16px';
                coin.textContent = 'â‚ª';
                
                // Position at center of screen initially
                coin.style.top = '50%';
                coin.style.left = '50%';
                
                // Add to game container
                document.getElementById('game-container').appendChild(coin);
                
                // Animate coin
                const randomX = Math.random() * 200 - 100; // -100 to 100
                const randomY = Math.random() * 100 - 150; // -150 to -50 (upward)
                const randomDelay = Math.random() * 200;
                
                // Create dynamic keyframes for each coin
                const keyframes = `
                    @keyframes coin-move-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        10% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 1;
                        }
                        60% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY}px)) scale(1);
                            opacity: 1;
                        }
                        100% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY - 50}px)) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific coin
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    coin.style.animation = `coin-move-${i} 1.5s ease-out forwards`;
                }, randomDelay);
                
                // Remove coin after animation
                setTimeout(() => {
                    if (coin.parentNode) {
                        coin.parentNode.removeChild(coin);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, 1800 + randomDelay);
            }
            
            // Show total amount animation
            const totalAmount = document.createElement('div');
            totalAmount.className = 'total-bonus';
            totalAmount.style.position = 'absolute';
            totalAmount.style.top = '40%';
            totalAmount.style.left = '50%';
            totalAmount.style.transform = 'translate(-50%, -50%)';
            totalAmount.style.fontSize = '36px';
            totalAmount.style.fontWeight = 'bold';
            totalAmount.style.color = '#FFD700';
            totalAmount.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            totalAmount.style.zIndex = '31';
            totalAmount.style.opacity = '0';
            totalAmount.textContent = `+${amount} â‚ª`;
            
            document.getElementById('game-container').appendChild(totalAmount);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes total-bonus-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation with delay
            setTimeout(() => {
                totalAmount.style.animation = 'total-bonus-anim 2s ease-out forwards';
            }, 300);
            
            // Remove elements after animation
            setTimeout(() => {
                if (totalAmount.parentNode) {
                    totalAmount.parentNode.removeChild(totalAmount);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
        }
        
        // Mental boost visual effect
        function showMentalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'mental-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(42, 100, 150, 0.3) 0%, rgba(42, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes mental-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'mental-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Physical boost visual effect
        function showPhysicalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'physical-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(58, 122, 95, 0.3) 0%, rgba(58, 122, 95, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes physical-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'physical-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Companion join visual effect
        function showCompanionJoinEffect() {
            // Create multiple particles effect
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'companion-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
                particle.style.zIndex = '25';
                
                // Position around player
                particle.style.top = `${player.y + player.height / 2}px`;
                particle.style.left = `${player.x + player.width / 2}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create dynamic animation for each particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const duration = 0.8 + Math.random() * 0.7;
                const delay = Math.random() * 0.3;
                const size = 5 + Math.random() * 10;
                
                // Update size
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // Create specific keyframes for this particle
                const keyframes = `
                    @keyframes companion-particle-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        20% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 0.8;
                        }
                        100% {
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific particle
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    particle.style.animation = `companion-particle-${i} ${duration}s ease-out forwards`;
                }, delay * 1000);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, (delay + duration + 0.1) * 1000);
            }
            
            // Add companion icon
            const icon = document.createElement('div');
            icon.className = 'companion-icon';
            icon.style.position = 'absolute';
            icon.style.top = `${player.y - 40}px`;
            icon.style.left = `${player.x + player.width / 2}px`;
            icon.style.transform = 'translate(-50%, -50%)';
            icon.style.fontSize = '30px';
            icon.style.opacity = '0';
            icon.style.zIndex = '26';
            icon.textContent = 'ğŸ‘«';
            
            document.getElementById('game-container').appendChild(icon);
            
            // Define animation for icon
            const iconStyle = document.createElement('style');
            iconStyle.textContent = `
                @keyframes companion-icon-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -80px) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -100px) scale(0.8); }
                }
            `;
            document.head.appendChild(iconStyle);
            
            // Apply animation
            icon.style.animation = 'companion-icon-anim 2s ease-out forwards';
            
            // Remove icon after animation
            setTimeout(() => {
                if (icon.parentNode) {
                    icon.parentNode.removeChild(icon);
                }
                if (iconStyle.parentNode) {
                    iconStyle.parentNode.removeChild(iconStyle);
                }
            }, 2000);
        }
        // Handle powerup no response
function powerupNoResponse() {
    if (!currentPowerup) return;
    
    // If this is a bonus with followup questions
    if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
        // Show negative feedback
        showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].negativeEffect, 2500);
        
        // Show next question
        const questionText = document.getElementById('powerup-text');
        questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
        
        // Reset button text for followup questions
        document.getElementById('powerup-yes-btn').textContent = "×›×Ÿ";
        document.getElementById('powerup-no-btn').textContent = "×œ×";
        
        powerupFollowupIndex++;
        return;
    }
    
    // Check if the answer is correct (for all except money)
    if (currentPowerup.type !== 'money' && currentPowerup.correctButton) {
        if (currentPowerup.correctButton === 'powerup-no-btn') {
            // Answer is correct
            showPopupMessage("×ª×©×•×‘×” × ×›×•× ×”!", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // Apply the powerup effect based on the type
            stats.powerupsCollected++;
            
            // Apply power-up effects after showing feedback
            setTimeout(() => {
                applyPowerupEffect(currentPowerup);
            }, 1000);
        } else {
            // Answer is wrong
            showPopupMessage("×ª×©×•×‘×” ×©×’×•×™×”", 2000);
            setTimeout(() => {
                showPopupMessage(currentPowerup.explanation, 3000);
            }, 2200);
            
            // Apply negative effect for wrong answer
            switch(currentPowerup.type) {
                case 'exercise':
                case 'healthyFood':
                    // Decrease physical health
                    stats.physicalHealth = Math.max(20, stats.physicalHealth - 10);
                    showNegativePhysicalEffect();
                    break;
                case 'earlyRise':
                case 'earlySleep':
                    // Decrease mental health
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 10);
                    showNegativeMentalEffect();
                    break;
                case 'companion':
                    // Decrease mental health (lighter effect)
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 5);
                    showNegativeMentalEffect();
                    break;
            }
        }
        
        // ×”×¡×¨×ª ×©×›×‘×ª ×”××¤×œ×”
        if (currentPowerup && currentPowerup.dialogOverlay) {
            if (currentPowerup.dialogOverlay.parentNode) {
                currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
            }
        }
        
        // Hide dialog
        const dialogBox = document.getElementById('powerup-dialog');
        dialogBox.style.display = 'none';
        currentPowerup = null;
        gamePaused = false;
        
        // Update display
        updatePlayerCondition();
        updateDisplay();
        
        return;
    }
    
    // Apply negative effect based on type for money
    if (currentPowerup.type === 'money') {
        // No bonus for poor performance
        showPopupMessage("×¤×¡×¤×¡×ª ×”×–×“×× ×•×ª ×œ×©×™×¤×•×¨ ××¦×‘×š ×”×¤×™× × ×¡×™", 2500);
        // Show subtle negative effect
        showMissedOpportunityEffect();
    }
    
    // ×”×¡×¨×ª ×©×›×‘×ª ×”××¤×œ×”
    if (currentPowerup && currentPowerup.dialogOverlay) {
        if (currentPowerup.dialogOverlay.parentNode) {
            currentPowerup.dialogOverlay.parentNode.removeChild(currentPowerup.dialogOverlay);
        }
    }
    
    // Hide dialog
    const dialogBox = document.getElementById('powerup-dialog');
    dialogBox.style.display = 'none';
    currentPowerup = null;
    gamePaused = false;
    
    // Update display
    updatePlayerCondition();
    updateDisplay();
}
        
        // Visual effect for negative physical impact
        function showNegativePhysicalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-physical-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(212, 91, 91, 0.2) 0%, rgba(212, 91, 91, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-physical {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-physical 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for negative mental impact
        function showNegativeMentalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-mental-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(100, 100, 150, 0.2) 0%, rgba(100, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-mental {
                    0% { opacity: 0; }
                    30% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-mental 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for missed opportunity
        function showMissedOpportunityEffect() {
            const effect = document.createElement('div');
            effect.className = 'missed-opportunity';
            effect.style.position = 'absolute';
            effect.style.top = '40%';
            effect.style.left = '50%';
            effect.style.transform = 'translate(-50%, -50%)';
            effect.style.color = 'rgba(150, 150, 150, 0.8)';
            effect.style.fontSize = '40px';
            effect.style.fontWeight = 'bold';
            effect.style.zIndex = '25';
            effect.style.opacity = '0';
            effect.style.textShadow = '0 0 10px rgba(150, 150, 150, 0.5)';
            effect.innerHTML = '<span style="text-decoration: line-through;">â‚ª</span>';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes missed-opportunity {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'missed-opportunity 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Handle applying powerup directly
// For modern gameplay with interaction, show dialog instead of direct application
function applyPowerup(powerup) {
    // Reset button text before showing dialog
    resetPowerupDialogButtons();
    
    // For modern gameplay with interaction, show dialog instead of direct application
    showPowerupDialog(powerup);
    return;
}
        
        // Show obstacle dialog with enhanced animation
function showObstacleDialog(obstacle) {
    // Pause the game
    gamePaused = true;
    isMoving = false; // ×¢×¦×™×¨×ª ×”×ª× ×•×¢×” ×‘××•×¤×Ÿ ××•×—×œ×˜
    currentObstacle = obstacle;
    persuasionStage = 0; // Reset persuasion stage
    
    // Set dialog content - initial stage
    document.getElementById('obstacle-title').textContent = obstacle.obstacleTitle;
    document.getElementById('obstacle-text').textContent = obstacle.initialText;
    
    // Change button text based on obstacle type
    if (obstacle.type === 'thought') {
        // For thought obstacles, show only one button with custom text
document.getElementById('ignore-btn').style.display = "none"; // ×”×¡×ª×¨×ª ×›×¤×ª×•×¨ ×™×× ×™
document.getElementById('accept-btn').textContent = obstacle.acceptOption || "××™××•×¥ ×”××—×©×‘×”";
document.getElementById('accept-btn').style.width = "100%"; // ×”×¨×—×‘×ª ×”×›×¤×ª×•×¨ ×”× ×©××¨
document.getElementById('accept-btn').style.backgroundColor = "var(--primary-color)"; // ×©××™×¨×” ×¢×œ ×¦×‘×¢ ××—×™×“
    } else if (obstacle.type === 'companion_msg') {
        // For companion messages, also show only one button
document.getElementById('ignore-btn').style.display = "none";
document.getElementById('accept-btn').textContent = "×ª×•×“×” ×¢×œ ×”×¢×™×“×•×“!";
document.getElementById('accept-btn').style.width = "100%";
document.getElementById('accept-btn').style.backgroundColor = "var(--primary-color)"; // ×©××™×¨×” ×¢×œ ×¦×‘×¢ ××—×™×“
    } else if (obstacle.type === 'financial_question') {
        // For financial questions, change button text to the answer options
        const question = obstacle.questionData;
        
        // Randomize which button gets the correct answer
        if (Math.random() < 0.5) {
            document.getElementById('ignore-btn').textContent = question.correctAnswer;
            document.getElementById('accept-btn').textContent = question.wrongAnswer;
            // Mark which button has the correct answer
            obstacle.correctButton = 'ignore-btn';
        } else {
            document.getElementById('ignore-btn').textContent = question.wrongAnswer;
            document.getElementById('accept-btn').textContent = question.correctAnswer;
            // Mark which button has the correct answer
            obstacle.correctButton = 'accept-btn';
        }
    } else {
        // For regular obstacles with custom button text
        if (obstacle.ignoreOption && obstacle.acceptOption) {
            document.getElementById('ignore-btn').textContent = obstacle.ignoreOption;
            document.getElementById('accept-btn').textContent = obstacle.acceptOption;
        } else {
            // Fallback to default text
            document.getElementById('ignore-btn').textContent = "×¡×™×¨×•×‘";
            document.getElementById('accept-btn').textContent = "×”×¡×›××”";
        }
    }
    
    // Enhanced visual styling based on obstacle type
    const dialogBox = document.getElementById('obstacle-dialog');
    
    // Reset any previous custom styling
    dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
    
    // Add type-specific styling
    switch(obstacle.type) {
        case 'person':
            dialogBox.style.boxShadow = '0 5px 20px rgba(100, 100, 150, 0.3)';
            break;
        case 'ad':
            dialogBox.style.boxShadow = '0 5px 20px rgba(73, 80, 87, 0.3)';
            break;
        case 'food':
            dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
            break;
        case 'thought':
            dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)';
            break;
        case 'companion_msg':
            dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.3)';
            break;
        case 'financial_question':
            dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)'; // ×™×¨×•×§ ×œ×©××œ×•×ª ×¤×™× × ×¡×™×•×ª
            break;
    }
    
    // ×™×¦×™×¨×ª ×©×›×‘×ª ×”××¤×œ×” ×××—×•×¨×™ ×”×“×™××œ×•×’
    const dialogOverlay = createDialogOverlay();
    currentObstacle.dialogOverlay = dialogOverlay;
    
    // ×©×™× ×•×™ ×”Ö¾z-index ×›×“×™ ×œ×”×‘×˜×™×— ×©×”×“×™××œ×•×’ ×™×”×™×” ××¢×œ ×©×›×‘×ª ×”××¤×œ×”
    dialogBox.style.zIndex = '100';
    
    // Show dialog
    dialogBox.style.display = 'block';
    
    // Add appropriate overlay effect based on type
    let overlayColor = 'rgba(200, 50, 50, 0.1)'; // Default red for negative obstacles
    
    // Change color for positive obstacles
    if (obstacle.type === 'thought') {
        overlayColor = 'rgba(58, 122, 95, 0.1)'; // Green for thoughts
    } else if (obstacle.type === 'companion_msg') {
        overlayColor = 'rgba(42, 100, 150, 0.1)'; // Blue for companion messages
    } else if (obstacle.type === 'financial_question') {
        overlayColor = 'rgba(58, 122, 95, 0.1)'; // Green for financial questions
    }
    
    const warningOverlay = document.createElement('div');
    warningOverlay.className = 'warning-overlay';
    warningOverlay.style.position = 'absolute';
    warningOverlay.style.top = '0';
    warningOverlay.style.left = '0';
    warningOverlay.style.width = '100%';
    warningOverlay.style.height = '100%';
    warningOverlay.style.backgroundColor = overlayColor;
    warningOverlay.style.opacity = '0';
    warningOverlay.style.transition = 'opacity 0.5s ease';
    warningOverlay.style.zIndex = '15';
    warningOverlay.style.pointerEvents = 'none';
    
    document.getElementById('game-container').appendChild(warningOverlay);
    
    // Fade in the overlay
    setTimeout(() => {
        warningOverlay.style.opacity = '1';
    }, 100);
    
    // Store reference to remove later
    currentObstacle.warningOverlay = warningOverlay;
    
    // Add an icon animation near the obstacle position
    if (obstacle.x && obstacle.y) {
        const iconElement = document.createElement('div');
        iconElement.className = 'obstacle-icon';
        iconElement.style.position = 'absolute';
        iconElement.style.top = `${obstacle.y - 40}px`;
        iconElement.style.left = `${obstacle.x}px`;
        iconElement.style.fontSize = '24px';
        iconElement.style.zIndex = '16';
        iconElement.style.opacity = '0.9';
        
        // Set icon based on obstacle type
        if (obstacle.type === 'thought') {
            iconElement.textContent = 'ğŸ’­'; // Thought bubble
            iconElement.style.color = '#3a7a5f';
        } else if (obstacle.type === 'companion_msg') {
            iconElement.textContent = 'ğŸ‘«'; // Companion
            iconElement.style.color = '#2a6496';
        } else if (obstacle.type === 'financial_question') {
            iconElement.textContent = 'â“'; // Question mark
            iconElement.style.color = '#3a7a5f';
        } else {
            iconElement.textContent = 'âš ï¸'; // Warning
            iconElement.style.color = 'red';
        }
        
        iconElement.style.animation = 'warning-bounce 0.8s infinite alternate';
        
        document.getElementById('game-container').appendChild(iconElement);
        
        // Add animation style if not already defined
        if (!document.getElementById('warning-animation-style')) {
            const style = document.createElement('style');
            style.id = 'warning-animation-style';
            style.textContent = `
                @keyframes warning-bounce {
                    from { transform: translateY(0); }
                    to { transform: translateY(-10px); }
                }
            `;
            document.head.appendChild(style);
        }
        
        // Store reference to remove later
        currentObstacle.warningIcon = iconElement;
    }
}
        
        // Continue to next persuasion stage with enhanced visuals
function continuePersuasion() {
    if (!currentObstacle) return;
    
    persuasionStage++;
    
    // Special handling for thought, companion obstacles, and financial questions
    if (currentObstacle.type === 'thought' || currentObstacle.type === 'companion_msg' || currentObstacle.type === 'financial_question') {
        // Close the dialog
        hideObstacleDialog();
        
        // Small mental boost for acknowledging positive messages
        stats.mentalHealth = Math.min(100, stats.mentalHealth + 2);
        updatePlayerCondition();
        
        if (currentObstacle.type === 'thought') {
            // Score boost for adopting financial thinking
            score += currentObstacle.value || 500;
            
            // Show custom message with the adopted thought option
            showPopupMessage("××™××¦×ª ××ª ×”××—×©×‘×”: " + currentObstacle.acceptOption, 2500);
        } else if (currentObstacle.type === 'companion_msg') {
            showPopupMessage("×”×§×©×‘×ª ×œ×—×‘×¨ ×©×œ×š!", 2000);
        } else if (currentObstacle.type === 'financial_question') {
    // Check if answer is correct (the user clicked 'ignore-btn')
    if (currentObstacle.correctButton === 'ignore-btn') {
        // Removed score increase
        showPopupMessage("âœ… ×ª×©×•×‘×” × ×›×•× ×”!", 2000);
        
        // Show explanation
        setTimeout(() => {
            showPopupMessage("ğŸ’¡ " + currentObstacle.questionData.explanation, 3000);
        }, 2200);
    } else {
        showPopupMessage("âŒ ×ª×©×•×‘×” ×©×’×•×™×”", 2000);
        setTimeout(() => {
            showPopupMessage("ğŸ’¡ " + currentObstacle.questionData.explanation, 3000);
        }, 2200);
    }
}
        
        return;
    }
    
    // Regular persuasion flow for normal obstacles
    // Check if we have more persuasive texts
    if (persuasionStage <= currentObstacle.persuasiveTexts.length) {
        // Update text for current stage with animation
        const textElement = document.getElementById('obstacle-text');
        const ignoreBtn = document.getElementById('ignore-btn');
        const acceptBtn = document.getElementById('accept-btn');
        
        // Fade out current text and buttons
        textElement.style.transition = 'opacity 0.2s, transform 0.2s';
        textElement.style.opacity = '0';
        textElement.style.transform = 'translateY(-10px)';
        
        // After fade out, update text and fade in
        setTimeout(() => {
            // Check if persuasiveTexts is an array of objects or strings
            if (typeof currentObstacle.persuasiveTexts[0] === 'object') {
                // Using new format with custom button text
                const persuasion = currentObstacle.persuasiveTexts[persuasionStage - 1];
                textElement.textContent = persuasion.text;
                
                // Update button text if available
                if (persuasion.ignoreOption) {
                    ignoreBtn.textContent = persuasion.ignoreOption;
                }
                if (persuasion.acceptOption) {
                    acceptBtn.textContent = persuasion.acceptOption;
                }
            } else {
                // Legacy format (just text strings)
                textElement.textContent = currentObstacle.persuasiveTexts[persuasionStage - 1];
            }
            
            // Fade in new text
            textElement.style.transform = 'translateY(0)';
            textElement.style.opacity = '1';
        }, 200);
        
        // If this is the last stage, change the ignore button text
if (persuasionStage === currentObstacle.persuasiveTexts.length) {
    if (!currentObstacle.persuasiveTexts[persuasionStage - 1].ignoreOption) {
        ignoreBtn.textContent = "×”×—×œ×˜×” ×¡×•×¤×™×ª: ×¡×™×¨×•×‘";
    }
    ignoreBtn.style.fontWeight = 'bold';
    // ×©×™××•×¨ ×¦×‘×¢ ××—×™×“ ×œ×œ× ×©×™× ×•×™ ×‘×©×œ×‘ ×”××—×¨×•×Ÿ
    ignoreBtn.style.background = 'var(--primary-color)';
} else if (typeof currentObstacle.persuasiveTexts[0] !== 'object') {
    // Only reset if using legacy format
    ignoreBtn.textContent = "×¡×™×¨×•×‘";
}
        
        // Visual effect on each persuasion stage
        const persuasionEffect = document.createElement('div');
        persuasionEffect.className = 'persuasion-pulse';
        persuasionEffect.style.position = 'absolute';
        persuasionEffect.style.top = '0';
        persuasionEffect.style.left = '0';
        persuasionEffect.style.width = '100%';
        persuasionEffect.style.height = '100%';
        persuasionEffect.style.background = 'radial-gradient(circle at center, rgba(150, 50, 50, 0.1) 0%, rgba(150, 50, 50, 0) 70%)';
        persuasionEffect.style.opacity = '0';
        persuasionEffect.style.zIndex = '14';
        persuasionEffect.style.pointerEvents = 'none';
        
        document.getElementById('game-container').appendChild(persuasionEffect);
        
        // Define animation for persuasion pulse
        const pulseStyle = document.createElement('style');
        pulseStyle.textContent = `
            @keyframes persuasion-pulse {
                0% { opacity: 0; }
                50% { opacity: 1; }
                100% { opacity: 0; }
            }
        `;
        document.head.appendChild(pulseStyle);
        
        // Apply animation
        persuasionEffect.style.animation = 'persuasion-pulse 1s ease-out forwards';
        
        // Remove elements after animation
        setTimeout(() => {
            if (persuasionEffect.parentNode) {
                persuasionEffect.parentNode.removeChild(persuasionEffect);
            }
            if (pulseStyle.parentNode) {
                pulseStyle.parentNode.removeChild(pulseStyle);
            }
        }, 1000);
    } else {
        // If no more texts, close the dialog
        hideObstacleDialog();
        stats.obstaclesAvoided++; // Increment obstacle resistance counter
        
        // Small mental boost for fully resisting
        stats.mentalHealth = Math.min(100, stats.mentalHealth + 5);
        updatePlayerCondition();
        
        // Show resistance message
        showPopupMessage("×§×‘×œ×ª ×”×—×œ×˜×” ×¤×™× × ×¡×™×ª ××•×©×›×œ×ª!", 2500);
        
        // Add visual reinforcement for good decision
        showPositiveDecisionEffect();
    }
}
        
        // Visual effect for positive financial decision
        function showPositiveDecisionEffect() {
            // Create shield-like visual around player
            const shield = document.createElement('div');
            shield.className = 'decision-shield';
            shield.style.position = 'absolute';
            shield.style.top = `${player.y + player.height / 2}px`;
            shield.style.left = `${player.x + player.width / 2}px`;
            shield.style.width = '0';
            shield.style.height = '0';
            shield.style.borderRadius = '50%';
            shield.style.background = 'radial-gradient(circle, rgba(58, 122, 95, 0.2) 0%, rgba(58, 122, 95, 0) 70%)';
            shield.style.transform = 'translate(-50%, -50%)';
            shield.style.zIndex = '15';
            
            document.getElementById('game-container').appendChild(shield);
            
            // Define animation for expanding shield
            const shieldStyle = document.createElement('style');
            shieldStyle.textContent = `
                @keyframes shield-expand {
                    0% { width: 0; height: 0; opacity: 0; }
                    50% { width: 200px; height: 200px; opacity: 0.7; }
                    100% { width: 300px; height: 300px; opacity: 0; }
                }
            `;
            document.head.appendChild(shieldStyle);
            
            // Apply animation
            shield.style.animation = 'shield-expand 1.5s ease-out forwards';
            
            // Add checkmark icon
            const checkmark = document.createElement('div');
            checkmark.className = 'decision-checkmark';
            checkmark.style.position = 'absolute';
            checkmark.style.top = `${player.y - 30}px`;
            checkmark.style.left = `${player.x + player.width / 2}px`;
            checkmark.style.transform = 'translate(-50%, -50%)';
            checkmark.style.fontSize = '30px';
            checkmark.style.color = 'rgb(58, 122, 95)';
            checkmark.style.zIndex = '16';
            checkmark.style.opacity = '0';
            checkmark.textContent = 'âœ“';
            
            document.getElementById('game-container').appendChild(checkmark);
            
            // Define animation for checkmark
            const checkStyle = document.createElement('style');
            checkStyle.textContent = `
                @keyframes checkmark-appear {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
                    100% { opacity: 0; transform: translate(-50%, -130%) scale(1); }
                }
            `;
            document.head.appendChild(checkStyle);
            
            // Apply animation
            checkmark.style.animation = 'checkmark-appear 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (shield.parentNode) {
                    shield.parentNode.removeChild(shield);
                }
                if (shieldStyle.parentNode) {
                    shieldStyle.parentNode.removeChild(shieldStyle);
                }
                if (checkmark.parentNode) {
                    checkmark.parentNode.removeChild(checkmark);
                }
                if (checkStyle.parentNode) {
                    checkStyle.parentNode.removeChild(checkStyle);
                }
            }, 1500);
        }
        
        // Handle accepting obstacle with enhanced visuals
function acceptObstacle() {
    if (!currentObstacle) return;
    
    // Handle different obstacle types
    if (currentObstacle.type === 'thought') {
        // Positive effect for adopting financial thoughts
        score += currentObstacle.value;
        stats.mentalHealth = Math.min(100, stats.mentalHealth + currentObstacle.mentalEffect);
        showPopupMessage(`××™××¦×ª: ${currentObstacle.acceptOption}. +${currentObstacle.value} ×©"×—, +${currentObstacle.mentalEffect} ×—×•×¡×Ÿ ×× ×˜×œ×™`, 2500);
        showPositiveDecisionEffect();
    } else if (currentObstacle.type === 'companion_msg') {
        // Positive effect for accepting companion advice
        stats.mentalHealth = Math.min(100, stats.mentalHealth + currentObstacle.mentalEffect);
        showPopupMessage(`×§×™×‘×œ×ª ×¢×™×“×•×“ ××—×‘×¨×š: +${currentObstacle.mentalEffect} ×—×•×¡×Ÿ ×× ×˜×œ×™`, 2500);
        showPositiveDecisionEffect();
    } else if (currentObstacle.type === 'financial_question') {
        // Check if answer is correct (the user clicked 'accept-btn')
        if (currentObstacle.correctButton === 'accept-btn') {
            // Removed score increase
            showPopupMessage("×ª×©×•×‘×” × ×›×•× ×”!", 2000);
            
            // Show explanation
            setTimeout(() => {
                showPopupMessage(currentObstacle.questionData.explanation, 3000);
            }, 2200);
        } else {
            showPopupMessage("×ª×©×•×‘×” ×©×’×•×™×”", 2000);
            setTimeout(() => {
                showPopupMessage(currentObstacle.questionData.explanation, 3000);
            }, 2200);
        }
    } else {
        // Apply the negative effects for regular obstacles
        score -= currentObstacle.value;
        stats.expenses += currentObstacle.value;
        
        // Apply specific effects based on obstacle type
        if (currentObstacle.type === 'person') {
            stats.mentalHealth -= currentObstacle.mentalEffect;
            showPopupMessage(`×œ×—×¥ ×—×‘×¨×ª×™ ×”×©×¤×™×¢ ×¢×œ×™×š: -${currentObstacle.mentalEffect} × ×§×•×“×•×ª ×—×•×¡×Ÿ ×× ×˜×œ×™`, 2500);
            showNegativeMentalEffect();
        } else if (currentObstacle.type === 'food') {
            stats.physicalHealth -= currentObstacle.weightEffect;
            showPopupMessage(`×”×—×œ×˜×” ×ª×–×•× ×ª×™×ª ×œ× ××™×˜×‘×™×ª: -${currentObstacle.weightEffect} × ×§×•×“×•×ª ×‘×¨×™××•×ª`, 2500);
            showNegativePhysicalEffect();
        } else {
            showPopupMessage(`×”×•×¦××” ×‘×œ×ª×™ ××ª×•×›× × ×ª: ${currentObstacle.value} ×©"×—`, 2000);
            showMoneyLossEffect(currentObstacle.value);
        }
    }
    
    // Update obstacle interactions counter
    stats.obstaclesFaced++;
    
    // Update player condition
    updatePlayerCondition();
    updateDisplay();
    
    // Reset and continue game
    hideObstacleDialog();
    
    // Check if player is now bankrupt
    if (score < 0) {
        gameOver(`×”×××–×Ÿ ×”×©×œ×™×œ×™ ×”×•×‘×™×œ ×œ×§×¨×™×¡×” ×¤×™× × ×¡×™×ª. ×”×•×¦××ª ×™×•×ª×¨ ××“×™ ×¢×œ ${currentObstacle.text}`);
        return;
    }
    
    // Check if mental or physical health is too low
    if (stats.mentalHealth <= 20) {
        gameOver("×”×—×•×¡×Ÿ ×”×× ×˜×œ×™ ×©×œ×š × ×¤×’×¢ ××©××¢×•×ª×™×ª. ××™× ×š ××¡×•×’×œ ×œ×”××©×™×š.");
        return;
    }
    
    if (stats.physicalHealth <= 20) {
        gameOver("×‘×¨×™××•×ª×š ×”×¤×™×–×™×ª × ×¤×’×¢×” ×‘××•×¤×Ÿ ×—××•×¨. ×§×©×” ×œ×š ×œ×”××©×™×š ×‘×“×¨×š.");
        return;
    }
}
        
        // Visual effect for money loss
        function showMoneyLossEffect(amount) {
            // Create money loss text
            const lossText = document.createElement('div');
            lossText.className = 'money-loss';
            lossText.style.position = 'absolute';
            lossText.style.top = '40%';
            lossText.style.left = '50%';
            lossText.style.transform = 'translate(-50%, -50%)';
            lossText.style.fontSize = '36px';
            lossText.style.fontWeight = 'bold';
            lossText.style.color = '#d45b5b';
            lossText.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            lossText.style.zIndex = '30';
            lossText.style.opacity = '0';
            lossText.textContent = `-${amount} â‚ª`;
            
            document.getElementById('game-container').appendChild(lossText);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes money-loss-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, 0) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            lossText.style.animation = 'money-loss-anim 2s ease-out forwards';
            
            // Create falling coins for large amounts
            if (amount > 1000) {
                const coinCount = Math.min(8, Math.floor(amount / 500));
                
                for (let i = 0; i < coinCount; i++) {
                    const coin = document.createElement('div');
                    coin.className = 'falling-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '20px';
                    coin.style.height = '20px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#d45b5b';
                    coin.style.boxShadow = '0 0 5px rgba(212, 91, 91, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '12px';
                    coin.textContent = 'â‚ª';
                    
                    // Position at center of screen initially
                    coin.style.top = '40%';
                    coin.style.left = '50%';
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create dynamic animation for each coin
                    const fallDelay = Math.random() * 0.5;
                    const fallDuration = 1 + Math.random() * 0.5;
                    const horizontalOffset = (Math.random() * 200) - 100; // -100px to 100px
                    
                    // Create specific keyframes for this coin
                    const coinKeyframes = `
                        @keyframes coin-fall-${i} {
                            0% { 
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1); 
                            }
                            100% { 
                                opacity: 0;
                                transform: translate(calc(-50% + ${horizontalOffset}px), calc(-50% + 200px)) scale(0.5) rotate(${Math.random() * 360}deg); 
                            }
                        }
                    `;
                    
                    // Add style for this specific coin
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-fall-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDelay + fallDuration + 0.1) * 1000);
                }
            }
            
            // Remove elements after animation
            setTimeout(() => {
                if (lossText.parentNode) {
                    lossText.parentNode.removeChild(lossText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2000);
        }
        // Hide obstacle dialog and continue game with cleanup
function hideObstacleDialog() {
    const dialogBox = document.getElementById('obstacle-dialog');
    
    // ×”×¡×¨×ª ×©×›×‘×ª ×”××¤×œ×”
    if (currentObstacle && currentObstacle.dialogOverlay) {
        if (currentObstacle.dialogOverlay.parentNode) {
            currentObstacle.dialogOverlay.parentNode.removeChild(currentObstacle.dialogOverlay);
        }
    }
    
    // ×”×—×–×¨×ª ×”×§×œ×˜ ×œ××©×—×§
    document.getElementById('game-container').style.pointerEvents = 'auto';
    
    // ×”×¡×ª×¨×ª ×”×“×™××œ×•×’
    dialogBox.style.display = 'none';
    
    // ×”×¡×ª×¨×ª ×”××œ×× ×˜×™× ×”× ×•×¡×¤×™×
    if (currentObstacle && currentObstacle.warningOverlay) {
        currentObstacle.warningOverlay.style.opacity = '0';
        setTimeout(() => {
            if (currentObstacle.warningOverlay.parentNode) {
                currentObstacle.warningOverlay.parentNode.removeChild(currentObstacle.warningOverlay);
            }
        }, 500);
    }
    
    if (currentObstacle && currentObstacle.warningIcon) {
        if (currentObstacle.warningIcon.parentNode) {
            currentObstacle.warningIcon.parentNode.removeChild(currentObstacle.warningIcon);
        }
    }
    
    // ×©×—×¨×•×¨ ××©×—×§
    setTimeout(() => {
        currentObstacle = null;
        gamePaused = false;
        persuasionStage = 0;
        
        // Reset button styles to default
const ignoreBtn = document.getElementById('ignore-btn');
ignoreBtn.textContent = "×¡×™×¨×•×‘";
ignoreBtn.style.fontWeight = 'normal';
ignoreBtn.style.background = 'var(--primary-color)';
ignoreBtn.style.display = 'inline-block';
ignoreBtn.style.width = '';
        
        // Reset accept button too
        const acceptBtn = document.getElementById('accept-btn');
        acceptBtn.textContent = "×”×¡×›××”";
        acceptBtn.style.width = '';
    }, 300);
}

// Reset powerup dialog button text when dialog is hidden
function resetPowerupDialogButtons() {
    // Reset button text
    document.getElementById('powerup-yes-btn').textContent = "×›×Ÿ";
    document.getElementById('powerup-no-btn').textContent = "×œ×";
}
        
        // Collision detection
function checkCollision(obj1, obj2) {
    return obj1.x < obj2.x + obj2.width &&
           obj1.x + obj1.width > obj2.x &&
           obj1.y < obj2.y + obj2.height &&
           obj1.y + obj1.height > obj2.y;
}

// Check if a position is occupied by any existing object
function isPositionOccupied(newObj) {
    // ×”×’×“×¨ ××¨×•×•×— ××™× ×™××œ×™ ×‘×™×Ÿ ××•×‘×™×™×§×˜×™×
    const minSpacing = 20; // ××¨×•×•×— ××™× ×™××œ×™ ×©×œ 20 ×¤×™×§×¡×œ×™×
    
    // ×”×¨×—×‘ ××ª ×”××•×‘×™×™×§×˜ ×”×–×× ×™ ×œ×‘×“×™×§×” ×›×“×™ ×œ×“×¨×•×© ××¨×•×•×— ××™× ×™××œ×™
    const tempObj = {
        x: newObj.x - minSpacing,
        y: newObj.y - minSpacing,
        width: newObj.width + (minSpacing * 2),
        height: newObj.height + (minSpacing * 2)
    };
    
    // Check collision with existing obstacles
    for (let i = 0; i < obstacles.length; i++) {
        if (checkCollision(tempObj, obstacles[i])) {
            return true;
        }
    }
    
    // Check collision with existing powerups
    for (let i = 0; i < powerups.length; i++) {
        if (checkCollision(tempObj, powerups[i])) {
            return true;
        }
    }
    
    return false;
}
        
        // Handle obstacle hit
function hitObstacle(obstacle) {
    // See if enough time has passed since last obstacle dialog
    const now = Date.now();
    if (now - lastObstacleTime < minObstacleInterval) {
        // Too soon for another obstacle dialog
        return true;
    }
    
    // Show obstacle dialog with enhanced animation
    showObstacleDialog(obstacle);
    lastObstacleTime = now;
    
    // Play appropriate sound based on obstacle type
    if (obstacle.type === 'thought') {
        // Could add a positive thought sound here if you add sounds later
    } else if (obstacle.type === 'companion_msg') {
        // Could add a friendly message sound here if you add sounds later
    }
    
    return true; // Obstacle is handled (will be removed in the main loop)
}
        
        // Update game state
        function updateGame() {
    if (!gameRunning || gamePaused) return;
    
    // Update day/night cycle only if player is moving
    if (isMoving) {
        updateDayNightCycle();
    } else {
        // ×× ×”×©×—×§×Ÿ ×œ× ×–×–, ×¢×“×™×™×Ÿ × ×¢×“×›×Ÿ ××ª ×ª×¦×•×’×ª ×”×©×¢×•×Ÿ
        updateClockDisplay();
    }
    
    // ×¢×“×›×•×Ÿ ××¦×‘ ×”×›×¤×ª×•×¨ ×‘××•×¤×Ÿ ×“×™× ××™
    updateArrowButtonAttention();
    
    // ×”×§×•×“ ×œ×”×¦×’×ª ×˜×™×¤×™× ×¤×™× × ×¡×™×™× ×”×•×¡×¨ ×›×™×•×•×Ÿ ×©×”× ×¢×›×©×™×• ×—×œ×§ ×××¢×¨×›×ª ×”×©××œ×•×ª
    
    // Update month timer only if player is moving (pressing forward button)
    if (isMoving) {
        // Progress at speed adjusted to player condition
        currentMonthTimer += player.currentSpeed / player.baseSpeed;
    }
            
    if (currentMonthTimer >= framesPerMonth) {
        currentMonthTimer = 0;
        currentMonth++;
        stats.monthsPlayed++;
        
        // Add monthly income to score with animation
        score += stats.income;
        showMonthlyIncomeEffect();
        
        // Slightly recover mental and physical health each month
        stats.mentalHealth = Math.min(100, stats.mentalHealth + 2);
        stats.physicalHealth = Math.min(100, stats.physicalHealth + 2);
        updatePlayerCondition();
        
        // Reset monthly counters at the beginning of a new month
        monthlyObstacleCounter = {
            person: 0,
            ad: 0,
            food: 0
        };
        
        monthlyPowerupCounter = {
            money: 0,
            earlyRise: 0,
            earlySleep: 0,
            healthyFood: 0,
            exercise: 0,
            companion: 0
        };
        
        // Check win condition
        if (score >= 100000) {
            winGame();
            return;
        }
        
        // Update display
        updateDisplay();
        
        // Show month transition animation
        showMonthTransitionEffect();
        
        // Maybe show job offer (15% chance each month)
        if (Math.random() < 0.15) {
            showJobOffer();
        }
        
        // Create monthly powerups
        const monthlyTypes = ['money', 'earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
        monthlyTypes.forEach(type => {
            // Schedule powerups throughout the month
            setTimeout(() => {
                createCustomPowerup(type);
            }, getRandomInt(5, monthDuration * 0.7) * 1000);
        });
        
        // Every 2 months, create a companion powerup
        if (currentMonth % 2 === 0) {
            setTimeout(() => {
                createCompanion();
            }, getRandomInt(10, monthDuration * 0.6) * 1000);
        }
        
    }
    
    // Update powerup status
    if (player.powerUp) {
        player.powerUpTime--;
        
        // Update power meter with smoother animation
        const powerFill = document.getElementById('power-meter-fill');
        const powerPercentage = (player.powerUpTime / maxPowerUpTime) * 100;
        powerFill.style.width = `${Math.min(100, powerPercentage)}%`;
        
        // Change color based on time remaining
        if (powerPercentage < 20) {
            powerFill.style.backgroundColor = 'var(--danger-color)';
        } else if (powerPercentage < 50) {
            powerFill.style.backgroundColor = 'var(--warning-color)';
        } else {
            powerFill.style.backgroundColor = 'var(--success-color)';
        }
        
        if (player.powerUpTime <= 0) {
            player.powerUp = false;
            player.companion = false;
            document.getElementById('power-meter').style.display = 'none';
            showPopupMessage("×”×©×¤×¢×ª ×”×—×™×–×•×§ ×”×¡×ª×™×™××”", 1500);
        }
    }
    
    // Update obstacles
    for (let i = obstacles.length - 1; i >= 0; i--) {
        const obstacle = obstacles[i];
        
        // Update position only if player is moving
        if (isMoving) {
            obstacle.x -= obstacle.speed;
            
            // Apply any obstacle-specific animations
            if (obstacle.bobSpeed) {
                obstacle.y = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 2;
            }
            
            // For ad obstacles, add pulsing effect
            if (obstacle.type === 'ad' && obstacle.pulseRate) {
                obstacle.pulseValue = (Math.sin(Date.now() * obstacle.pulseRate) + 1) / 2; // 0 to 1
            }
        }
        
        // Check for collision
        if (checkCollision(player, obstacle)) {
            const survived = hitObstacle(obstacle);
            obstacles.splice(i, 1);
            
            if (!survived) return; // Game over
        }
        
        // Remove if off-screen
        if (obstacle.x + obstacle.width < 0) {
            obstacles.splice(i, 1);
        }
    }
    
    // Update powerups
    for (let i = powerups.length - 1; i >= 0; i--) {
        const powerup = powerups[i];
        
        // Update position only if player is moving
        if (isMoving) {
            powerup.x -= powerup.speed;
            
            // Apply floating animation if available
            if (powerup.floatSpeed && powerup.originalY) {
                powerup.y = powerup.originalY + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
            }
        }
        
        // Check for collision
        if (checkCollision(player, powerup)) {
            // Apply powerup effect
            applyPowerup(powerup);
            powerups.splice(i, 1);
        }
        
        // Remove if off-screen
        if (powerup.x + powerup.width < 0) {
            powerups.splice(i, 1);
        }
    }
    
    // Maybe create a new obstacle (0.3% chance per frame - slower for longer game)
if (Math.random() < 0.003 && isMoving) {
    // Ensure there's enough distance from the last obstacle
    let canCreateObstacle = true;
    
    for (let i = 0; i < obstacles.length; i++) {
        if (obstacles[i].x > canvas.width - 450) { // Increased space between obstacles
            canCreateObstacle = false;
            break;
        }
    }
    
    // ×’× ×‘×“×•×§ ××¨×—×§ ××¤××•×•×¨-××¤×™× ×§×™×™××™×
    for (let i = 0; i < powerups.length; i++) {
        if (powerups[i].x > canvas.width - 300) { // ×œ× ×œ×™×¦×•×¨ ××›×©×•×œ ×§×¨×•×‘ ××“×™ ×œ×¤××•×•×¨-××¤
            canCreateObstacle = false;
            break;
        }
    }
    
    if (canCreateObstacle) {
        createObstacle();
    }
}

// Maybe create a new powerup (0.1% chance per frame - fewer powerups)
if (Math.random() < 0.001 && isMoving) {
    // Make sure powerups are spaced out
    let canCreatePowerup = true;
    
    for (let i = 0; i < powerups.length; i++) {
        if (powerups[i].x > canvas.width - 500) { // Increased space between powerups
            canCreatePowerup = false;
            break;
        }
    }
    
    // ×’× ×‘×“×•×§ ××¨×—×§ ×××›×©×•×œ×™× ×§×™×™××™×
    for (let i = 0; i < obstacles.length; i++) {
        if (obstacles[i].x > canvas.width - 300) { // ×œ× ×œ×™×¦×•×¨ ×¤××•×•×¨-××¤ ×§×¨×•×‘ ××“×™ ×œ××›×©×•×œ
            canCreatePowerup = false;
            break;
        }
    }
    
    if (canCreatePowerup) {
        createPowerup();
    }
}
    
    // Process any pending obstacles
    if (pendingObstacles.length > 0 && gameRunning && isMoving) {
        const now = Date.now();
        
        for (let i = pendingObstacles.length - 1; i >= 0; i--) {
            if (now >= pendingObstacles[i].time) {
                createObstacle();
                pendingObstacles.splice(i, 1);
            }
        }
    }
    
    // Render game
    renderGame();
    
    // Update game message time
    if (gameMessageTime > 0) {
        gameMessageTime--;
        if (gameMessageTime <= 0) {
            gameMessage = '';
        }
    }
}
        
        // Monthly income visual effect
        function showMonthlyIncomeEffect() {
            // Create income text effect
            const incomeText = document.createElement('div');
            incomeText.className = 'income-text';
            incomeText.style.position = 'absolute';
            incomeText.style.top = '40%';
            incomeText.style.left = '50%';
            incomeText.style.transform = 'translate(-50%, -50%)';
            incomeText.style.fontSize = '32px';
            incomeText.style.fontWeight = 'bold';
            incomeText.style.color = '#3a7a5f';
            incomeText.style.textShadow = '0 0 10px rgba(58, 122, 95, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            incomeText.style.zIndex = '30';
            incomeText.style.opacity = '0';
            incomeText.textContent = `+${stats.income.toLocaleString()} ×©"×— ××©×›×•×¨×ª ×—×•×“×©×™×ª`;
            
            document.getElementById('game-container').appendChild(incomeText);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes income-text-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            incomeText.style.animation = 'income-text-anim 2.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (incomeText.parentNode) {
                    incomeText.parentNode.removeChild(incomeText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
            
            // Show falling money for visual reinforcement
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'income-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '30px';
                    coin.style.height = '30px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#3a7a5f';
                    coin.style.boxShadow = '0 0 10px rgba(58, 122, 95, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '18px';
                    coin.textContent = 'â‚ª';
                    
                    // Position at top of screen
                    const startX = Math.random() * canvas.width;
                    coin.style.top = '-30px';
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation
                    const fallDuration = 1.5 + Math.random();
                    const fallDelay = Math.random() * 0.5;
                    const rotation = Math.random() * 360;
                    const endX = startX + (Math.random() * 200 - 100);
                    
                    const coinKeyframes = `
                        @keyframes coin-income-${i} {
                            0% { 
                                opacity: 1;
                                transform: translateY(0) rotate(0deg); 
                            }
                            80% {
                                opacity: 1;
                            }
                            100% { 
                                opacity: 0;
                                transform: translateY(${canvas.height}px) translateX(${endX - startX}px) rotate(${rotation}deg); 
                            }
                        }
                    `;
                    
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-income-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDuration + fallDelay + 0.1) * 1000);
                }, i * 100); // Stagger coin creation
            }
        }
        
        // Month transition effect
        function showMonthTransitionEffect() {
            // Create month transition overlay
            const overlay = document.createElement('div');
            overlay.className = 'month-transition';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            overlay.style.zIndex = '40';
            overlay.style.pointerEvents = 'none';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            // Create month text
            const monthText = document.createElement('div');
            monthText.style.fontSize = '48px';
            monthText.style.fontWeight = 'bold';
            monthText.style.color = 'rgba(42, 100, 150, 0)';
            monthText.style.textShadow = '0 0 20px rgba(42, 100, 150, 0.5)';
            monthText.style.opacity = '0';
            monthText.style.transform = 'scale(0.8)';
            monthText.style.transition = 'all 0.5s ease';
            monthText.textContent = monthNames[currentMonth];
            
            overlay.appendChild(monthText);
            document.getElementById('game-container').appendChild(overlay);
            
            // Animate the transition
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                monthText.style.opacity = '1';
                monthText.style.color = 'rgba(42, 100, 150, 1)';
                monthText.style.transform = 'scale(1.2)';
            }, 100);
            
            setTimeout(() => {
                monthText.style.opacity = '0';
                monthText.style.transform = 'scale(0.8)';
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            }, 1500);
            
            // Remove overlay after animation
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            }, 2000);
        }
        // Create a specific type of powerup with enhanced visuals
function createCustomPowerup(type) {
    let text = '';
    let width = 40;
    let height = 40;
    let value = 1000;
    let healthEffect = 0;
    let mentalEffect = 0;
    let color = '';
            
            switch(type) {
                case 'money':
                    text = "×‘×•× ×•×¡ ×›×¡×¤×™";
                    value = getRandomInt(1000, 3000);
                    color = "#2a6496"; // Blue
                    break;
                case 'earlyRise':
                    text = "×§×™××” ××•×§×“××ª";
                    mentalEffect = 10;
                    color = "#3a7a5f"; // Green
                    break;
                case 'earlySleep':
                    text = "×©×™× ×” ××•×§×“××ª";
                    mentalEffect = 15;
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "×ª×–×•× ×” ×‘×¨×™××”";
                    healthEffect = 15;
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "×¤×¢×™×œ×•×ª ×’×•×¤× ×™×ª";
                    healthEffect = 20;
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
        x: canvas.width,
        y: getRandomInt(ground.y - 150, ground.y - 60),
        width: width,
        height: height,
        type: type,
        speed: 4,
        text: text,
        value: value,
        healthEffect: healthEffect,
        mentalEffect: mentalEffect,
        color: color,
        animationOffset: Math.random() * Math.PI * 2,
        floatSpeed: 0.03 + Math.random() * 0.02,
        floatRange: 10 + Math.random() * 5,
        glowing: true,
        originalY: 0
    };
    
    // Store original Y for floating animation
    powerup.originalY = powerup.y;
    
    // ×‘×“×™×§×” ×× ×”×¤××•×•×¨-××¤ ×”×—×“×© ××ª× ×’×© ×¢× ××•×‘×™×™×§×˜×™× ×§×™×™××™×
    let attempts = 0;
    const maxAttempts = 5;
    let validPosition = false;
    
    while (!validPosition && attempts < maxAttempts) {
        // ×‘××™×“×ª ×”×¦×•×¨×š, ×©× ×” ××ª ××™×§×•× ×”-Y ×©×œ ×”×¤××•×•×¨-××¤
        if (attempts > 0) {
            const yOffset = (Math.random() - 0.5) * 120; // ×©×™× ×•×™ ××§×¨××™ ×‘×’×•×‘×” 
            powerup.y = getRandomInt(ground.y - 150, ground.y - 60) + yOffset;
            powerup.originalY = powerup.y; // ×¢×“×›×•×Ÿ ×”-originalY ×’× ×›×Ÿ
        }
        
        // ×‘×“×•×§ ×× ×”××™×§×•× ×”×—×“×© ×¤× ×•×™
        validPosition = !isPositionOccupied(powerup);
        attempts++;
    }
    
    powerups.push(powerup);
    
    // Visual cue for powerup arrival
    showPowerupArrivalCue(powerup);
        }
        
        // Visual cue for powerup arrival
        function showPowerupArrivalCue(powerup) {
            // Create a subtle flash at the edge where the powerup will appear
            const flash = document.createElement('div');
            flash.className = 'powerup-arrival-flash';
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '20px';
            flash.style.height = `${powerup.height * 1.5}px`;
            flash.style.borderRadius = '10px 0 0 10px';
            flash.style.zIndex = '9';
            flash.style.opacity = '0';
            
            // Set color based on powerup type
            switch(powerup.type) {
                case 'money':
                    flash.style.backgroundColor = 'rgba(42, 100, 150, 0.6)';
                    break;
                case 'earlyRise':
                case 'healthyFood':
                    flash.style.backgroundColor = 'rgba(58, 122, 95, 0.6)';
                    break;
                case 'earlySleep':
                    flash.style.backgroundColor = 'rgba(90, 90, 143, 0.6)';
                    break;
                case 'exercise':
                    flash.style.backgroundColor = 'rgba(211, 135, 62, 0.6)';
                    break;
                default:
                    flash.style.backgroundColor = 'rgba(100, 100, 100, 0.6)';
            }
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define animation for flash
            const style = document.createElement('style');
            style.textContent = `
                @keyframes powerup-arrival-flash {
                    0% { opacity: 0; width: 5px; }
                    50% { opacity: 0.8; width: 20px; }
                    100% { opacity: 0; width: 5px; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            flash.style.animation = 'powerup-arrival-flash 1s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1000);
        }
        
        // Render game with enhanced visuals
function renderGame() {
    try {
        // ×‘×“×™×§×” ×©×”×§× ×‘×¡ ×–××™×Ÿ ×•×‘×’×•×“×œ ×ª×§×™×Ÿ
        if (!canvas || canvas.width <= 0 || canvas.height <= 0) {
            console.error("Canvas not ready or has invalid dimensions");
            return;
        }
        
        // ×‘×“×™×§×” ×©×”×”×§×©×¨ ×©×œ ×”×§× ×‘×¡ ×–××™×Ÿ
        if (!ctx) {
            console.error("Canvas context not available");
            return;
        }
    
        // Clear canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        
        // × ×™×¡×™×•×Ÿ ×œ×¦×™×™×¨ ×¨×§×¢ ×‘×¡×™×¡×™ ×œ××§×¨×” ×©×œ ×›×©×œ ×‘×¤×•× ×§×¦×™×•×ª ×”××—×¨×•×ª
        try {
            // Draw sky with dynamic coloring based on time
            drawDynamicBackground();
        } catch (error) {
            console.error("Error in drawDynamicBackground:", error);
            // ×¤×ª×¨×•×Ÿ ×’×™×‘×•×™ - ×¨×§×¢ ×¤×©×•×˜
            ctx.fillStyle = "#87CEEB";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        
        try {
            // Draw subtle background patterns
            drawBackgroundPatterns();
        } catch (error) {
            console.error("Error in renderGame:", error);
        }
        
        // Draw ground
        const groundGradient = ctx.createLinearGradient(0, ground.y, 0, canvas.height);
        groundGradient.addColorStop(0, "#adb5bd");
        groundGradient.addColorStop(1, "#6c757d");
        ctx.fillStyle = groundGradient;
        ctx.fillRect(0, ground.y, ground.width, ground.height);
        
        // Draw "stable career path" text on the ground
        ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
        ctx.font = "bold 20px 'Open Sans', Arial";
        ctx.textAlign = "center";
        const text = "× ×ª×™×‘ ×§×¨×™×™×¨×” ×™×¦×™×‘";
        
        // ×‘×“×™×§×” ×©×”××“×™×“×” ×©×œ ×”×˜×§×¡×˜ ×ª×§×™× ×”
        let textWidth;
        try {
            textWidth = ctx.measureText(text).width;
        } catch (error) {
            console.error("Error measuring text:", error);
            textWidth = 200; // ×¢×¨×š ×‘×¨×™×¨×ª ××—×“×œ
        }
        
        // Create pattern with the text repeating across the ground
        const repetitions = Math.ceil(canvas.width / (textWidth + 100));
        
        for (let i = 0; i < repetitions; i++) {
            try {
                ctx.fillText(text, (textWidth + 100) * i + textWidth/2 + 50, ground.y + 40);
            } catch (error) {
                console.error("Error drawing text:", error);
            }
        }
            
            ctx.textAlign = "start";
            
            // Draw path edge with enhanced shadow
            const pathGlow = isDayTime ? 'rgba(73, 80, 87, 0.7)' : 'rgba(73, 80, 87, 0.9)';
            ctx.fillStyle = pathGlow;
            ctx.fillRect(0, ground.y, ground.width, 5);
            
            // Add subtle shadow/highlight to path edge based on time of day
            if (!isDayTime) {
                // Night shadow
                ctx.fillStyle = 'rgba(0, 0, 30, 0.3)';
                ctx.fillRect(0, ground.y + 5, ground.width, 3);
            } else {
                // Day highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(0, ground.y - 1, ground.width, 1);
            }
            
            // Draw player - enhanced style
            drawEnhancedPlayer();
            
            // Draw obstacles with enhanced visuals
            obstacles.forEach(obstacle => {
                switch(obstacle.type) {
                    case 'person':
    // Draw negative person as emoji with animation
    ctx.save();
    
    // Apply bobbing animation
    const personY = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 3;
    
    // Draw emoji
    ctx.font = `${obstacle.width}px Arial`;
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×

    // Randomly select one of several negative emojis
    if (!obstacle.emojiChar) {
        const negativeEmojis = ["ğŸ˜ ", "ğŸ˜’", "ğŸ™â€â™‚ï¸", "ğŸ™â€â™€ï¸", "ğŸ˜¤"];
        obstacle.emojiChar = negativeEmojis[Math.floor(Math.random() * negativeEmojis.length)];
    }

    ctx.fillText(obstacle.emojiChar, 
                obstacle.x + obstacle.width/2, 
                personY + obstacle.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
    
    // ×‘×•×¢×•×ª ×“×™×‘×•×¨ ×”×•×¡×¨×•
    break;
                        
    case 'ad':
    // Draw ad as emoji with pulsing effect
    ctx.save();
    
    const pulseScale = obstacle.pulseValue ? 1 + (obstacle.pulseValue * 0.1) : 1;
    const adX = obstacle.x;
    const adY = obstacle.y;
    
    // Draw emoji with pulsing effect
ctx.font = `${obstacle.width * pulseScale}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×

// Randomly select one of several ad emojis
if (!obstacle.emojiChar) {
    const adEmojis = ["ğŸ’°", "ğŸ’¸", "ğŸ¤‘", "ğŸ“¢", "ğŸ›’"];
    obstacle.emojiChar = adEmojis[Math.floor(Math.random() * adEmojis.length)];
}

ctx.fillText(obstacle.emojiChar, 
            adX + obstacle.width/2, 
            adY + obstacle.height/2);
    
    // Add sparkle effect on random positions
    if (Math.random() < 0.1) {
        const sparkleX = adX + Math.random() * obstacle.width;
        const sparkleY = adY + Math.random() * obstacle.height;
        
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.beginPath();
        ctx.arc(sparkleX, sparkleY, 1, 0, Math.PI * 2);
        ctx.fill();
    }
    
    ctx.textAlign = "start";
    ctx.restore();
    break;
                        
    case 'financial_question':
    // Draw financial question as emoji with special styling
    ctx.save();
    
    // Apply a subtle bobbing animation
    const questionY = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 3;
    
    // Draw glow effect
    ctx.shadowColor = 'rgba(58, 122, 95, 0.5)';
    ctx.shadowBlur = 10;
    ctx.shadowOffsetX = 0;
    ctx.shadowOffsetY = 0;
    
    // Draw question emoji
ctx.font = `${obstacle.width}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×

// Randomly select one of several question emojis
if (!obstacle.emojiChar) {
    const questionEmojis = ["â“", "ğŸ’­", "ğŸ“Š", "ğŸ“ˆ"];
    obstacle.emojiChar = questionEmojis[Math.floor(Math.random() * questionEmojis.length)];
}

ctx.fillText(obstacle.emojiChar, 
            obstacle.x + obstacle.width/2, 
            questionY + obstacle.height/2);
    
    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // Add shimmer effect
    const shimmerAngle = Date.now() * 0.002 % (Math.PI * 2);
    ctx.fillStyle = "rgba(255, 255, 255, 0.2)";
    ctx.beginPath();
    ctx.ellipse(
        obstacle.x + obstacle.width/2 + Math.cos(shimmerAngle) * obstacle.width/4,
        questionY + obstacle.height/2 + Math.sin(shimmerAngle) * obstacle.height/4,
        5, 5, 0, 0, Math.PI * 2
    );
    ctx.fill();
    
    // Add sparkle effects
    if (Math.random() < 0.05) {
        drawSparkle(
            obstacle.x + Math.random() * obstacle.width,
            questionY + Math.random() * obstacle.height,
            3, 'rgba(255, 255, 255, 0.7)'
        );
    }
    
    ctx.restore();
    break;
                        
                        case 'food':
    // Draw food as emoji with rotation effect
    ctx.save();
    
    // Apply rotation animation
    const foodRotation = obstacle.rotationSpeed ? Date.now() * obstacle.rotationSpeed : 0;
    ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
    ctx.rotate(Math.sin(foodRotation) * 0.05); // Subtle rotation
    
    // Draw food emoji
ctx.font = `${obstacle.width}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×

// Randomly select one of several food emojis
if (!obstacle.emojiChar) {
    const foodEmojis = ["ğŸ”", "ğŸ•", "ğŸ£", "ğŸ±", "ğŸ¥¡"];
    obstacle.emojiChar = foodEmojis[Math.floor(Math.random() * foodEmojis.length)];
}

ctx.fillText(obstacle.emojiChar, 0, 0);
    
    // Steam effect for hot food (only for certain emojis)
    if (Math.random() < 0.2 && (obstacle.emojiChar === "ğŸ”" || obstacle.emojiChar === "ğŸ•")) {
        ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
        ctx.lineWidth = 1;
        
        const steamHeight = 10 + Math.random() * 5;
        
        ctx.beginPath();
        ctx.moveTo(0, -obstacle.height/3);
        ctx.bezierCurveTo(
            -5, -obstacle.height/3 - steamHeight/2,
            5, -obstacle.height/3 - steamHeight,
            0, -obstacle.height/3 - steamHeight
        );
        ctx.stroke();
    }
    
    ctx.restore();
    break;
                        
    case 'thought':
    // Draw thought as emoji
    ctx.save();
    
    // Apply a subtle bobbing animation
    const thoughtY = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 3;
    
    // Draw thought emoji
ctx.font = `${obstacle.width}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×

// Use thought bubble emoji
ctx.fillText("ğŸ’­", 
            obstacle.x + obstacle.width/2, 
            thoughtY + obstacle.height/2);
    
    ctx.restore();
    break;
    
// ××§×¨×” ×‘×¨×™×¨×ª ×”××—×“×œ × ×©××¨ ××•×ª×• ×“×‘×¨ ×œ×˜×™×¤×•×œ ×‘××›×©×•×œ×™× ×©×œ× ×˜×•×¤×œ×• ××¤×•×¨×©×•×ª
default:
    // Default obstacle - minimalist style
    ctx.fillStyle = obstacle.color || "#6c757d";
    roundRect(ctx, obstacle.x, obstacle.y, obstacle.width, obstacle.height, 8, true, false);
    break;
                }
            });
            
            // Draw powerups with enhanced visuals
            powerups.forEach(powerup => {
                let fillColor = powerup.color || "#6c757d";
                
                // Draw the powerup with different shapes based on type
                if (powerup.type === 'money') {
    // Draw money bonus as emoji
    ctx.save();
    
    // Add glow effect
    if (powerup.glowing) {
        ctx.shadowColor = fillColor;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Get floating position
    const moneyY = powerup.y;
    
    // Draw money emoji with pulse animation
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×

// Pulsing animation
const pulseFactor = 1 + Math.sin(Date.now() * 0.005) * 0.2;
ctx.font = `${powerup.width * pulseFactor}px Arial`;

// Randomly select one of several money emojis
if (!powerup.emojiChar) {
    const moneyEmojis = ["ğŸ’°", "ğŸ’µ", "ğŸ’´", "ğŸ’¶", "ğŸ’·", "ğŸ‘›"];
    powerup.emojiChar = moneyEmojis[Math.floor(Math.random() * moneyEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            moneyY + powerup.height/2);
    
    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // Add sparkle effects
    if (Math.random() < 0.2) {
        drawSparkle(powerup.x + powerup.width/2, moneyY + powerup.height/2, 5, fillColor);
    }
    
    ctx.textAlign = "start";
    ctx.restore();
} else if (powerup.type === 'companion') {
    // Draw companion as emoji
    ctx.save();
    
    // Add glow effect
    if (powerup.glowing) {
        ctx.shadowColor = fillColor;
        ctx.shadowBlur = 10;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Add subtle floating animation
    const companionY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Draw companion emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several companion emojis
if (!powerup.emojiChar) {
    const companionEmojis = ["ğŸ‘«", "ğŸ‘¬", "ğŸ‘­", "ğŸ¤", "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"];
    powerup.emojiChar = companionEmojis[Math.floor(Math.random() * companionEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            companionY + powerup.height/2);
    
    // Reset shadow
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    
    // Emit particles for companion
    if (powerup.emitParticles && Math.random() < 0.1) {
        const particleX = powerup.x + powerup.width/2 + (Math.random() * 20 - 10);
        const particleY = companionY + (Math.random() * 10);
        
        drawPowerupParticle(particleX, particleY, fillColor);
    }
    
    ctx.textAlign = "start";
    ctx.restore();
} else {
                    // Draw other powerups - enhanced icons
                    
                    // Add glow effect
    if (powerup.glowing) {
        ctx.shadowColor = fillColor;
        ctx.shadowBlur = 8;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    ctx.fillStyle = fillColor;
    
    if (powerup.type === 'earlyRise') {
        // Draw early rise as emoji
        ctx.save();
        
        // Add subtle floating animation
        const riseY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
        
        // Draw early rise emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several early rise emojis
if (!powerup.emojiChar) {
    const earlyRiseEmojis = ["ğŸŒ…", "â°", "ğŸŒ"];
    powerup.emojiChar = earlyRiseEmojis[Math.floor(Math.random() * earlyRiseEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            riseY + powerup.height/2);
        
        ctx.textAlign = "start";
        ctx.restore();
    } else if (powerup.type === 'earlySleep') {
    // Draw early sleep as emoji
    ctx.save();
    
    // Add subtle floating animation
    const sleepY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Draw early sleep emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several early sleep emojis
if (!powerup.emojiChar) {
    const earlySleepEmojis = ["ğŸŒ™", "ğŸ’¤", "ğŸ˜´", "ğŸ›Œ"];
    powerup.emojiChar = earlySleepEmojis[Math.floor(Math.random() * earlySleepEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            sleepY + powerup.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
} else if (powerup.type === 'healthyFood') {
    // Draw healthy food as emoji
    ctx.save();
    
    // Add subtle floating animation
    const foodY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Draw healthy food emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several healthy food emojis
if (!powerup.emojiChar) {
    const healthyFoodEmojis = ["ğŸ¥—", "ğŸ¥¦", "ğŸ", "ğŸ¥", "ğŸ‰"];
    powerup.emojiChar = healthyFoodEmojis[Math.floor(Math.random() * healthyFoodEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2, 
            foodY + powerup.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
} else if (powerup.type === 'exercise') {
    // Draw exercise as emoji
    ctx.save();
    
    // Add subtle floating animation
    const exerciseY = powerup.y + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
    
    // Add subtle shake animation
    const exerciseShake = Math.sin(Date.now() * 0.01) * 2;
    
    // Draw exercise emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×
ctx.font = `${powerup.width}px Arial`;

// Randomly select one of several exercise emojis
if (!powerup.emojiChar) {
    const exerciseEmojis = ["ğŸ‹ï¸â€â™‚ï¸", "ğŸƒâ€â™€ï¸", "ğŸš´â€â™‚ï¸", "ğŸ§˜â€â™€ï¸", "ğŸ’ª"];
    powerup.emojiChar = exerciseEmojis[Math.floor(Math.random() * exerciseEmojis.length)];
}

ctx.fillText(powerup.emojiChar, 
            powerup.x + powerup.width/2 + exerciseShake, 
            exerciseY + powerup.height/2);
    
    ctx.textAlign = "start";
    ctx.restore();
}
                }
            });
            
            /* Draw month progress bar with enhanced style - ××•×¡×ª×¨ ×›×¢×ª */
// ×”×¤×¡ ×”×•×¡×ª×¨ - ×œ× × ×¦×™×’ ××•×ª×• ×™×•×ª×¨
            
            // Draw running animation if player is moving
            if (isMoving) {
                // Draw motion lines behind player - more subtle for mature look
                ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.4)" : "rgba(150, 150, 180, 0.4)";
                ctx.lineWidth = 1.5;
                
                const motionX = player.x - 30;
                
                for (let i = 0; i < 4; i++) {
                    const lineY = player.y + 20 + i * 15;
                    const lineLength = 8 + i * 4;
                    
                    // Animate motion lines length based on player speed
                    const animatedLength = lineLength * (0.8 + Math.sin(Date.now() * 0.01 + i) * 0.2);
                    
                    ctx.beginPath();
                    ctx.moveTo(motionX, lineY);
                    ctx.lineTo(motionX - animatedLength, lineY);
                    ctx.stroke();
                }
                
                // Add dust particles at player's feet when moving
                if (Math.random() < 0.2) {
                    createDustParticle();
                }
            }
            
            // Draw game messages if any
            if (gameMessage && gameMessageTime > 0) {
                const alpha = Math.min(1, gameMessageTime / 100);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#495057";
                ctx.font = "18px 'Open Sans', Arial";
                ctx.textAlign = "center";
                ctx.fillText(gameMessage, canvas.width/2, canvas.height/2);
                ctx.textAlign = "start";
                ctx.globalAlpha = 1.0;
            }
            
            // Draw dynamic day/night indicator - ×¨×§ ×× ×”×¤×•× ×§×¦×™×” ×§×™×™××ª
if (typeof drawDayNightIndicator === 'function') {
    drawDayNightIndicator();
}
        
// ×”×•×¡×¤×ª ×¡×•×’×¨ try
} catch (error) {
    console.error("Error in main renderGame process:", error);
}
} // ×¡×’×™×¨×” × ×›×•× ×” ×©×œ renderGame ×‘×¡×•×£ ×”×¤×•× ×§×¦×™×”

// Draw dynamic background based on time of day
function drawDynamicBackground() {
    // Sky gradient based on time
    let skyGradient;
    const hour = currentHour + (currentMinute / 60);
    
    skyGradient = ctx.createLinearGradient(0, 0, 0, ground.y);
    
    // Dawn (5-6)
    if (hour >= 5 && hour < 6) {
                const dawnProgress = (hour - 5);
                skyGradient.addColorStop(0, mixColorStrings('#283655', '#FF7F50', dawnProgress));
                skyGradient.addColorStop(1, mixColorStrings('#1a2238', '#FFD700', dawnProgress));
            }
            // Morning (6-10)
            else if (hour >= 6 && hour < 10) {
                skyGradient.addColorStop(0, '#87CEEB');
                skyGradient.addColorStop(1, '#ADD8E6');
            }
            // Day (10-16)
            else if (hour >= 10 && hour < 16) {
                skyGradient.addColorStop(0, '#6CA6CD');
                skyGradient.addColorStop(1, '#87CEEB');
            }
            // Afternoon (16-18)
            else if (hour >= 16 && hour < 18) {
                const afternoonProgress = (hour - 16) / 2;
                skyGradient.addColorStop(0, mixColorStrings('#6CA6CD', '#FF7F50', afternoonProgress));
                skyGradient.addColorStop(1, mixColorStrings('#87CEEB', '#FFD700', afternoonProgress));
            }
            // Sunset (18-19)
            else if (hour >= 18 && hour < 19) {
                const sunsetProgress = (hour - 18);
                skyGradient.addColorStop(0, mixColorStrings('#FF7F50', '#283655', sunsetProgress));
                skyGradient.addColorStop(1, mixColorStrings('#FFD700', '#1a2238', sunsetProgress));
            }
            // Night (19-5)
            else {
                skyGradient.addColorStop(0, '#1a2238');
                skyGradient.addColorStop(1, '#283655');
            }
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add stars at night
            if (hour >= 19 || hour < 5) {
                drawStars();
            }
            // Draw sunrise/sunset rays
            else if ((hour >= 5 && hour < 7) || (hour >= 17 && hour < 19)) {
                drawSunrays();
            }
        }
        
        // Draw stars in night sky
        function drawStars() {
            // Use the stars array created in createStars()
            if (stars.length === 0) {
                createStars();
            }
            
            stars.forEach((star, index) => {
                // Twinkle effect
                const twinkle = 0.5 + Math.sin(Date.now() * 0.001 * star.twinkleSpeed) * 0.5;
                const size = star.size * (0.7 + twinkle * 0.3);
                
                // Draw star
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + twinkle * 0.5})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Occasional larger star with glow
                if (index % 8 === 0) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Draw sunrise/sunset rays
        function drawSunrays() {
            const hour = currentHour + (currentMinute / 60);
            let rayOpacity, rayColor, sunX, sunY;
            
            // Sunrise (5-7)
            if (hour >= 5 && hour < 7) {
                rayOpacity = (hour - 5) / 2; // 0 to 1 during sunrise
                rayColor = 'rgba(255, 215, 0, '; // Golden
                sunX = canvas.width * 0.2;
                sunY = ground.y * 0.8;
            }
            // Sunset (17-19)
            else {
                rayOpacity = 1 - ((hour - 17) / 2); // 1 to 0 during sunset
                rayColor = 'rgba(255, 127, 80, '; // Coral
                sunX = canvas.width * 0.8;
                sunY = ground.y * 0.8;
            }
            
            // Limit opacity
            rayOpacity = Math.min(0.7, Math.max(0, rayOpacity));
            
            // Draw rays
            ctx.save();
            ctx.translate(sunX, sunY);
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const rayLength = 100 + Math.sin(Date.now() * 0.001 + i) * 20;
                
                ctx.rotate(angle);
                ctx.fillStyle = rayColor + rayOpacity + ')';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(rayLength, 10);
                ctx.lineTo(rayLength, -10);
                ctx.closePath();
                ctx.fill();
                ctx.rotate(-angle);
            }
            
            ctx.restore();
        }
        
        // Draw background patterns - enhanced for day/night
        function drawBackgroundPatterns() {
            ctx.fillStyle = isDayTime ? "rgba(222, 226, 230, 0.2)" : "rgba(100, 100, 150, 0.1)";
            
            // Draw subtle grid pattern
            ctx.beginPath();
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, ground.y);
            }
            for (let i = 0; i < ground.y; i += 40) {
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
            }
            ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.05)" : "rgba(100, 100, 150, 0.05)";
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Add subtle visual elements representing financial graph
            ctx.strokeStyle = isDayTime ? 
                "rgba(42, 100, 150, 0.1)" : // Day: Blue
                "rgba(100, 100, 150, 0.1)"; // Night: Purple-blue
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Draw financial graph line in background
            ctx.moveTo(0, ground.y - 100);
            
            // Use current score to influence the graph height
            const scoreInfluence = Math.min(0.5, score / 100000);
            
            for (let x = 50; x < canvas.width; x += 50) {
                // Base graph with randomness
                let y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20;
                
                // Add upward trend based on score
                y -= scoreInfluence * 100;
                
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Add data points to graph
            if (score > 10000) {
                for (let x = 100; x < canvas.width; x += 100) {
                    const y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20 - (scoreInfluence * 100);
                    
                    ctx.fillStyle = isDayTime ? "rgba(42, 100, 150, 0.2)" : "rgba(100, 100, 150, 0.2)";
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function to create dust particles at player's feet
        function createDustParticle() {
            const particle = document.createElement('div');
            particle.className = 'dust-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = isDayTime ? 'rgba(200, 200, 200, 0.6)' : 'rgba(150, 150, 180, 0.6)';
            particle.style.zIndex = '12';
            
            // Position at player's feet
            particle.style.top = `${ground.y}px`;
            particle.style.left = `${player.x + player.width / 2}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.PI + (Math.random() * Math.PI * 0.5);
            const distance = 10 + Math.random() * 20;
            const duration = 0.5 + Math.random() * 0.5;
            
            const particleKeyframes = `
                @keyframes dust-move-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.5);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `dust-move-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw sparkle effect
        function drawSparkle(x, y, size, color) {
            // Draw a simple sparkle star
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * Math.PI * 2);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            const innerSize = size * 0.5;
            const outerSize = size;
            
            // Star shape
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * outerSize, Math.sin(angle) * outerSize);
            }
            ctx.stroke();
            
            // Inner glow
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, 0, innerSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw powerup particle effect
        function drawPowerupParticle(x, y, color) {
            const particle = document.createElement('div');
            particle.className = 'powerup-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '6px';
            particle.style.height = '6px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = color || 'rgba(42, 100, 150, 0.8)';
            particle.style.zIndex = '15';
            
            // Position at source
            particle.style.top = `${y}px`;
            particle.style.left = `${x}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 30;
            const duration = 1 + Math.random() * 1;
            
            const particleKeyframes = `
                @keyframes powerup-particle-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.2);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `powerup-particle-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw day/night indicator
        function drawDayNightIndicator() {
            // Small indicator in corner
            const size = 30;
            const margin = 20;
            const x = canvas.width - size - margin;
            const y = margin;
            
            // Draw background circle
            ctx.fillStyle = isDayTime ? 'rgba(255, 255, 255, 0.6)' : 'rgba(50, 50, 80, 0.6)';
            ctx.beginPath();
            ctx.arc(x, y, size/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw icon based on time
            if (isDayTime) {
                // Sun icon
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Sun rays
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                ctx.lineWidth = 1.5;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerRadius = size/3 + 2;
                    const outerRadius = size/2 - 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        x + Math.cos(angle) * innerRadius,
                        y + Math.sin(angle) * innerRadius
                    );
                    ctx.lineTo(
                        x + Math.cos(angle) * outerRadius,
                        y + Math.sin(angle) * outerRadius
                    );
                    ctx.stroke();
                }
            } else {
                // Moon icon
                ctx.fillStyle = 'rgba(230, 230, 250, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Moon shadow
                ctx.fillStyle = 'rgba(50, 50, 80, 0.6)';
                ctx.beginPath();
                ctx.arc(x + size/8, y - size/8, size/3 - 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Stars
                for (let i = 0; i < 3; i++) {
                    const starX = x + Math.cos(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    const starY = y + Math.sin(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(starX, starY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function for color string mixing
        function mixColorStrings(color1, color2, ratio) {
            // Convert hex to rgb if needed
            const getRGB = (color) => {
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return [r, g, b];
                } else if (color.startsWith('rgb')) {
                    return color.match(/\d+/g).map(Number);
                }
                return [0, 0, 0]; // Fallback
            };
            
            const rgb1 = getRGB(color1);
            const rgb2 = getRGB(color2);
            
            const r = Math.round(rgb1[0] * (1 - ratio) + rgb2[0] * ratio);
            const g = Math.round(rgb1[1] * (1 - ratio) + rgb2[1] * ratio);
            const b = Math.round(rgb1[2] * (1 - ratio) + rgb2[2] * ratio);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        // Draw speech bubble for characters - ××‘×•×˜×œ ×›×¨×’×¢
function drawSpeechBubble(ctx, x, y, text, maxWidth, maxHeight) {
    // ×¤×•× ×§×¦×™×” ×¨×™×§×” - ×‘×•×¢×•×ª ×”×“×™×‘×•×¨ ×”×•×©×‘×ª×•
    return;
}
        
        // Draw player and companion as emojis with animations
function drawEnhancedPlayer() {
    // Use health factor for player appearance
    const healthFactor = stats.physicalHealth / 100;
    const mentalFactor = stats.mentalHealth / 100;
    
    // Add subtle bob animation when moving - visual only
let playerY = player.y;
if (isMoving) {
    // ××¤×§×˜ ×•×™×–×•××œ×™ ×‘×œ×‘×“ - ×œ× ××©× ×” ××ª ×¢×¨×š ×”-Y ×”×××™×ª×™ ×©×œ ×”×©×—×§×Ÿ
    playerY = originalPlayerY + Math.sin(Date.now() * 0.01) * 2;
} else {
    // ×›×©×œ× ×‘×ª× ×•×¢×”, ×•×•×“× ×©×”×©×—×§×Ÿ ×—×•×–×¨ ×œ××™×§×•× ×”××§×•×¨×™
    playerY = originalPlayerY || ground.y - player.height - 5;
}
    
    // Draw shadow beneath player
    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.beginPath();
    ctx.ellipse(player.x + player.width/2, ground.y, player.width/2, player.width/8, 0, 0, Math.PI * 2);
    ctx.fill();
    
    // Select player emoji based on state and health
if (!player.emojiChar || player.lastHealthCheck !== Math.floor(healthFactor * 10) + Math.floor(mentalFactor * 10) || player.lastMovementState !== isMoving) {
    // Update player emoji when health changes significantly or movement state changes
    player.lastHealthCheck = Math.floor(healthFactor * 10) + Math.floor(mentalFactor * 10);
    player.lastMovementState = isMoving;
    
    // Call the function that updates the player emoji
    updatePlayerEmoji();
}
    
    ctx.save();
    
    // If player has powerUp, add glow effect
    if (player.powerUp) {
        let glowColor;
        
        switch(player.powerUpType) {
            case 'earlyRise':
                glowColor = 'rgba(58, 122, 95, 0.7)'; // Green-blue
                break;
            case 'earlySleep':
                glowColor = 'rgba(90, 90, 143, 0.7)'; // Purple-blue
                break;
            case 'healthyFood':
                glowColor = 'rgba(58, 122, 95, 0.7)'; // Green
                break;
            case 'exercise':
                glowColor = 'rgba(211, 135, 62, 0.7)'; // Orange
                break;
            case 'companion':
                glowColor = 'rgba(42, 100, 150, 0.7)'; // Blue
                break;
            default:
                glowColor = 'rgba(73, 80, 87, 0.7)'; // Default gray
        }
        
        // Add glow with pulsating animation
        const glowSize = 10 + Math.sin(Date.now() * 0.005) * 3;
        ctx.shadowColor = glowColor;
        ctx.shadowBlur = glowSize;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
    }
    
    // Draw player emoji
ctx.font = `${player.width * 1.2}px Arial`;
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×

// Draw player emoji - no need to change this part
// since we handle movement state in the emoji selection logic
ctx.save();
ctx.translate(player.x + player.width/2, playerY + player.height/2);
ctx.scale(-1, 1); // ×”×¤×™×›×ª ×”××™××•×’'×™ ×‘×¦×™×¨ X

// Apply slight forward lean only when moving
if (isMoving) {
    ctx.rotate(Math.PI * 0.03); // Slight forward lean
}

ctx.fillText(player.emojiChar, 0, 0);
ctx.restore();
    
    // Reset shadow and text alignment
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
    ctx.textAlign = "start";
    
    // Draw companion if active - as emoji
    if (player.companion && player.powerUp) {
        // Calculate companion position with slight offset from player
        const companionX = player.x - 40; 
        const companionY = playerY;
        
        // Add companion animation - follows player with slight delay
        const companionBob = isMoving ? Math.sin((Date.now() - 100) * 0.01) * 2 : 0;
        
        // Add companion shadow
        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
        ctx.beginPath();
        ctx.ellipse(companionX + 15, ground.y, 15, 3, 0, 0, Math.PI * 2);
        ctx.fill();
        
        // Companion glow effect
        ctx.shadowColor = 'rgba(42, 100, 150, 0.6)';
        ctx.shadowBlur = 8 + Math.sin(Date.now() * 0.01) * 2;
        ctx.shadowOffsetX = 0;
        ctx.shadowOffsetY = 0;
        
        // Draw companion emoji
ctx.textAlign = "center";
ctx.textBaseline = "middle";
ctx.fillStyle = "rgba(0, 0, 0, 1.0)"; // ×©×•×¨×” ×—×“×©×”: ×”×’×“×¨×ª ×¦×‘×¢ ××™×œ×•×™ ××˜×•×
ctx.font = `${player.width}px Arial`;

// Set companion emoji if not already set
if (!player.companionEmojiChar) {
    const companionEmojis = ["ğŸ‘«", "ğŸ‘¬", "ğŸ‘­", "ğŸ‘¨â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦", "ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦", "ğŸ‘©â€ğŸ‘©â€ğŸ‘§â€ğŸ‘¦"];
    player.companionEmojiChar = companionEmojis[Math.floor(Math.random() * companionEmojis.length)];
}

ctx.fillText(player.companionEmojiChar, 
            companionX + 15, 
            companionY + companionBob + player.height/2);
        
        // Reset shadow
        ctx.shadowColor = 'transparent';
        ctx.shadowBlur = 0;
        
        // Connection line between player and companion
        ctx.strokeStyle = 'rgba(42, 100, 150, 0.3)';
        ctx.lineWidth = 2;
        ctx.setLineDash([5, 3]);
        
        ctx.beginPath();
        ctx.moveTo(companionX + 30, companionY + companionBob + player.height/2);
        ctx.lineTo(player.x, playerY + player.height/2);
        ctx.stroke();
        
        // Reset line dash
        ctx.setLineDash([]);
        
        // Occasional particles between player and companion
        if (Math.random() < 0.05 && isMoving) {
            const particleX = companionX + 30 + Math.random() * (player.x - companionX - 30);
            const particleY = companionY + player.height/2 + (Math.random() * 20 - 10);
            
            drawPowerupParticle(particleX, particleY, 'rgba(42, 100, 150, 0.6)');
        }
        
        // Create companion message obstacles with same frequency as regular obstacles
        if (Math.random() < 0.003 && obstacles.length < 3) {
            const encouragement = [
                "ğŸ”¥ ×× ×™ ××××™×Ÿ ×‘×š! ××œ ×ª×¢×¦×•×¨ ×œ×¨×’×¢!",
                "ğŸŒŸ ××ª×” ×œ×’××¨×™ ×‘×“×¨×š ×”× ×›×•× ×” â€“ ×’××” ×‘×š!",
                "ğŸ’ª ×ª××©×™×š ×‘×“×™×•×§ ×›×›×”, ××ª×” ×”×©×¨××” ×‘×©×‘×™×œ×™!",
                "ğŸ¤ ×× ×—× ×• ×™×—×“ ×‘×–×”, ×•× ×’×™×¢ ×¨×—×•×§!",
                "ğŸ‘ ×¢×‘×•×“×” × ×”×“×¨×ª! ×¨×•××™× ××ª ×”×”×ª×§×“××•×ª ×©×œ×š!"
            ];
            
            const selectedMessage = encouragement[Math.floor(Math.random() * encouragement.length)];
            
            // Create a companion message obstacle
            const companionObstacle = {
                x: canvas.width,
                y: ground.y - 80,
                width: 50,
                height: 80,
                type: "companion_msg",
                speed: 4,
                text: selectedMessage,
                value: 0, // No direct monetary value
                mentalEffect: 8, // Significant mental boost
                persuasiveTexts: [],
                obstacleTitle: "ğŸ‘« ×¢×™×“×•×“ ××—×‘×¨",
                initialText: selectedMessage,
                // Visual properties
                color: "#2a6496", // Blue
                animationOffset: Math.random() * Math.PI * 2,
                bobSpeed: 0.05 + Math.random() * 0.03
            };
            
            obstacles.push(companionObstacle);
        }
    }
    
    // Create thought obstacle with same frequency as regular obstacles
    if (Math.random() < 0.003 && obstacles.length < 3) {
        const thoughts = [
            {
                text: "×—×™×¡×›×•×Ÿ ×§×‘×•×¢ ××‘×™× ×œ×‘×™×˜×—×•×Ÿ ×¤×™× × ×¡×™",
                option: "×× ×™ ××ª×—×™×™×‘ ×œ×©×™× ×‘×¦×“ ×¡×›×•× ×§×‘×•×¢ ×›×œ ×—×•×“×©"
            },
            {
                text: "×”×”×•×¦××•×ª ×”×§×˜× ×•×ª ××¦×˜×‘×¨×•×ª",
                option: "×× ×™ ××ª×—×™×œ ×œ×”×©×™× ×œ×‘ ×œ×›×œ ×©×§×œ ×©×™×•×¦×"
            },
            {
                text: "×”×©×§×¢×” ×‘×¢×¦××™ ×”×™× ×”×”×©×§×¢×” ×”×˜×•×‘×” ×‘×™×•×ª×¨",
                option: "×× ×™ ×›××• ×× ×™×”, ×›×œ ×”×•×¦××” ×’×•×¨××ª ×œ×× ×™×” ×œ×¨×“×ª"
            },
            {
                text: "×¡×‘×œ× ×•×ª ×”×™× ×”××¤×ª×— ×œ×”×¦×œ×—×” ×¤×™× × ×¡×™×ª",
                option: "×× ×™ ×œ× ××—×¤×© ×§×™×¦×•×¨×™ ×“×¨×š, ×× ×™ ×‘×•× ×” ×™×¦×™×‘×•×ª"
            },
            {
                text: "×œ×ª×›× ×Ÿ ××¨××© ×—×•×¡×š ×›×¡×£ ×‘×˜×•×•×— ×”××¨×•×š",
                option: "×× ×™ ×©×•×œ×˜ ×‘××•×¤×Ÿ ××œ× ×¢×œ ×”×—×™×™× ×©×œ×™"
            }
        ];
        
        const selectedThought = thoughts[Math.floor(Math.random() * thoughts.length)];
        
        // Create a new obstacle of type "thought"
        const thoughtObstacle = {
            x: canvas.width,
            y: ground.y - 80,
            width: 50,
            height: 80,
            type: "thought",
            speed: 4,
            text: selectedThought.text,
            value: 500, // Small bonus when interacting
            mentalEffect: 5, // Small positive mental effect
            persuasiveTexts: [],
            obstacleTitle: "ğŸ’­ ×—×©×•×‘ ×œ×–×›×•×¨ ×©...",
            initialText: selectedThought.text,
            acceptOption: selectedThought.option, // Custom option text
            // Visual properties
            color: "#3a7a5f",
            animationOffset: Math.random() * Math.PI * 2,
            bobSpeed: 0.05 + Math.random() * 0.03
        };
        
        obstacles.push(thoughtObstacle);
    }
    
    ctx.restore();
}
        
        // Draw thought bubble - ××‘×•×˜×œ ×›×¨×’×¢
function drawThoughtBubble(ctx, x, y, text, maxWidth, maxHeight) {
    // ×¤×•× ×§×¦×™×” ×¨×™×§×” - ×‘×•×¢×•×ª ×”××—×©×‘×” ×”×•×©×‘×ª×•
    return;
}
        
        // Helper function for rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }
        
        // Update display with animated transitions
        function updateDisplay() {
    // Update score with smooth animation if significant change
    const scoreDisplay = document.getElementById('score-display');
    const assetsDisplay = document.getElementById('assets');
    const currentScoreText = scoreDisplay.textContent;
    const currentScore = parseInt(currentScoreText.match(/\d+/g).join(''));
            
    if (Math.abs(currentScore - score) > 100) {
    // Animate score change
    animateScoreChange(currentScore, score);
} else {
    // Small change, just update
    scoreDisplay.textContent = `×¡×š × ×›×¡×™× ×¤×™× × ×¡×™×™×: ${score.toLocaleString()} ×©"×—`;
}

// Update assets display
assetsDisplay.textContent = score.toLocaleString();

// Update date display with transition effect
const dateDisplay = document.getElementById('date-display');
            
            if (dateDisplay.textContent !== monthNames[currentMonth]) {
                // Save original transform
                const originalTransform = dateDisplay.style.transform;
                
                // Fade out
                dateDisplay.style.opacity = '0';
                dateDisplay.style.transform = 'translateY(-5px)';
                
                // After fade out, update text and fade in
                setTimeout(() => {
                    dateDisplay.textContent = monthNames[currentMonth];
                    dateDisplay.style.opacity = '1';
                    dateDisplay.style.transform = originalTransform;
                }, 300);
            }
            
            // Update monthly stats
            document.getElementById('expenses').textContent = stats.expenses.toLocaleString();
            document.getElementById('income').textContent = stats.income.toLocaleString();
            
            // Highlight changes in income or expenses with color flash
            const expensesElem = document.getElementById('expenses');
            const incomeElem = document.getElementById('income');
            
            // Flash expenses if they changed
            if (stats.expenses > parseInt(expensesElem.getAttribute('data-prev-value') || '0')) {
                flashElement(expensesElem, 'rgba(212, 91, 91, 0.2)');
            }
            
            // Flash income if it changed
            if (stats.income > parseInt(incomeElem.getAttribute('data-prev-value') || '0')) {
                flashElement(incomeElem, 'rgba(58, 122, 95, 0.2)');
            }
            
            // Store current values for next comparison
            expensesElem.setAttribute('data-prev-value', stats.expenses);
            incomeElem.setAttribute('data-prev-value', stats.income);
        }
        
        // Animate score change with counting effect
        function animateScoreChange(startScore, endScore) {
            const scoreDisplay = document.getElementById('score-display');
            const duration = 1000; // 1 second animation
            const startTime = Date.now();
            const scoreChange = endScore - startScore;
            
            // Add highlight effect based on score change direction
            if (scoreChange > 0) {
                scoreDisplay.style.color = 'var(--success-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(58, 122, 95, 0.3)';
            } else if (scoreChange < 0) {
                scoreDisplay.style.color = 'var(--danger-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(212, 91, 91, 0.3)';
            }
            
            // Animation function
            function animate() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Easing function for smoother animation
                const easedProgress = progress < 0.5 ? 
                    4 * progress * progress * progress : 
                    1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                // Calculate current value
                const currentValue = Math.round(startScore + scoreChange * easedProgress);
                
                // Update display
                scoreDisplay.textContent = `×¡×š × ×›×¡×™× ×¤×™× × ×¡×™×™×: ${currentValue.toLocaleString()} ×©"×—`;
                
                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Reset style after animation
                    setTimeout(() => {
                        scoreDisplay.style.color = 'var(--primary-color)';
                        scoreDisplay.style.textShadow = 'none';
                    }, 500);
                }
            }
            
            // Start animation
            animate();
        }
        
        // Flash element background color
        function flashElement(element, color) {
            // Save original background
            const originalBg = element.style.backgroundColor;
            const originalTransition = element.style.transition;
            
            // Apply flash
            element.style.transition = 'background-color 0.1s ease-in';
            element.style.backgroundColor = color;
            
            // Remove flash with transition
            setTimeout(() => {
                element.style.transition = 'background-color 0.5s ease-out';
                element.style.backgroundColor = originalBg;
                
                // Reset transition after animation
                setTimeout(() => {
                    element.style.transition = originalTransition;
                }, 500);
            }, 100);
        }
        
        // Show job offer with enhanced visuals
function showJobOffer() {
    gamePaused = true;
    isMoving = false; // ×¢×¦×™×¨×ª ×”×ª× ×•×¢×” ×‘××•×¤×Ÿ ××•×—×œ×˜
    jobOfferStage = 0;
    
    // Prepare dialog with animation
    const jobOfferDialog = document.getElementById('job-offer');
    jobOfferDialog.style.animation = 'job-offer-appear 0.5s ease forwards';
    
    // Add animation style if not already present
    if (!document.getElementById('job-offer-style')) {
        const style = document.createElement('style');
        style.id = 'job-offer-style';
        style.textContent = `
            @keyframes job-offer-appear {
                from {
                    opacity: 0;
                    transform: translate(-50%, -60%) scale(0.9);
                }
                to {
                    opacity: 1;
                    transform: translate(-50%, -50%) scale(1);
                }
            }
        `;
        document.head.appendChild(style);
    }
    
    // ×™×¦×™×¨×ª ×©×›×‘×ª ×”××¤×œ×” ×××—×•×¨×™ ×”×“×™××œ×•×’ ×‘××§×•× ×”-overlay ×”××§×•×¨×™
    const dialogOverlay = createDialogOverlay();
    
    // ×©××™×¨×ª ×”×¤× ×™×” ×œ×©×›×‘×ª ×”××¤×œ×” ×¢×œ ×”××•×‘×™×™×§×˜ ×©×œ ×”×“×™××œ×•×’
    jobOfferDialog.dialogOverlay = dialogOverlay;
    
    // ×©×™× ×•×™ ×”Ö¾z-index ×©×œ ×”×“×™××œ×•×’
    jobOfferDialog.style.zIndex = '100';
    
    // Show dialog
    jobOfferDialog.style.display = 'block';
    
    // Add career icon animation
    const careerIcon = document.createElement('div');
    careerIcon.className = 'career-icon';
    careerIcon.style.position = 'absolute';
    careerIcon.style.top = '-40px';
    careerIcon.style.left = '50%';
    careerIcon.style.transform = 'translateX(-50%)';
    careerIcon.style.fontSize = '50px';
    careerIcon.style.opacity = '0';
    careerIcon.style.transition = 'all 0.5s ease';
    careerIcon.textContent = 'ğŸ’¼';
    
    jobOfferDialog.appendChild(careerIcon);
    
    // Animate icon
    setTimeout(() => {
        careerIcon.style.opacity = '1';
        careerIcon.style.top = '-60px';
    }, 300);
}
        
        // Show job offer followup with enhanced visuals
        function showJobOfferFollowup() {
            // Hide job offer dialog
            const jobOfferDialog = document.getElementById('job-offer');
            jobOfferDialog.style.animation = 'job-offer-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('job-offer-exit-style')) {
                const style = document.createElement('style');
                style.id = 'job-offer-exit-style';
                style.textContent = `
                    @keyframes job-offer-exit {
                        from {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        to {
                            opacity: 0;
                            transform: translate(-50%, -60%) scale(0.9);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // After exit animation, hide dialog and show followup
            setTimeout(() => {
                jobOfferDialog.style.display = 'none';
                
                // Check if there's a career icon to remove
                const careerIcon = jobOfferDialog.querySelector('.career-icon');
                if (careerIcon) {
                    jobOfferDialog.removeChild(careerIcon);
                }
                
                // Set followup text
                document.getElementById('followup-text').textContent = jobOfferTexts[jobOfferStage];
                
                // Show followup dialog with entrance animation
                const followupDialog = document.getElementById('job-offer-followup');
                followupDialog.style.animation = 'job-followup-appear 0.4s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('job-followup-style')) {
                    const style = document.createElement('style');
                    style.id = 'job-followup-style';
                    style.textContent = `
                        @keyframes job-followup-appear {
                            from {
                                opacity: 0;
                                transform: translate(-50%, -40%) scale(0.95);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                followupDialog.style.display = 'block';
                
                // Add persuasion icon based on stage
                let persuasionIcon = 'ğŸ’°'; // Default money
                
                if (jobOfferStage === 1) persuasionIcon = 'ğŸ“ˆ'; // Growth
                if (jobOfferStage === 2) persuasionIcon = 'ğŸš€'; // Career
                if (jobOfferStage === 3) persuasionIcon = 'â±ï¸'; // Time/flexibility
                
                const iconElem = document.createElement('div');
                iconElem.className = 'persuasion-icon';
                iconElem.style.position = 'absolute';
                iconElem.style.top = '-40px';
                iconElem.style.left = '50%';
                iconElem.style.transform = 'translateX(-50%)';
                iconElem.style.fontSize = '40px';
                iconElem.style.opacity = '0';
                iconElem.style.transition = 'all 0.5s ease';
                iconElem.textContent = persuasionIcon;
                
                followupDialog.appendChild(iconElem);
                
                // Animate icon
                setTimeout(() => {
                    iconElem.style.opacity = '1';
                    iconElem.style.top = '-50px';
                }, 300);
            }, 300);
        }
        
        // Game over with enhanced visuals
        function gameOver(reason) {
            gameRunning = false;
            
            // Update game stats
            document.getElementById('game-over-reason').textContent = reason;
            document.getElementById('final-score').textContent = score.toLocaleString();
            document.getElementById('months-played').textContent = stats.monthsPlayed;
            document.getElementById('powerups-collected').textContent = stats.powerupsCollected;
            document.getElementById('obstacles-avoided').textContent = stats.obstaclesFaced;
            
            // Create dramatic overlay
            const overlay = document.createElement('div');
            overlay.className = 'game-over-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            overlay.style.transition = 'background-color 1.5s ease';
            overlay.style.zIndex = '90';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in dark overlay
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
            }, 100);
            
            // Show game over with enhanced animation
            setTimeout(() => {
                const gameOverScreen = document.getElementById('game-over');
                gameOverScreen.style.display = 'block';
                gameOverScreen.style.animation = 'game-over-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('game-over-style')) {
                    const style = document.createElement('style');
                    style.id = 'game-over-style';
                    style.textContent = `
                        @keyframes game-over-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.05);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Add dramatic visual effects
                createGameOverEffect();
            }, 800);
        }
        
        // Create visual effects for game over
        function createGameOverEffect() {
            // Add falling coins/money effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'falling-money';
                    
                    // Randomize coin appearance - dollar, shekel, or coins
                    const coinTypes = ['ğŸ’°', 'ğŸ’¸', 'â‚ª', 'ğŸ’µ'];
                    const coinText = coinTypes[Math.floor(Math.random() * coinTypes.length)];
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.fontSize = `${20 + Math.random() * 20}px`;
                    coin.style.opacity = '0.7';
                    coin.style.zIndex = '91';
                    coin.style.color = '#d45b5b';
                    coin.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.5)';
                    coin.textContent = coinText;
                    
                    // Position randomly at top
                    const startX = Math.random() * window.innerWidth;
                    coin.style.top = `-50px`;
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation for falling
                    const fallDuration = 3 + Math.random() * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 720;
                    const horizontalMovement = (Math.random() - 0.5) * 100;
                    const delay = Math.random() * 2;
                    
                    // Create keyframes for this specific coin
                    const keyframes = `
                        @keyframes fall-${Date.now()}-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0.7;
                            }
                            80% {
                                opacity: 0.7;
                            }
                            100% {
                                transform: translateY(${window.innerHeight + 100}px) 
                                           translateX(${horizontalMovement}px) 
                                           rotate(${rotationSpeed}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    
                    // Add style for this specific animation
                    const style = document.createElement('style');
                    style.textContent = keyframes;
                    document.head.appendChild(style);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `fall-${Date.now()}-${i} ${fallDuration}s cubic-bezier(0.4, 0, 1, 1) forwards`;
                    }, delay * 1000);
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (style.parentNode) {
                            style.parentNode.removeChild(style);
                        }
                    }, (fallDuration + delay + 0.5) * 1000);
                }, i * 200); // Stagger coin creation
            }
            
            // Add crack in ground effect
            const crack = document.createElement('div');
            crack.className = 'ground-crack';
            crack.style.position = 'absolute';
            crack.style.top = `${ground.y - 10}px`;
            crack.style.left = '50%';
            crack.style.transform = 'translateX(-50%)';
            crack.style.width = '0';
            crack.style.height = '20px';
            crack.style.backgroundColor = '#333';
            crack.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5), 0 0 5px rgba(255, 0, 0, 0.3)';
            crack.style.zIndex = '91';
            
            document.getElementById('game-container').appendChild(crack);
            
            // Create crack animation
            const crackStyle = document.createElement('style');
            crackStyle.textContent = `
                @keyframes crack-grow {
                    0% { width: 0; }
                    60% { width: 60%; }
                    100% { width: 50%; }
                }
            `;
            document.head.appendChild(crackStyle);
            
            // Apply animation
            crack.style.animation = 'crack-grow 1.2s ease-out forwards';
        }
        
        // Win game with enhanced visuals
        function winGame() {
            gameRunning = false;
            
            // Update win stats
            document.getElementById('win-months').textContent = stats.monthsPlayed;
            document.getElementById('win-powerups').textContent = stats.powerupsCollected;
            document.getElementById('win-obstacles').textContent = stats.obstaclesFaced;
            
            // Create celebratory overlay
            const overlay = document.createElement('div');
            overlay.className = 'win-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'radial-gradient(circle, rgba(42, 100, 150, 0) 0%, rgba(42, 100, 150, 0.3) 100%)';
            overlay.style.transition = 'all 1.5s ease';
            overlay.style.zIndex = '90';
            overlay.style.opacity = '0';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in overlay
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 100);
            
            // Create celebration effects
            createWinEffects();
            
            // Show win screen with enhanced animation
            setTimeout(() => {
                const winScreen = document.getElementById('win-screen');
                winScreen.style.display = 'block';
                winScreen.style.animation = 'win-screen-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('win-screen-style')) {
                    const style = document.createElement('style');
                    style.id = 'win-screen-style';
                    style.textContent = `
                        @keyframes win-screen-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.1);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }, 1500);
        }
        
        // Create celebration effects for win
        function createWinEffects() {
            // Create fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createFirework();
                }, i * 300);
            }
            
            // Create golden rain
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    createGoldenRain();
                }, Math.random() * 2000);
            }
            
            // Create floating achievement icons
            const achievementIcons = ['ğŸ’°', 'ğŸ“ˆ', 'ğŸ†', 'ğŸ’ª', 'ğŸ“Š', 'âœ…', 'ğŸ¯'];
            
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const icon = document.createElement('div');
                    icon.className = 'floating-achievement';
                    
                    // Style the icon
                    icon.style.position = 'absolute';
                    icon.style.fontSize = `${30 + Math.random() * 20}px`;
                    icon.style.opacity = '0';
                    icon.style.zIndex = '91';
                    icon.textContent = achievementIcons[Math.floor(Math.random() * achievementIcons.length)];
                    
                    // Position randomly
                    icon.style.top = `${Math.random() * (window.innerHeight * 0.7)}px`;
                    icon.style.left = `${Math.random() * window.innerWidth}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(icon);
                    
                    // Define animation
                    const floatDuration = 5 + Math.random() * 3;
                    const floatDistance = 100 + Math.random() * 200;
                    
                    const iconStyle = document.createElement('style');
                    iconStyle.textContent = `
                        @keyframes float-icon-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0;
                            }
                            10% {
                                opacity: 0.9;
                            }
                            90% {
                                opacity: 0.9;
                            }
                            100% {
                                transform: translateY(-${floatDistance}px) rotate(${Math.random() * 40 - 20}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    document.head.appendChild(iconStyle);
                    
                    // Apply animation
                    icon.style.animation = `float-icon-${i} ${floatDuration}s ease-out forwards`;
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (icon.parentNode) {
                            icon.parentNode.removeChild(icon);
                        }
                        if (iconStyle.parentNode) {
                            iconStyle.parentNode.removeChild(iconStyle);
                        }
                    }, floatDuration * 1000 + 100);
                }, i * 500 + Math.random() * 1000);
            }
        }
        
        // Create a firework effect
        function createFirework() {
            // Create firework explosion at random position
            const explosionX = Math.random() * window.innerWidth;
            const explosionY = Math.random() * (window.innerHeight * 0.6);
            
            // Random firework color
            const colors = [
                '255, 215, 0',  // Gold
                '42, 100, 150', // Blue
                '58, 122, 95',  // Green
                '255, 127, 80', // Coral
                '147, 112, 219' // Purple
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Create particles
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'firework-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = `rgba(${color}, 0.8)`;
                particle.style.boxShadow = `0 0 6px rgba(${color}, 0.5)`;
                particle.style.zIndex = '92';
                
                // Position at explosion center
                particle.style.top = `${explosionY}px`;
                particle.style.left = `${explosionX}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create specific animation for this particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 150;
                const duration = 0.8 + Math.random() * 0.6;
                
                const particleKeyframes = `
                    @keyframes firework-particle-${Date.now()}-${i} {
                        0% { 
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1.5); 
                        }
                        100% { 
                            opacity: 0;
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5); 
                        }
                    }
                `;
                
                const particleStyle = document.createElement('style');
                particleStyle.textContent = particleKeyframes;
                document.head.appendChild(particleStyle);
                
                // Apply animation
                particle.style.animation = `firework-particle-${Date.now()}-${i} ${duration}s ease-out forwards`;
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (particleStyle.parentNode) {
                        particleStyle.parentNode.removeChild(particleStyle);
                    }
                }, duration * 1000 + 100);
            }
        }
        
        // Create golden rain for win effect
        function createGoldenRain() {
            const coin = document.createElement('div');
            coin.className = 'golden-rain';
            
            // Style coin
            coin.style.position = 'absolute';
            coin.style.fontSize = `${15 + Math.random() * 10}px`;
            coin.style.opacity = '0.9';
            coin.style.zIndex = '91';
            coin.style.color = '#FFD700';
            coin.style.textShadow = '0 0 5px rgba(255, 215, 0, 0.7)';
            coin.textContent = 'â‚ª';
            
            // Position at top with random horizontal placement
            const startX = Math.random() * window.innerWidth;
            coin.style.top = `-20px`;
            coin.style.left = `${startX}px`;
            
            document.getElementById('game-container').appendChild(coin);
            
            // Create animation
            const fallDuration = 3 + Math.random() * 2;
            const swayAmount = 50 + Math.random() * 50;
            const direction = Math.random() > 0.5 ? 1 : -1;
            const rotationAmount = Math.random() * 360;
            
            const keyframes = `
                @keyframes golden-rain-${Date.now()} {
                    0% {
                        transform: translateY(0) rotate(0deg);
                        opacity: 0;
                    }
                    10% {
                        opacity: 0.9;
                    }
                    100% {
                        transform: translateY(${window.innerHeight + 50}px) 
                                   translateX(${swayAmount * direction}px) 
                                   rotate(${rotationAmount}deg);
                        opacity: 0.7;
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = keyframes;
            document.head.appendChild(style);
            
            // Apply animation
            coin.style.animation = `golden-rain-${Date.now()} ${fallDuration}s ease-in forwards`;
            
            // Remove elements after animation
            setTimeout(() => {
                if (coin.parentNode) {
                    coin.parentNode.removeChild(coin);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, fallDuration * 1000 + 100);
        }
        // Reset game with simple initialization
function resetGame() {
    // Initialize game variables directly without fade effects
    gameRunning = true;
    gamePaused = false;
    score = 0;
    currentMonth = 0;
    currentMonthTimer = 0;
    obstacles = [];
    powerups = [];
    pendingObstacles = [];
    isMoving = false;
        
    // ××™×¤×•×¡ ×”××¢×¨×›×ª ×”×—×“×©×” ×©×œ ×™××™× ×©× ×•×ª×¨×•
currentHour = 5; // ××©××¨ ×œ××§×¨×” ×©×¦×¨×™×š ×œ×—×™×©×•×‘×™× ××—×¨×™×
currentMinute = 0; // ××©××¨ ×œ××§×¨×” ×©×¦×¨×™×š ×œ×—×™×©×•×‘×™× ××—×¨×™×
isDayTime = true;
lastTimeUpdate = Date.now(); // ×—×©×•×‘: ××™×¤×•×¡ ×”×–××Ÿ ×”××—×¨×•×Ÿ
lastDaysRemaining = 30; // ××™×¤×•×¡ ××¡×¤×¨ ×”×™××™× ×”× ×•×ª×¨×™×

    // ×”×¡×ª×¨ ××ª ×œ×•×— ×”××—×•×•× ×™× ×•×›×¤×ª×•×¨ ×”×—×¥ ×‘×¢×ª ××ª×—×•×œ ×”××©×—×§ ××—×“×©
    document.querySelector('.dashboard-container').style.display = 'none';
    document.getElementById('forward-arrow-button').style.display = 'none';

    // Reset stats
    stats = {
        monthsPlayed: 0,
        powerupsCollected: 0,
        obstaclesAvoided: 0,
        obstaclesFaced: 0,
        expenses: 0,
        income: 5000,
        mentalHealth: 100,
        physicalHealth: 100
    };

    // ××ª×—×•×œ ××”×™×¨×•×ª ×”×™×•×
    updateDaySpeed();
    
    // Reset monthly counters
monthlyObstacleCounter = {
    person: 0,
    ad: 0,
    food: 0,
    thought: 0,
    companion_msg: 0,
    financial_question: 0
};

monthlyPowerupCounter = {
    money: 0,
    earlyRise: 0,
    earlySleep: 0,
    healthyFood: 0,
    exercise: 0,
    companion: 0
};
    
    // Reset achievements
    achievements = {
        firstMonth: { earned: false, text: "×”×™×©×¨×“×•×ª ×—×•×“×© ×¨××©×•×Ÿ" },
        saveHero: { earned: false, text: "×—×¡×›×ª 50,000 ×©\"×—" },
        powerCollector: { earned: false, text: "××™××¦×ª 10 ×”×¨×’×œ×™× ×¤×™× × ×¡×™×™× ×—×™×•×‘×™×™×" },
        resistanceMaster: { earned: false, text: "×¤×ª×¨×ª 20 ×“×™×œ××•×ª ×¤×™× × ×¡×™×•×ª" },
        mentalStrength: { earned: false, text: "×©××¨×ª ×¢×œ ×—×•×¡×Ÿ ×× ×˜×œ×™ ×’×‘×•×”" }
    };
    
    // Reset player
player.powerUp = false;
player.powerUpTime = 0;
player.companion = false;
player.currentSpeed = player.baseSpeed;

// ×•×•×“× ×©×”×©×—×§×Ÿ ×—×•×–×¨ ×œ××™×§×•× ×”××§×•×¨×™ ×©×œ×• ×¢×œ ×”×§×¨×§×¢
originalPlayerY = ground.y - player.height - 5; // 5px gap
player.y = originalPlayerY;
    
    // Adjust player size based on screen dimensions
    let scaleFactor = Math.min(window.innerWidth, window.innerHeight) / 500;
    scaleFactor = Math.max(0.5, Math.min(1.5, scaleFactor)); // Limit between 0.5 and 1.5
    player.width = 50 * scaleFactor;
    player.height = 80 * scaleFactor;
    
    // Update player position after size change - with a small 5px gap above ground
player.y = ground.y - player.height - 5; // 5px gap for better visual
originalPlayerY = player.y; // Update the original position variable
    
    // Reset displays
    updateDisplay();
    updatePlayerCondition();
    updateClockDisplay();
    
    // Hide status displays
    document.getElementById('status-negative').style.display = 'none';
    document.getElementById('status-weight').style.display = 'none';
    
    // Hide power meter
    document.getElementById('power-meter').style.display = 'none';
    
    // Hide all dialogs
    document.getElementById('job-offer').style.display = 'none';
    document.getElementById('job-offer-followup').style.display = 'none';
    document.getElementById('obstacle-dialog').style.display = 'none';
    document.getElementById('powerup-dialog').style.display = 'none';
    document.getElementById('game-over').style.display = 'none';
    document.getElementById('win-screen').style.display = 'none';
    
    // Reset tutorial and show it
    tutorialShown = true;
    document.getElementById('tutorial-message').style.display = 'block';
    document.getElementById('movement-instruction').style.display = 'none';
    
    // ××ª×—×•×œ ××¡×›×™ ×”××“×¨×™×š ××—×“×© - ×”×¦×’ ×¨×§ ××ª ×”×¨××©×•×Ÿ
    currentTutorialScreen = 1;
    for (let i = 1; i <= totalTutorialScreens; i++) {
        const screen = document.getElementById(`tutorial-screen-${i}`);
        if (screen) {
            screen.style.display = i === 1 ? 'block' : 'none';
        }
    }
                
    // Reset finance tip
    document.getElementById('finance-tip').style.opacity = '0';
    
    // Reset obstacle dialog tracking
    currentObstacle = null;
    lastObstacleTime = 0;
    persuasionStage = 0;
    
    // Reset powerup dialog tracking
    currentPowerup = null;
    powerupFollowupIndex = 0;
    
    // × ×§×” ×§×•×“× ××œ×× ×˜×™× ×§×™×™××™× ×©×œ ×›×•×›×‘×™×, ×¢× × ×™× ×•×¦×™×¤×•×¨×™×
    document.querySelectorAll('.star, .cloud, .bird').forEach(elem => {
        if (elem.parentNode) {
            elem.parentNode.removeChild(elem);
        }
    });
    
    // Create new stars and environmental elements
    createStars();
    createClouds();
    createBirds();
}
        
        // Handle movement events with feedback
// ×©××™×¨×ª ××™×§×•× Y ××§×•×¨×™ ×©×œ ×”×©×—×§×Ÿ
let originalPlayerY; 

function startMoving() {
    if (!isMoving) {
        isMoving = true;
        
        // ×‘×¢×ª ×”×ª×—×œ×ª ×ª× ×•×¢×”, ×¢×“×›×Ÿ ××ª ×–××Ÿ ×”××©×—×§ ×œ×”×ª×—×œ×ª ×”××“×™×“×”
        lastTimeUpdate = Date.now();
        
        // ×©××™×¨×ª ×”××™×§×•× ×”××§×•×¨×™ ×‘×¤×¢× ×”×¨××©×•× ×” ×©× ×œ×—×¥
        if (!originalPlayerY) {
            originalPlayerY = ground.y - player.height - 5; // 5px gap above ground
        }
        
        // Ensure we're showing the right emoji immediately
        updatePlayerEmoji();
        
        // Create dust particles at player's feet
        for (let i = 0; i < 3; i++) {
            setTimeout(() => {
                createDustParticle();
            }, i * 100);
        }
    }
}

// ×”×•×¡×¤×ª ×¤×•× ×§×¦×™×” ×—×“×©×” ×©×ª×¢×“×›×Ÿ ××ª ×”××™××•×’'×™ ×©×œ ×”×©×—×§×Ÿ
function updatePlayerEmoji() {
    const healthFactor = stats.physicalHealth / 100;
    const mentalFactor = stats.mentalHealth / 100;
    
    if (!isMoving) {
        // When player isn't moving, always show standing emoji
        const standingEmojis = ["ğŸ§â€â™‚ï¸", "ğŸ§â€â™€ï¸"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    } else if (healthFactor > 0.7 && mentalFactor > 0.7) {
        // Excellent health - running
        const runningEmojis = ["ğŸƒâ€â™‚ï¸", "ğŸƒâ€â™€ï¸"];
        player.emojiChar = runningEmojis[Math.floor(Math.random() * runningEmojis.length)];
    } else if (healthFactor > 0.4 && mentalFactor > 0.4) {
        // Good health - walking
        const walkingEmojis = ["ğŸš¶â€â™‚ï¸", "ğŸš¶â€â™€ï¸"];
        player.emojiChar = walkingEmojis[Math.floor(Math.random() * walkingEmojis.length)];
    } else {
        // Poor health - standing
        const standingEmojis = ["ğŸ§â€â™‚ï¸", "ğŸ§â€â™€ï¸"];
        player.emojiChar = standingEmojis[Math.floor(Math.random() * standingEmojis.length)];
    }
}

function stopMoving() {
    if (isMoving) {
        isMoving = false;
        
        // ×•×™×“×•× ×©×”×©×—×§×Ÿ ×—×•×–×¨ ×œ××™×§×•× ×”××§×•×¨×™
        player.y = originalPlayerY;
        
        // Create stopping dust effect
        createDustParticle();
    }
}
        
        // Handle window resize with smooth transitions
        function handleResize() {
            // Store old dimensions for transition calculations
            const oldWidth = canvas.width;
            const oldHeight = canvas.height;
            const oldGroundY = ground.y;
            
            // Update canvas dimensions
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            // Update ground position
            ground.y = canvas.height * 0.8;
            ground.width = canvas.width;
            ground.height = canvas.height * 0.2;
            
            // Adjust player size and position based on screen dimensions
            let scaleFactor = Math.min(window.innerWidth, window.innerHeight) / 500;
            scaleFactor = Math.max(0.5, Math.min(1.5, scaleFactor)); // Limit between 0.5 and 1.5
            
            player.width = 50 * scaleFactor;
            player.height = 80 * scaleFactor;
            
            // Maintain relative position to ground
            player.y = ground.y - player.height;
            
            // Scale player's X position proportionally to new width
            player.x = (player.x / oldWidth) * canvas.width;
            
            // Adjust player base speed for screen size
            player.baseSpeed = 5 * scaleFactor;
            updatePlayerCondition(); // Update speed based on health
            
            // Update positions of obstacles and powerups
            obstacles.forEach(obstacle => {
                // Scale X position proportionally
                obstacle.x = (obstacle.x / oldWidth) * canvas.width;
                
                // Adjust Y position relative to new ground
                const oldRelativeY = (obstacle.y - oldGroundY) / (oldHeight - oldGroundY);
                obstacle.y = ground.y + oldRelativeY * (canvas.height - ground.y);
            });
            
            powerups.forEach(powerup => {
                // Scale X position proportionally
                powerup.x = (powerup.x / oldWidth) * canvas.width;
                
                // Adjust Y position relative to new ground
                const oldRelativeY = powerup.y / oldHeight;
                powerup.y = oldRelativeY * canvas.height;
                
                // Update original Y for floating animation
                if (powerup.originalY) {
                    powerup.originalY = powerup.y;
                }
            });
            
            // Recreate environmental elements for new dimensions
            createStars();
            createClouds();
            
            // Adjust sun and moon positions
            updateCelestialBodies();
        }
        
        // Helper function to schedule obstacles
        function scheduleObstacle(delayMs) {
            pendingObstacles.push({
                time: Date.now() + delayMs
            });
        }
        
        // Mobile-specific optimizations
function optimizeForMobile() {
    const isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent);
    
    if (isMobile) {
        // Reduce visual effects for better performance
        const style = document.createElement('style');
        style.textContent = `
            @media (max-width: 768px) {
                #game-canvas {
                    image-rendering: optimizeSpeed;
                }
                .health-bars {
                    width: 220px;
                    padding: 10px;
                }
                .health-bar .label {
                    font-size: 12px;
                }
                .health-bar .bar {
                    height: 10px;
                }
                
                /* Reduce particle effects on mobile */
                .dust-particle, .powerup-particle, .companion-particle {
                    opacity: 0.7 !important;
                }

                /* Smaller celestial bodies */
                #sun, #moon {
                    width: 40px !important;
                    height: 40px !important;
                }

                /* Fewer stars for better performance */
                .star {
                    opacity: 0.5 !important;
                }
            }
        `;
document.head.appendChild(style);
                
                // Reduce number of particles in effects
                const originalCreateDustParticle = createDustParticle;
                createDustParticle = function() {
                    if (Math.random() < 0.5) { // Only create dust particles 50% of the time
                        originalCreateDustParticle();
                    }
                };
                
                // Reduce firework particles
                const originalCreateFirework = createFirework;
                createFirework = function() {
                    const tempCreate = (Math.random() < 0.8); // 80% chance to create
                    if (tempCreate) {
                        originalCreateFirework();
                    }
                };
            }
        }

        // ×¤×•× ×§×¦×™×™×ª ×¢×–×¨ ×œ×™×¦×™×¨×ª ×©×›×‘×ª ×”××¤×œ×” ×××—×•×¨×™ ×ª×™×‘×•×ª ×“×•-×©×™×—
        function createDialogOverlay() {
    const overlay = document.createElement('div');
    overlay.className = 'dialog-overlay';
    overlay.style.position = 'absolute';
    overlay.style.top = '0';
    overlay.style.left = '0';
    overlay.style.width = '100%';
    overlay.style.height = '100%';
    overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.65)';
    overlay.style.zIndex = '95';
    overlay.style.backdropFilter = 'blur(2px)';
    overlay.style.transition = 'opacity 0.3s ease';
    overlay.style.opacity = '0';
    
    document.getElementById('game-container').appendChild(overlay);
    
    // ×× ×™××¦×™×™×ª ×”×•×¤×¢×” ×”×“×¨×’×ª×™×ª
    setTimeout(() => {
        overlay.style.opacity = '1';
    }, 10);
    
    return overlay;
}
        
        // Start game with direct initialization
function startGame() {
    try {
        // ×—×©×•×‘: ×”×’×“×¨×ª canvas ×¨××©×•× ×™
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Initialize the game directly
        resetGame();

        // ××ª×—×•×œ ×¨××©×•× ×™ ×©×œ ××”×™×¨×•×ª ×”×™×•×
        updateDaySpeed();
        
        // Handle resize event
        window.removeEventListener('resize', handleResize);
        window.addEventListener('resize', handleResize);
        handleResize();
        
        // Show tutorial initially
        tutorialShown = true;
        document.getElementById('tutorial-message').style.display = 'block';
        
        // ×”×’×“×¨ ××ª ×”××©×—×§ ×œ××¦×‘ ×¨×™×¦×” ×¨×§ ××—×¨×™ ×¡×’×™×¨×ª ×”×”×“×¨×›×”
        gameRunning = false;
        
        // Add welcome message
        showWelcomeMessage();
        
        // Clear any existing game loops
        if (window.gameLoopInterval) {
            clearInterval(window.gameLoopInterval);
        }
        
        // Game loop - run at 60fps
        window.gameLoopInterval = setInterval(() => {
            if (gameRunning) {
                updateGame();
            }
        }, frameTime);
        
        console.log("Game started successfully");
    } catch (error) {
        console.error("Error starting game:", error);
    }
}
        
        // Show welcome message with enhanced visuals
function showWelcomeMessage() {
    // ×•×•×“× ×©×”××©×—×§ ××•×›×Ÿ ×œ×¤×¢×•×œ×”
    gameRunning = true;
    return;
}
        
        // Event listeners - keydown and keyup for space key
document.addEventListener('keydown', function(event) {
    if (event.code === 'Space') {
        if (tutorialShown) {
            tutorialShown = false;
            document.getElementById('tutorial-message').style.display = 'none';
        }
        // ××™×Ÿ ×™×•×ª×¨ ×”×¤×¢×œ×ª ×ª× ×•×¢×” ×¢×œ ×™×“×™ ××§×© ×”×¨×•×•×—
    }
});

document.addEventListener('keyup', function(event) {
    // ××™×Ÿ ×™×•×ª×¨ ×”×¤×¡×§×ª ×ª× ×•×¢×” ×¢×œ ×™×“×™ ××§×© ×”×¨×•×•×—
});
        
        // ×‘×™×˜×•×œ ×œ×—×™×¦×•×ª ××¡×š ×™×©×™×¨×•×ª - ×¨×§ ×›×¤×ª×•×¨ ×”×—×¥ ×™×¤×¢×™×œ ×ª× ×•×¢×”
// ×œ× × ×•×¡×™×£ ×™×•×ª×¨ ×××–×™× ×™ ××™×¨×•×¢×™× ×œ××¡×š ×”×§× ×‘×¡
// ××‘×œ × ×©××™×¨ ××ª ×”××¤×©×¨×•×ª ×œ×¡×’×•×¨ ××ª ×”×”×•×“×¢×” ×©×œ ×”×ª×—×œ×ª ×”××©×—×§ ×¢"×™ ×œ×—×™×¦×” ×¢×œ ×”××¡×š

// ×‘×™×˜×•×œ ×œ×—×™×¦×•×ª ××¡×š ×™×©×™×¨×•×ª - ×¨×§ ×›×¤×ª×•×¨ ×”×—×¥ ×™×¤×¢×™×œ ×ª× ×•×¢×”
canvas.addEventListener('touchstart', function(event) {
    // ×× ×™×¢×ª ××™×¨×•×¢×™ ××’×¢ ×¢×œ ×”×§× ×‘×¡
    event.preventDefault();
    
    // ×× ×™×© ×”×•×“×¢×ª ×”×“×¨×›×” - ×œ× ×œ×¢×©×•×ª ×›×œ×•× (×œ× ×œ×¡×’×•×¨ ××ª ×”×”×“×¨×›×”)
});

// ×××–×™×Ÿ ×œ×—×™×¦×” ×œ× ××©×¤×™×¢ ×¢×œ ×”×•×“×¢×ª ×”×”×“×¨×›×”
canvas.addEventListener('mousedown', function(event) {
    // ×”×¡×¨× ×• ××ª ×”×§×•×“ ×©××¡×ª×™×¨ ××ª ××¡×š ×”×”×“×¨×›×” ×‘×œ×—×™×¦×” ×¢×œ ×”×§× ×‘×¡
    // ×¨×§ ×›×¤×ª×•×¨×™ "×”×‘×" ×•"×”×ª×—×œ" ×™×›×•×œ×™× ×œ×©× ×•×ª ××ª ××¦×‘ ×”××“×¨×™×š
});

// ×¤×•× ×§×¦×™×” ×—×“×©×” ×œ×¢×“×›×•×Ÿ ××¦×‘ ×”×›×¤×ª×•×¨
function updateArrowButtonAttention() {
    const arrowButton = document.getElementById('forward-arrow-button');
    if (!arrowButton) return;
    
    // ×× ×”××©×—×§ ×¨×¥, ××š ×”×©×—×§×Ÿ ×œ× ×–×–, ×”×•×¡×£ ××ª ×”×× ×™××¦×™×”
    if (gameRunning && !gamePaused && !isMoving) {
        // ×‘×“×•×§ ×× ×›×‘×¨ ×™×© ××ª ×”××—×œ×§×”
        if (!arrowButton.classList.contains('attention-needed')) {
            arrowButton.classList.add('attention-needed');
        }
    } else {
        // ×”×¡×¨ ××ª ×”××—×œ×§×” ×× ×”×©×—×§×Ÿ ×–×– ××• ×”××©×—×§ ×œ× ×¤×¢×™×œ
        arrowButton.classList.remove('attention-needed');
    }
}

// ×”×•×¡×¤×ª ×××–×™× ×™ ××™×¨×•×¢×™× ×œ×›×¤×ª×•×¨ ×”×—×¥ ×¢× × ×™×¡×™×•×Ÿ ×—×•×–×¨
function setupArrowButtonEvents() {
    const arrowButton = document.getElementById('forward-arrow-button');
    if (!arrowButton) {
        // ×× ×”×›×¤×ª×•×¨ ×œ× × ××¦×, × × ×¡×” ×©×•×‘ ×‘×¢×•×“ ×—×¦×™ ×©× ×™×™×”
        console.log("Arrow button not found, retrying in 500ms");
        setTimeout(setupArrowButtonEvents, 500);
        return;
    }
    
    // × ×™×§×•×™ ×××–×™× ×™× ×§×•×“××™× ×œ×× ×™×¢×ª ×›×¤×™×œ×•×™×•×ª
    const newArrowButton = arrowButton.cloneNode(true);
    if (arrowButton.parentNode) {
        arrowButton.parentNode.replaceChild(newArrowButton, arrowButton);
    }
    
    // ×”×•×¡×¤×ª ×××–×™× ×™× ×œ×¢×•×ª×§ ×”×—×“×©
    newArrowButton.addEventListener('mousedown', function(event) {
        if (gameRunning && !gamePaused) {
            startMoving();
        }
    });

    newArrowButton.addEventListener('mouseup', function(event) {
        if (gameRunning && !gamePaused) {
            stopMoving();
        }
    });

    newArrowButton.addEventListener('touchstart', function(event) {
    if (gameRunning && !gamePaused) {
        event.preventDefault(); // ×× ×™×¢×ª ×”×ª× ×”×’×•×ª ×‘×¨×™×¨×ª ××—×“×œ ×©×œ ××’×¢
        event.stopPropagation(); // ×¢×¦×™×¨×ª ×”×¤×¦×ª ×”××™×¨×•×¢
        startMoving();
    }
});

newArrowButton.addEventListener('touchend', function(event) {
    if (gameRunning && !gamePaused) {
        event.preventDefault();
        event.stopPropagation(); // ×¢×¦×™×¨×ª ×”×¤×¦×ª ×”××™×¨×•×¢
        stopMoving();
    }
});

    // ×”×•×¡×¤×ª ×××–×™×Ÿ ×œ××§×¨×” ×©×”××©×ª××© ×¢×•×–×‘ ××ª ×”×›×¤×ª×•×¨ ×‘×××¦×¢ ×œ×—×™×¦×”
    newArrowButton.addEventListener('mouseleave', function(event) {
        if (gameRunning && !gamePaused && isMoving) {
            stopMoving();
        }
    });
    
    console.log("Arrow button event listeners setup complete");
}

// Obstacle dialog buttons
document.getElementById('ignore-btn').addEventListener('click', function() {
    continuePersuasion(); // Continue to next persuasion stage or close dialog
});
        
        document.getElementById('accept-btn').addEventListener('click', function() {
            acceptObstacle(); // Accept obstacle with all negative consequences
        });
        
        // Powerup dialog buttons
        document.getElementById('powerup-yes-btn').addEventListener('click', function() {
            powerupYesResponse();
        });
        
        document.getElementById('powerup-no-btn').addEventListener('click', function() {
            powerupNoResponse();
        });
        
        // ××¢×§×‘ ××—×¨ ×”××¡×š ×”× ×•×›×—×™ ×‘××“×¨×™×š
let currentTutorialScreen = 1;
const totalTutorialScreens = 7; // ×¢×•×“×›×Ÿ ×-6 ×œ-7 ×‘×’×œ×œ ×”×•×¡×¤×ª ××¡×š
let playerGender = "male"; // ×‘×¨×™×¨×ª ××—×“×œ

// ××¢×‘×¨ ×œ××¡×š ×”×‘× ×‘××“×¨×™×š
function nextTutorialScreen() {
    // ×”×¡×ª×¨ ××ª ×”××¡×š ×”× ×•×›×—×™
    const currentScreen = document.getElementById(`tutorial-screen-${currentTutorialScreen}`);
    if (currentScreen) {
        currentScreen.style.display = 'none';
    }
    
    // ×¢×‘×•×¨ ×œ××¡×š ×”×‘×
    currentTutorialScreen++;
    
    // ×”×¦×’ ××ª ×”××¡×š ×”×‘× ×× ×§×™×™×
    if (currentTutorialScreen <= totalTutorialScreens) {
        const nextScreen = document.getElementById(`tutorial-screen-${currentTutorialScreen}`);
        if (nextScreen) {
            nextScreen.style.display = 'block';
        }
    }
}

// ×”×•×¡×£ ×××–×™× ×™ ××™×¨×•×¢×™× ×œ×›×¤×ª×•×¨×™ "×”×‘×"
document.querySelectorAll('.next-btn').forEach(button => {
    button.addEventListener('click', function() {
        // ×× ×™××¦×™×™×ª ×œ×—×™×¦×”
        this.style.transform = 'scale(0.95)';
        
        // ×”×©×”×™×” ×§×¦×¨×” ×œ××¤×§×˜ ×”×œ×—×™×¦×”
        setTimeout(() => {
            this.style.transform = '';
            nextTutorialScreen();
        }, 100);
    });
});

// ×”×•×¡×£ ×××–×™× ×™ ××™×¨×•×¢×™× ×œ×›×¤×ª×•×¨×™ ×‘×—×™×¨×ª ××™×Ÿ
document.getElementById('male-btn').addEventListener('click', function() {
    playerGender = "male";
    this.style.transform = 'scale(0.95)';
    
    setTimeout(() => {
        this.style.transform = '';
        nextTutorialScreen();
    }, 100);
});

document.getElementById('female-btn').addEventListener('click', function() {
    playerGender = "female";
    this.style.transform = 'scale(0.95)';
    
    setTimeout(() => {
        this.style.transform = '';
        nextTutorialScreen();
    }, 100);
});

// Start button click
document.getElementById('start-btn').addEventListener('click', function() {
    tutorialShown = false;
    
    // Add button press animation
    const button = document.getElementById('start-btn');
    button.style.transform = 'scale(0.95)';
    button.style.backgroundColor = '#1e5180';
    
    // Reset after short delay
    setTimeout(() => {
        button.style.transform = '';
        button.style.backgroundColor = '';
        
        // Hide tutorial immediately without fade
        const tutorial = document.getElementById('tutorial-message');
        tutorial.style.display = 'none';
        
        // ×”×¦×’ ××ª ×œ×•×— ×”××—×•×•× ×™× ×•×›×¤×ª×•×¨ ×”×—×¥ ×¨×§ ×›××©×¨ ×”××©×—×§ ××ª×—×™×œ ×‘×××ª
        document.querySelector('.dashboard-container').style.display = 'block';
        document.getElementById('forward-arrow-button').style.display = 'block';
        
        // Make sure the game is running
        gameRunning = true;
        console.log("Game set to running state");
        
        // Update critical game state
        lastTimeUpdate = Date.now(); // ×—×™×“×•×© ×–××Ÿ ×”×ª×—×œ×ª×™
        
        // ××ª×—×•×œ ×©×¢×•×Ÿ ×”××©×—×§
        currentHour = 5;
        currentMinute = 0;
        
        // Update the display and player condition
        updateDisplay();
        updatePlayerCondition();
        
        // ×•×“× ×©×œ×•×œ××ª ×”××©×—×§ ×¤×•×¢×œ×ª
        if (!window.gameLoopInterval) {
            window.gameLoopInterval = setInterval(() => {
                if (gameRunning) {
                    updateGame();
                }
            }, frameTime);
            console.log("Game loop started");
        }
    }, 100);
});

// ×× ×™×¢×ª ×¡×’×™×¨×ª ××¡×š ×”×”×“×¨×›×” ×‘×œ×—×™×¦×” ×¢×œ ×”××–×•×¨ ×©×œ×• (××‘×œ ×œ× ×¢×œ ×”×›×¤×ª×•×¨×™×)
document.getElementById('tutorial-message').addEventListener('mousedown', function(event) {
    // ×× ×”×œ×—×™×¦×” ×œ× ×¢×œ ××—×“ ×”×›×¤×ª×•×¨×™×, ×× ×¢ ×©×™×‘×•×¢ (bubbling) ×©×œ ×”××™×¨×•×¢
    if (!event.target.classList.contains('next-btn') && event.target.id !== 'start-btn') {
        event.stopPropagation();
    }
});

// ×’× ×œ××§×¨×” ×©×œ ××›×©×™×¨×™ ××’×¢
document.getElementById('tutorial-message').addEventListener('touchstart', function(event) {
    // ×× ×”× ×’×™×¢×” ×œ× ×¢×œ ××—×“ ×”×›×¤×ª×•×¨×™×, ×× ×¢ ×©×™×‘×•×¢ (bubbling) ×•×¤×¢×•×œ×ª ×‘×¨×™×¨×ª ××—×“×œ
    if (!event.target.classList.contains('next-btn') && event.target.id !== 'start-btn') {
        event.stopPropagation();
        event.preventDefault();
    }
});
        
        // Job offer buttons
        document.getElementById('yes-btn').addEventListener('click', function() {
            gameOver("×”×—×œ×¤×ª ×§×¨×™×™×¨×”. ××™×‘×“×ª ××ª ×”×™×¦×™×‘×•×ª ×”×¤×™× × ×¡×™×ª ×‘×ª×§×•×¤×ª ×”××¢×‘×¨.");
        });
        
        document.getElementById('no-btn').addEventListener('click', function() {
            showJobOfferFollowup();
        });
        
        document.getElementById('followup-yes-btn').addEventListener('click', function() {
            gameOver("×”×—×œ×¤×ª ×§×¨×™×™×¨×”. ××™×‘×“×ª ××ª ×”×™×¦×™×‘×•×ª ×”×¤×™× × ×¡×™×ª ×‘×ª×§×•×¤×ª ×”××¢×‘×¨.");
        });
        
        document.getElementById('followup-no-btn').addEventListener('click', function() {
            jobOfferStage++;
            if (jobOfferStage < jobOfferTexts.length) {
                // Update text with animation
                const textElement = document.getElementById('followup-text');
                
                // Fade out current text
                textElement.style.transition = 'opacity 0.2s ease, transform 0.2s ease';
                textElement.style.opacity = '0';
                textElement.style.transform = 'translateY(-10px)';
                
                // Update text and fade in
                setTimeout(() => {
                    textElement.textContent = jobOfferTexts[jobOfferStage];
                    textElement.style.opacity = '1';
                    textElement.style.transform = 'translateY(0)';
                }, 200);
                
                // Update icon
                const icon = document.querySelector('.persuasion-icon');
                if (icon) {
                    // Animate icon change
                    icon.style.transform = 'translateX(-50%) scale(0.8)';
                    icon.style.opacity = '0.5';
                    
                    setTimeout(() => {
                        // Change icon based on stage
                        let persuasionIcon = 'ğŸ’°'; // Default money
                        if (jobOfferStage === 1) persuasionIcon = 'ğŸ“ˆ'; // Growth
                        if (jobOfferStage === 2) persuasionIcon = 'ğŸš€'; // Career
                        if (jobOfferStage === 3) persuasionIcon = 'â±ï¸'; // Time/flexibility
                        
                        icon.textContent = persuasionIcon;
                        icon.style.transform = 'translateX(-50%) scale(1.2)';
                        icon.style.opacity = '1';
                        
                        // Reset after animation
                        setTimeout(() => {
                            icon.style.transform = 'translateX(-50%) scale(1)';
                        }, 200);
                    }, 200);
                }
            } else {
                // Exit animation for dialog
                const followupDialog = document.getElementById('job-offer-followup');
                followupDialog.style.animation = 'job-followup-exit 0.3s ease forwards';
                
                // Add exit animation style if not already present
                if (!document.getElementById('job-followup-exit-style')) {
                    const style = document.createElement('style');
                    style.id = 'job-followup-exit-style';
                    style.textContent = `
                        @keyframes job-followup-exit {
                            from {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1);
                            }
                            to {
                                opacity: 0;
                                transform: translate(-50%, -40%) scale(0.95);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Remove overlay
                const overlay = document.querySelector('.job-offer-overlay');
                if (overlay) {
                    overlay.style.opacity = '0';
                    setTimeout(() => {
                        if (overlay.parentNode) {
                            overlay.parentNode.removeChild(overlay);
                        }
                    }, 500);
                }
                
                // Hide dialog after animation
                setTimeout(() => {
                    followupDialog.style.display = 'none';
                    
                    // Remove icon
                    const icon = document.querySelector('.persuasion-icon');
                    if (icon && icon.parentNode) {
                        icon.parentNode.removeChild(icon);
                    }
                    
                    gamePaused = false;
                    
                    // Reward player for resisting temptation
                    score += 1500;
                    
                    // Also boost mental health
                    stats.mentalHealth = Math.min(100, stats.mentalHealth + 10);
                    updatePlayerCondition();
                    
                    // Show reward effect
                    showCoinAnimation(1500);
                    showPopupMessage("×ª×’××•×œ ×¢×œ ×”×ª××“×” ×‘×§×¨×™×™×¨×”: 1,500 ×©\"×—", 2500);
                    updateDisplay();
                }, 300);
            }
        });
        
        // Game over buttons
        document.getElementById('restart-btn').addEventListener('click', function() {
            // Button press animation
            const button = document.getElementById('restart-btn');
            button.style.transform = 'scale(0.95)';
            
            // Reset after short delay
            setTimeout(() => {
                button.style.transform = '';
                resetGame();
            }, 100);
        });
        
        document.getElementById('play-again-btn').addEventListener('click', function() {
            // Button press animation
            const button = document.getElementById('play-again-btn');
            button.style.transform = 'scale(0.95)';
            
            // Reset after short delay
            setTimeout(() => {
                button.style.transform = '';
                resetGame();
            }, 100);
        });

        // ×‘×“×™×§×ª ××¦×‘ ×”×“×£ ×•××ª×—×•×œ ×¨×§ ×›××©×¨ ×”×“×£ ×˜×¢×•×Ÿ ×‘××œ×•××•
if (document.readyState === "complete" || document.readyState === "interactive") {
    setTimeout(initializeGame, 500); // ×”××¨×›×ª ×”×”×©×”×™×” ×œ×•×•×“× ×˜×¢×™× ×” ××œ××”
} else {
    document.addEventListener("DOMContentLoaded", function() {
        setTimeout(initializeGame, 500); // ×”××¨×›×ª ×”×”×©×”×™×” ×œ×•×•×“× ×˜×¢×™× ×” ××œ××”
    });
}

function initializeGame() {
    console.log("Initializing game...");
    
    // ×•×™×“× ×©×”×§× ×‘×¡ ×§×™×™× ×•××•×’×“×¨
    if (!canvas) {
        console.error("Canvas not found!");
        return;
    }
    
    // ××ª×—×•×œ ××—×“×© ×©×œ ×”×§× ×‘×¡
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    // ×•×™×“×•× ×©×›×œ ×”××©×ª× ×™× ×”×—×™×•× ×™×™× ××•×’×“×¨×™×
    if (!ground || !player || !ctx) {
        console.error("Essential game variables not defined!");
        return;
    }
    
    optimizeForMobile();
    createStars();
    createClouds();
    setupArrowButtonEvents();

    // ××ª×—×•×œ ××¡×›×™ ×”××“×¨×™×š ××—×“×© - ×”×¦×’ ×¨×§ ××ª ×”×¨××©×•×Ÿ
currentTutorialScreen = 1;
for (let i = 1; i <= totalTutorialScreens; i++) {
    const screen = document.getElementById(`tutorial-screen-${i}`);
    if (screen) {
        screen.style.display = i === 1 ? 'block' : 'none';
    }
}

    // ×•×™×“×•× ×©×”××©×—×§ ×××•×ª×—×œ ×œ×¤× ×™ ×”×¤×¢×œ×ª×•
    lastTimeUpdate = Date.now();
    gameRunning = false; // ×©×™× ×•×™: ×”××©×—×§ ×œ× ×¨×¥ ×¢×“ ×œ×œ×—×™×¦×” ×¢×œ "×”×ª×—×œ"

    // ×”×•×¡×£ ×‘×“×™×§×” ×ª×§×•×¤×ª×™×ª ×œ×›×¤×ª×•×¨ ×”×—×¥
    setInterval(updateArrowButtonAttention, 1000);

    // ×”×•×¡×£ ×××–×™×Ÿ ××™×¨×•×¢ ×œ×œ×—×™×¦×” ×¢×œ ×›×•×ª×¨×ª ×œ×•×— ×”××—×•×•× ×™×
    document.querySelector('.dashboard-header').addEventListener('click', function() {
        document.querySelector('.dashboard-container').classList.toggle('dashboard-collapsed');
    });

    startGame();
    console.log("Game initialization complete");
}

// ×œ× ×œ×§×¨×•× ×œ×¤×•× ×§×¦×™×•×ª ××œ×” ×™×©×™×¨×•×ª ×›××Ÿ
// optimizeForMobile();
// createStars();
// createClouds();
// setupArrowButtonEvents();
// startGame();
    </script>
</body>
</html>
