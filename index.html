<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>砖拽 砖注转 驻住转</title>
    <link href="https://fonts.googleapis.com/css2?family=Open+Sans:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --primary-color: #2a6496;
            --secondary-color: #4a4a4a;
            --success-color: #3a7a5f;
            --warning-color: #d3873e;
            --danger-color: #d45b5b;
            --background-color: #f8f9fa;
            --card-color: rgba(255, 255, 255, 0.95);
            --text-color: #333333;
            --text-light: #ffffff;
            --day-sky-color-start: #87CEEB;
            --day-sky-color-end: #ADD8E6;
            --night-sky-color-start: #1a2238;
            --night-sky-color-end: #283655;
            --sunset-sky-color-start: #FF7F50;
            --sunset-sky-color-end: #FFD700;
            --sunrise-sky-color-start: #FF7F50;
            --sunrise-sky-color-end: #ADD8E6;
        }
        
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--background-color);
            font-family: 'Open Sans', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: var(--text-color);
            transition: background-color 0.5s ease;
        }
        
        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }
        
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;
            transition: filter 2s ease; /* Smooth transition for day/night filter */
        }
        
        .game-display {
            position: absolute;
            padding: 10px 15px;
            background-color: rgba(255, 255, 255, 0.9);
            border-radius: 5px;
            font-size: 16px;
            font-weight: 600;
            z-index: 10;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        #score-display {
            top: 15px;
            right: 15px;
            color: var(--primary-color);
        }
        
        #date-display {
            top: 15px;
            left: 15px;
            color: var(--secondary-color);
        }
        
        #monthly-stats {
            position: absolute;
            top: 60px;
            right: 15px;
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            font-size: 14px;
            line-height: 1.6;
            z-index: 10;
        }
        
        #monthly-stats div {
            margin-bottom: 5px;
        }
        
        #tutorial-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 25px;
            background-color: var(--card-color);
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            max-width: 80%;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.15);
            line-height: 1.6;
        }
        
        .dialog-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            line-height: 1.6;
            animation: dialog-appear 0.3s ease-out forwards;
        }
        
        @keyframes dialog-appear {
            from {
                opacity: 0;
                transform: translate(-50%, -40%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        .dialog-box h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
            font-size: 20px;
        }
        
        .dialog-box p {
            margin: 15px 0;
            font-size: 16px;
        }
        
        .dialog-box button {
            margin: 8px;
            padding: 10px 20px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
            min-width: 100px;
        }
        
        .dialog-box button:hover {
            background-color: #1e5180;
            transform: translateY(-2px);
        }
        
        .dialog-box button.no-btn {
            background-color: var(--danger-color);
        }
        
        .dialog-box button.no-btn:hover {
            background-color: #c04848;
        }
        
        #obstacle-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            animation: bounce-in 0.5s ease-out forwards;
        }
        
        @keyframes bounce-in {
            0% {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            70% {
                opacity: 1;
                transform: translate(-50%, -48%);
            }
            100% {
                transform: translate(-50%, -50%);
            }
        }
        
        #obstacle-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #obstacle-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #obstacle-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 120px;
        }
        
        #ignore-btn {
            background-color: var(--success-color);
            color: white;
        }
        
        #accept-btn {
            background-color: var(--warning-color);
            color: white;
        }
        
        #ignore-btn:hover {
            background-color: #2c6a4f;
            transform: translateY(-2px);
        }
        
        #accept-btn:hover {
            background-color: #c77730;
            transform: translateY(-2px);
        }
        
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(50, 50, 50, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: fade-in 0.7s ease-out forwards;
        }
        
        @keyframes fade-in {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        #game-over h2,
        #win-screen h2 {
            font-size: 24px;
            margin-top: 0;
            margin-bottom: 20px;
        }
        
        #game-over button,
        #win-screen button {
            margin-top: 25px;
            padding: 12px 28px;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: background-color 0.3s, transform 0.1s;
        }
        
        #game-over button:hover,
        #win-screen button:hover {
            background-color: #1e5180;
            transform: translateY(-2px);
        }
        
        #win-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(42, 100, 150, 0.95);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 500px;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            line-height: 1.6;
            animation: scale-in 0.6s ease-out forwards;
        }
        
        @keyframes scale-in {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }
        
        .popup-message {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background-color: rgba(50, 50, 50, 0.9);
            color: white;
            border-radius: 25px;
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 20;
            max-width: 80%;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
        }
        
        .power-meter {
            position: absolute;
            bottom: 25px;
            left: 20px;
            width: 200px;
            height: 12px;
            background-color: rgba(255, 255, 255, 0.3);
            border-radius: 6px;
            overflow: hidden;
            display: none;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        
        .power-meter-fill {
            height: 100%;
            background-color: var(--success-color);
            width: 0%;
            transition: width 0.1s linear;
        }
        
        .status-effect {
            position: absolute;
            top: 50%;  /* Center vertically */
            left: 50%;  /* Center horizontally */
            transform: translate(-50%, 150px);  /* Adjust vertical position */
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            font-size: 14px;
            display: none;
            margin: 0 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            z-index: 15;
            animation: status-effect-appear 0.4s ease forwards;
        }
        
        @keyframes status-effect-appear {
            from {
                opacity: 0;
                transform: translate(-50%, 170px);
            }
            to {
                opacity: 1;
                transform: translate(-50%, 150px);
            }
        }
        
        #status-negative {
            background-color: rgba(212, 91, 91, 0.9);
        }
        
        #status-weight {
            background-color: rgba(211, 135, 62, 0.9);
        }
        
        #speed-indicator {
            position: absolute;
            bottom: 25px;
            right: 20px;
            padding: 8px 15px;
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
            transition: background-color 0.3s ease;
        }
        
        #movement-instruction {
            position: absolute;
            top: 50%; 
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            background-color: rgba(50, 50, 50, 0.8);
            color: white;
            border-radius: 8px;
            font-size: 24px;
            font-weight: bold;
            display: none;
            z-index: 25;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            text-align: center;
            max-width: 80%;
            animation: pulse 1.5s infinite alternate;
        }
        
        @keyframes pulse {
            from { transform: translate(-50%, -50%) scale(1); }
            to { transform: translate(-50%, -50%) scale(1.05); }
        }
        
        /* Health indicators in center */
        .health-bars {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            width: 260px;
            text-align: center;
            transition: all 0.3s ease;
        }
        
        .health-bar {
            margin-bottom: 15px;
        }
        
        .health-bar .label {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--secondary-color);
        }
        
        .health-bar .bar {
            width: 100%;
            height: 12px;
            background-color: #e9ecef;
            border-radius: 6px;
            overflow: hidden;
        }
        
        .health-bar .fill {
            height: 100%;
            transition: width 0.3s ease;
        }
        
        #physical-health-fill {
            background-color: var(--success-color);
        }
        
        #mental-health-fill {
            background-color: var(--primary-color);
        }
        
        .day-clock-container {
            margin-top: 15px;
            text-align: center;
        }
        
        #day-clock {
            font-size: 24px;
            font-weight: bold;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 15px;
            border-radius: 5px;
            display: inline-block;
            margin-top: 5px;
            transition: transform 0.3s ease;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
        }
        
        #day-clock:hover {
            transform: scale(1.05);
        }
        
        .clock-icon {
            display: inline-block;
            margin-right: 5px;
            font-size: 18px;
        }
        .finance-tip {
            position: absolute;
            bottom: 25px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: rgba(42, 100, 150, 0.85);
            color: white;
            border-radius: 5px;
            font-size: 14px;
            max-width: 80%;
            text-align: center;
            line-height: 1.4;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 15;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }
        
        #powerup-dialog {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: var(--card-color);
            border: 1px solid #dee2e6;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            z-index: 100;
            display: none;
            width: 80%;
            max-width: 450px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.15);
            animation: slide-in 0.4s ease forwards;
        }
        
        @keyframes slide-in {
            from {
                opacity: 0;
                transform: translate(-50%, -60%);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%);
            }
        }
        
        #powerup-dialog h3 {
            margin-top: 0;
            color: var(--primary-color);
            font-weight: 600;
        }
        
        #powerup-dialog p {
            font-size: 16px;
            margin: 15px 0;
            line-height: 1.6;
        }
        
        #powerup-dialog button {
            margin: 8px;
            padding: 10px 20px;
            font-size: 16px;
            font-weight: 600;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s;
            min-width: 80px;
        }
        
        #powerup-yes-btn {
            background-color: var(--success-color);
            color: white;
        }
        
        #powerup-no-btn {
            background-color: var(--danger-color);
            color: white;
        }
        
        #powerup-yes-btn:hover {
            background-color: #2c6a4f;
            transform: translateY(-2px);
        }
        
        #powerup-no-btn:hover {
            background-color: #c04848;
            transform: translateY(-2px);
        }
        
        .achievements-panel {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 10px 15px;
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            z-index: 10;
            display: none;
            text-align: center;
        }
        
        .achievement {
            margin: 5px 0;
            font-size: 14px;
            color: var(--primary-color);
            font-weight: 600;
            animation: achievement-pop 0.5s ease-out forwards;
        }
        
        @keyframes achievement-pop {
            0% {
                opacity: 0;
                transform: scale(0.8);
            }
            50% {
                opacity: 1;
                transform: scale(1.1);
            }
            100% {
                transform: scale(1);
            }
        }
        
        /* Sun and Moon */
        #sun {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 60px;
            height: 60px;
            background: radial-gradient(circle, #FFD700 40%, rgba(255, 215, 0, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
            z-index: 5;
            opacity: 1;
            transition: all 2s ease;
        }
        
        #moon {
            position: absolute;
            top: 60px;
            right: 100px;
            width: 50px;
            height: 50px;
            background: radial-gradient(circle, #E6E6FA 40%, rgba(230, 230, 250, 0) 70%);
            border-radius: 50%;
            box-shadow: 0 0 15px rgba(230, 230, 250, 0.5);
            z-index: 5;
            opacity: 0;
            transition: all 2s ease;
        }
        
        /* Moon shadow effect */
        #moon::before {
            content: '';
            position: absolute;
            top: 10px;
            left: 10px;
            width: 45px;
            height: 45px;
            background: radial-gradient(circle, rgba(0, 0, 0, 0.1) 40%, rgba(0, 0, 0, 0) 70%);
            border-radius: 50%;
        }
        
        /* Stars in night sky */
        .star {
            position: absolute;
            background-color: white;
            border-radius: 50%;
            opacity: 0;
            transition: opacity 2s ease;
            animation: twinkle 3s infinite alternate;
            z-index: 4;
        }
        
        @keyframes twinkle {
            from { opacity: 0.2; }
            to { opacity: 0.8; }
        }
        
        /* Weather effects */
        .cloud {
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
            z-index: 6;
            transition: all 1s ease;
            opacity: 0;
        }
        
        .cloud::before,
        .cloud::after {
            content: '';
            position: absolute;
            background: rgba(255, 255, 255, 0.7);
            border-radius: 50%;
        }
        
        .bird {
            position: absolute;
            z-index: 6;
            transition: all 0.5s ease;
            opacity: 0;
        }
        
        /* Day/Night cycle overlay */
        #day-night-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 30, 0);
            z-index: 3;
            pointer-events: none;
            transition: background-color 2s ease;
        }
        
        @media (max-width: 768px) {
            .game-display {
                font-size: 14px;
                padding: 8px 12px;
            }
            
            .dialog-box {
                width: 90%;
                max-width: 400px;
                padding: 20px;
            }
            
            .dialog-box h3 {
                font-size: 18px;
            }
            
            .dialog-box p {
                font-size: 14px;
            }
            
            .dialog-box button {
                padding: 8px 16px;
                font-size: 14px;
            }
            
            #tutorial-message {
                font-size: 14px;
                max-width: 95%;
                padding: 20px;
            }
            
            .power-meter {
                width: 150px;
                height: 10px;
            }
            
            #obstacle-dialog {
                width: 90%;
                max-width: 400px;
                padding: 20px;
            }
            
            #obstacle-dialog p {
                font-size: 14px;
            }
            
            .health-bars {
                width: 220px;
                padding: 12px;
                top: 100px;
            }
            
            .finance-tip {
                font-size: 12px;
                padding: 8px 16px;
            }
            
            #day-clock {
                font-size: 20px;
                padding: 4px 12px;
            }
            
            #sun, #moon {
                width: 40px;
                height: 40px;
                right: 60px;
                top: 40px;
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <!-- Day/Night cycle overlay -->
        <div id="day-night-overlay"></div>
        
        <!-- Sun and Moon -->
        <div id="sun"></div>
        <div id="moon"></div>
        
        <div id="score-display" class="game-display">住 住 驻住: 0 砖"</div>
        <div id="date-display" class="game-display">专抓 2025</div>
        
        <div id="monthly-stats">
            <div>爪转 砖转: <span id="expenses">0</span> 砖"</div>
            <div>住 砖转: <span id="income">5,000</span> 砖"</div>
        </div>
        
        <div class="health-bars">
            <div class="health-bar">
                <div class="label">专转 驻转</div>
                <div class="bar">
                    <div id="physical-health-fill" class="fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="health-bar">
                <div class="label">专转 转</div>
                <div class="bar">
                    <div id="mental-health-fill" class="fill" style="width: 100%;"></div>
                </div>
            </div>
            <div class="day-clock-container">
                <div class="label">砖注  <span class="clock-icon"></span></div>
                <div id="day-clock">05:00</div>
            </div>
        </div>
        
        <div id="achievements" class="achievements-panel"></div>
        
        <div id="power-meter" class="power-meter">
            <div id="power-meter-fill" class="power-meter-fill"></div>
        </div>
        
        <div id="popup-message" class="popup-message"></div>
        <div id="finance-tip" class="finance-tip"></div>
        
        <div id="status-negative" class="status-effect">砖驻注 转: 砖</div>
        <div id="status-weight" class="status-effect">爪 驻: </div>
        <div id="speed-indicator">专转: 专</div>
        <div id="movement-instruction">抓 注 住  转拽!<br><span style="font-size: 16px; font-weight: normal; opacity: 0.9;"> 爪  转拽转</span></div>
        
        <!--  驻专-驻 -->
        <div id="powerup-dialog" class="dialog-box">
            <h3 id="powerup-title">转拽转 转 砖驻专!</h3>
            <p id="powerup-text"> 注砖转  专 ?</p>
            <button id="powerup-yes-btn"></button>
            <button id="powerup-no-btn"></button>
        </div>
        
        <!--  砖 -->
        <div id="obstacle-dialog" class="dialog-box">
            <h3 id="obstacle-title">转转 注  驻住转</h3>
            <p id="obstacle-text"> 专 爪 转  砖 转转 住?</p>
            <button id="ignore-btn">住专</button>
            <button id="accept-btn">住</button>
        </div>
        
        <div id="tutorial-message">
            <h3>专  砖拽 砖注转 驻住转</h3>
            <p>专 砖  爪专 100,000 砖" 爪注转 转 转 驻住转 转.</p>
            <p>抓 注 住 ( 拽 拽砖 专)  转拽 专 驻住转. 转拽转 专砖转 抓 转.</p>
            <p>转 专 5,000 砖" 砖 注 爪 砖,  转转拽 转 驻转 专 专.</p>
            <p>拽爪 转拽转 砖 砖驻注 爪 驻 .</p>
            <p>专 - 爪转 驻住转  专转,  住驻专. 专砖转 砖注转 转 专 .</p>
            <button id="start-btn">转</button>
        </div>
        
        <div id="job-offer" class="dialog-box">
            <h3>转 拽专专 砖</h3>
            <p> 专 拽专专 注 砖专  转专  驻转 爪转?</p>
            <button id="yes-btn"></button>
            <button id="no-btn" class="no-btn"></button>
        </div>
        
        <div id="job-offer-followup" class="dialog-box">
            <h3>砖拽 砖 转 转</h3>
            <p id="followup-text"> 转  砖专爪 转 转 ?</p>
            <button id="followup-yes-btn"></button>
            <button id="followup-no-btn" class="no-btn"></button>
        </div>
        
        <div id="game-over">
            <h2> 驻住 砖</h2>
            <p id="game-over-reason"></p>
            <p>爪专转 住 砖 <span id="final-score">0</span> 砖" 住 驻住</p>
            <div id="game-stats">
                <p>转拽驻 砖: <span id="months-played">0</span> 砖</p>
                <p>专 驻住 : <span id="powerups-collected">0</span></p>
                <p>转 驻住转 砖驻转专: <span id="obstacles-avoided">0</span></p>
            </div>
            <p class="lesson">拽: 爪转 驻住转 专砖转 砖注转, 转 专  转 砖转.</p>
            <button id="restart-btn">住 砖</button>
        </div>
        
        <div id="win-screen">
            <h2>爪转 驻住转 砖!</h2>
            <p>爪转 爪专 100,000 砖" 住 驻住!</p>
            <p>  注 砖注转 注爪转, 转 拽转 转 转.</p>
            <div id="win-stats">
                <p>转拽驻转 爪专转 住: <span id="win-months">0</span> 砖</p>
                <p>专 驻住 : <span id="win-powerups">0</span></p>
                <p>转 驻住转 砖驻转专: <span id="win-obstacles">0</span></p>
            </div>
            <p class="lesson">专: 爪转 驻住转  转 转砖 专砖 转 转 砖转.</p>
            <button id="play-again-btn">住 住祝</button>
        </div>
    </div>
    <script>
        // Canvas and context setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to cover the window
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game variables
        let gameRunning = false;
        let gamePaused = false;
        let score = 0;
        let currentMonth = 0;
        let tutorialShown = true;
        let isMoving = false; // Movement control
        let moveTimer = null; // For instruction display timing
        let financeMessageTimer = null; // For finance tips display
        
        // Day/Night cycle variables
        let currentHour = 5; // Starting at 5:00 AM
        let currentMinute = 0;
        let dayProgress = 0; // 0 to 1 for day cycle
        let isDayTime = true;
        let timeMultiplier = 2.4; // 2.4 hours per real second (24h in 10 seconds)
        let lastTimeUpdate = Date.now();
        let stars = [];
        let clouds = [];
        let birds = [];
        
        // Create stars
        function createStars() {
            stars = [];
            const starCount = Math.min(50, Math.floor(window.innerWidth * window.innerHeight / 10000)); // Adjust based on screen size
            
            for (let i = 0; i < starCount; i++) {
                const star = {
                    x: Math.random() * canvas.width,
                    y: Math.random() * (canvas.height * 0.7), // Only in the sky area
                    size: Math.random() * 2 + 1, // 1-3px
                    twinkleSpeed: Math.random() * 2 + 1 // Variation in twinkle speed
                };
                stars.push(star);
            }
        }
        
        // Create clouds
        function createClouds() {
            clouds = [];
            const cloudCount = Math.min(5, Math.floor(window.innerWidth / 400)); // Adjust based on screen width
            
            for (let i = 0; i < cloudCount; i++) {
                createCloud();
            }
        }
        
        // Create a single cloud
        function createCloud() {
            const cloud = document.createElement('div');
            cloud.className = 'cloud';
            
            // Random cloud size and position
            const size = Math.random() * 40 + 60; // 60-100px
            const top = Math.random() * (canvas.height * 0.3) + 50; // Top half of sky
            const left = Math.random() * canvas.width;
            
            cloud.style.width = `${size}px`;
            cloud.style.height = `${size / 2}px`;
            cloud.style.top = `${top}px`;
            cloud.style.left = `${left}px`;
            
            // Create cloud shape with pseudo-elements
            cloud.style.boxShadow = '0 0 10px rgba(255, 255, 255, 0.3)';
            
            // Speed will determine how fast the cloud moves across the screen
            const speed = Math.random() * 0.05 + 0.01; // pixels per millisecond
            cloud.dataset.speed = speed;
            cloud.dataset.position = left;
            
            document.getElementById('game-container').appendChild(cloud);
            clouds.push(cloud);
            
            // Set initial opacity based on time of day
            updateCloudVisibility();
        }
        
        // Create birds
        function createBirds() {
            birds = [];
            const birdCount = Math.min(3, Math.floor(window.innerWidth / 500)); // Adjust based on screen width
            
            for (let i = 0; i < birdCount; i++) {
                if (Math.random() < 0.7) { // 70% chance to create a bird
                    createBird();
                }
            }
        }
        
        // Create a single bird
        function createBird() {
            const bird = document.createElement('div');
            bird.className = 'bird';
            
            // Create SVG for bird
            const birdSize = Math.random() * 10 + 15; // 15-25px
            bird.innerHTML = `
                <svg width="${birdSize}" height="${birdSize}" viewBox="0 0 100 100">
                    <path d="M10,50 Q30,30 50,50 Q70,30 90,50" stroke="#333" fill="transparent" stroke-width="5"/>
                </svg>
            `;
            
            // Random position
            const top = Math.random() * (canvas.height * 0.4) + 50; // Upper half of sky
            const left = -birdSize;
            
            bird.style.top = `${top}px`;
            bird.style.left = `${left}px`;
            
            // Speed will determine how fast the bird moves across the screen
            const speed = Math.random() * 0.08 + 0.05; // pixels per millisecond
            bird.dataset.speed = speed;
            bird.dataset.position = left;
            
            document.getElementById('game-container').appendChild(bird);
            birds.push(bird);
            
            // Only show birds during the day
            bird.style.opacity = isDayTime ? '1' : '0';
        }
        
        // Update clouds position
        function updateClouds(deltaTime) {
            clouds.forEach((cloud, index) => {
                let position = parseFloat(cloud.dataset.position);
                const speed = parseFloat(cloud.dataset.speed);
                
                position += speed * deltaTime;
                
                // Reset cloud when it goes off screen
                if (position > canvas.width + parseFloat(cloud.style.width)) {
                    position = -parseFloat(cloud.style.width);
                }
                
                cloud.dataset.position = position;
                cloud.style.left = `${position}px`;
            });
        }
        
        // Update birds position
        function updateBirds(deltaTime) {
            birds.forEach((bird, index) => {
                let position = parseFloat(bird.dataset.position);
                const speed = parseFloat(bird.dataset.speed);
                
                position += speed * deltaTime;
                
                // Remove bird when it goes off screen
                if (position > canvas.width + 50) {
                    document.getElementById('game-container').removeChild(bird);
                    birds.splice(index, 1);
                    
                    // Maybe create a new bird
                    if (Math.random() < 0.3 && isDayTime) {
                        setTimeout(createBird, Math.random() * 5000 + 2000);
                    }
                } else {
                    bird.dataset.position = position;
                    bird.style.left = `${position}px`;
                    
                    // Make bird flap by changing the SVG occasionally
                    if (Math.random() < 0.05) {
                        const path = bird.querySelector('path');
                        if (path) {
                            const flap = Math.random() < 0.5 ? 
                                "M10,50 Q30,20 50,50 Q70,20 90,50" : 
                                "M10,50 Q30,40 50,50 Q70,40 90,50";
                            path.setAttribute('d', flap);
                        }
                    }
                }
            });
            
            // Occasionally add new birds during the day
            if (birds.length < 3 && Math.random() < 0.001 && isDayTime) {
                createBird();
            }
        }
        
        // Update cloud visibility based on time of day
        function updateCloudVisibility() {
            const cloudOpacity = isDayTime ? 0.8 : 0.3; // Less visible at night
            
            clouds.forEach(cloud => {
                cloud.style.opacity = cloudOpacity;
                // Change cloud color for night
                if (isDayTime) {
                    cloud.style.background = "rgba(255, 255, 255, 0.7)";
                } else {
                    cloud.style.background = "rgba(200, 200, 220, 0.5)";
                }
            });
        }
        
        // Update birds visibility based on time of day
        function updateBirdsVisibility() {
            birds.forEach(bird => {
                // Birds only appear during day
                bird.style.opacity = isDayTime ? '1' : '0';
                
                // Remove birds at night
                if (!isDayTime) {
                    setTimeout(() => {
                        if (birds.includes(bird)) {
                            document.getElementById('game-container').removeChild(bird);
                            birds.splice(birds.indexOf(bird), 1);
                        }
                    }, 2000);
                }
            });
        }
        
        // Update day/night cycle
        function updateDayNightCycle() {
            const now = Date.now();
            const deltaTime = now - lastTimeUpdate;
            lastTimeUpdate = now;
            
            // Update time (hours incremented by timeMultiplier per second)
            const secondsElapsed = deltaTime / 1000;
            const hoursElapsed = secondsElapsed * timeMultiplier;
            
            // Update minutes first
            currentMinute += hoursElapsed * 60;
            
            // If minutes exceed 60, increment hour
            while (currentMinute >= 60) {
                currentMinute -= 60;
                currentHour++;
                
                // Reset hour after 24
                if (currentHour >= 24) {
                    currentHour = 0;
                }
                
                // Check for day/night transition
                if (currentHour === 18) {
                    transitionToNight();
                } else if (currentHour === 5) {
                    transitionToDay();
                }
            }
            
            // Format time display
            updateClockDisplay();
            
            // Update day progress (0-1 for full day)
            dayProgress = (currentHour + (currentMinute / 60)) / 24;
            
            // Update sky color based on time
            updateSkyColor();
            
            // Update sun/moon position
            updateCelestialBodies();
            
            // Update environment elements
            updateClouds(deltaTime);
            updateBirds(deltaTime);
        }
        
        // Format and update clock display
        function updateClockDisplay() {
            const hours = String(Math.floor(currentHour)).padStart(2, '0');
            const minutes = String(Math.floor(currentMinute)).padStart(2, '0');
            document.getElementById('day-clock').textContent = `${hours}:${minutes}`;
            
            // Visual effect on hour change
            if (Math.floor(currentMinute) === 0) {
                document.getElementById('day-clock').style.transform = 'scale(1.1)';
                setTimeout(() => {
                    document.getElementById('day-clock').style.transform = 'scale(1)';
                }, 300);
            }
        }
        
        // Update sky color based on time
        function updateSkyColor() {
            let skyColor;
            const hour = currentHour + (currentMinute / 60);
            
            // Day sky (6-17)
            if (hour >= 6 && hour < 17) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start');
            }
            // Sunset (17-19)
            else if (hour >= 17 && hour < 19) {
                const progress = (hour - 17) / 2; // 0-1 for sunset
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--sunset-sky-color-start'),
                    progress
                );
            }
            // Night (19-5)
            else if (hour >= 19 || hour < 5) {
                skyColor = getComputedStyle(document.documentElement).getPropertyValue('--night-sky-color-start');
            }
            // Sunrise (5-6)
            else {
                const progress = (hour - 5); // 0-1 for sunrise
                skyColor = mixColors(
                    getComputedStyle(document.documentElement).getPropertyValue('--sunrise-sky-color-start'),
                    getComputedStyle(document.documentElement).getPropertyValue('--day-sky-color-start'),
                    progress
                );
            }
            
            // Apply sky color in draw background
            ctx.fillStyle = skyColor;
        }
        
        // Helper for color mixing
        function mixColors(color1, color2, ratio) {
            color1 = color1.trim();
            color2 = color2.trim();
            
            // Simple mixing for hex or rgb colors
            if (color1.startsWith('#')) {
                // Convert hex to rgb
                const r1 = parseInt(color1.substr(1, 2), 16);
                const g1 = parseInt(color1.substr(3, 2), 16);
                const b1 = parseInt(color1.substr(5, 2), 16);
                
                const r2 = parseInt(color2.substr(1, 2), 16);
                const g2 = parseInt(color2.substr(3, 2), 16);
                const b2 = parseInt(color2.substr(5, 2), 16);
                
                const r = Math.round(r1 * (1 - ratio) + r2 * ratio);
                const g = Math.round(g1 * (1 - ratio) + g2 * ratio);
                const b = Math.round(b1 * (1 - ratio) + b2 * ratio);
                
                return `rgb(${r}, ${g}, ${b})`;
            } else {
                // Assume rgb format
                return color1; // Simplified - would need regex for proper rgb mixing
            }
        }
        
        // Update sun and moon positions
        function updateCelestialBodies() {
            const sunElement = document.getElementById('sun');
            const moonElement = document.getElementById('moon');
            
            // Calculate positions - circular path in sky
            const skyWidth = canvas.width;
            const skyHeight = canvas.height * 0.6; // Top 60% is sky
            
            // Sun moves from left to right during day (5-19)
            if (currentHour >= 5 && currentHour < 19) {
                const sunProgress = (currentHour - 5) / 14; // 0-1 for sun path
                
                // Circular path for sun - moves in an arc
                const sunX = skyWidth * sunProgress;
                const sunY = skyHeight * 0.5 * Math.sin(Math.PI * sunProgress) + 50;
                
                sunElement.style.left = `${sunX}px`;
                sunElement.style.top = `${sunY}px`;
                
                // Set sun opacity based on time (fade during sunset/sunrise)
                if (currentHour >= 17) { // Sunset
                    const fadeProgress = (currentHour + currentMinute/60 - 17) / 2;
                    sunElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else if (currentHour < 6) { // Sunrise
                    const fadeProgress = (currentHour + currentMinute/60 - 5);
                    sunElement.style.opacity = Math.min(1, fadeProgress);
                } else {
                    sunElement.style.opacity = '1';
                }
                
                // Hide moon during day
                moonElement.style.opacity = '0';
                
                // Stars invisible during day
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
            } 
            // Moon moves from left to right during night (19-5)
            else {
                const moonProgress = (currentHour >= 19) ? 
                    (currentHour - 19) / 10 : // Evening (19-24)
                    (currentHour + 5) / 10;  // Morning (0-5)
                
                // Circular path for moon
                const moonX = skyWidth * moonProgress;
                const moonY = skyHeight * 0.3 * Math.sin(Math.PI * moonProgress) + 50;
                
                moonElement.style.left = `${moonX}px`;
                moonElement.style.top = `${moonY}px`;
                
                // Set moon opacity (fade during transitions)
                if (currentHour >= 19 && currentHour < 20) { // Dusk
                    const fadeProgress = (currentHour + currentMinute/60 - 19);
                    moonElement.style.opacity = Math.min(1, fadeProgress);
                } else if (currentHour >= 4 && currentHour < 5) { // Dawn
                    const fadeProgress = (currentHour + currentMinute/60 - 4);
                    moonElement.style.opacity = Math.max(0, 1 - fadeProgress);
                } else {
                    moonElement.style.opacity = '1';
                }
                
                // Hide sun during night
                sunElement.style.opacity = '0';
                
                // Stars visible at night
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
            }
        }
        
        // Transition to night
        function transitionToNight() {
            if (isDayTime) {
                isDayTime = false;
                
                // Fade in night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0.3)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Create stars if they don't exist
                if (document.querySelectorAll('.star').length === 0) {
                    createStarsElements();
                }
                
                // Show stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0.7';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(0.8)';
                
                // Update UI elements for night
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.25)';
                });
            }
        }
        
        // Transition to day
        function transitionToDay() {
            if (!isDayTime) {
                isDayTime = true;
                
                // Fade out night overlay
                const overlay = document.getElementById('day-night-overlay');
                overlay.style.backgroundColor = 'rgba(0, 0, 30, 0)';
                
                // Update environment elements
                updateCloudVisibility();
                updateBirdsVisibility();
                
                // Hide stars
                document.querySelectorAll('.star').forEach(star => {
                    star.style.opacity = '0';
                });
                
                // Visual effect on screen
                canvas.style.filter = 'brightness(1)';
                
                // Update UI elements for day
                document.querySelectorAll('.game-display, .health-bars, #monthly-stats').forEach(elem => {
                    elem.style.boxShadow = '0 2px 8px rgba(0, 0, 0, 0.1)';
                });
                
                // Maybe create some birds for the new day
                if (birds.length < 2 && Math.random() < 0.5) {
                    createBird();
                }
            }
        }
        
        // Create star elements in DOM
        function createStarsElements() {
            createStars(); // Generate star data
            
            stars.forEach(star => {
                const starElement = document.createElement('div');
                starElement.className = 'star';
                starElement.style.width = `${star.size}px`;
                starElement.style.height = `${star.size}px`;
                starElement.style.left = `${star.x}px`;
                starElement.style.top = `${star.y}px`;
                
                // Custom twinkle animation
                starElement.style.animationDuration = `${star.twinkleSpeed}s`;
                
                document.getElementById('game-container').appendChild(starElement);
            });
        }
        // Game statistics
        let stats = {
            monthsPlayed: 0,
            powerupsCollected: 0,
            obstaclesAvoided: 0,
            obstaclesFaced: 0,
            expenses: 0,
            income: 5000,  // Starting monthly income
            mentalHealth: 100, // Mental state affects progress speed
            physicalHealth: 100 // Physical state affects progress speed
        };
        
        // Achievements
        let achievements = {
            firstMonth: { earned: false, text: "砖专转 砖 专砖" },
            saveHero: { earned: false, text: "住转 50,000 砖\"" },
            powerCollector: { earned: false, text: "爪转 10 专 驻住 " },
            resistanceMaster: { earned: false, text: "驻转专转 20 转 驻住转" },
            mentalStrength: { earned: false, text: "砖专转 注 住  " }
        };
        
        // Financial tips to display periodically
        const financialTips = [
            "拽爪转 50 砖\"  专转 抓 住转转 -18,000 砖\" 砖",
            "70% 爪注专 砖住 20% 住转 注 爪转 驻住转 转 5 砖",
            "砖拽注 砖 500 砖\" 砖  23  注  砖\"  驻专砖",
            "拽专 专 转 住 3-6 砖 爪转 转",
            "爪转 拽注转  爪专转 注转 注 50% 住 砖转 ",
            "注转 转 爪专转 专转   驻转 爪转 驻住转",
            "专砖转 爪专 砖砖  住 注 70% 注转 砖",
            "住 转驻注 专 专 拽专 转专 专砖 砖专 砖 专  专",
            "驻专砖 驻住  拽  砖注转转 转 住 住驻",
            "拽 砖  爪转 砖转 转 专注  住 转 砖拽"
        ];
        
        // Total months of simulation - extended game time
        const totalMonths = 24; // March 2025 to March 2027
        const monthNames = [
            "专抓 2025", "驻专 2025", " 2025", " 2025", " 2025", 
            "住 2025", "住驻专 2025", "拽专 2025", "专 2025", "爪专 2025",
            "专 2026", "驻专专 2026", "专抓 2026", "驻专 2026", " 2026", 
            " 2026", " 2026", "住 2026", "住驻专 2026", "拽专 2026", 
            "专 2026", "爪专 2026", "专 2027", "驻专专 2027", "专抓 2027"
        ];
        
        // Month duration increased to 5 minutes per month (300 seconds)
        const monthDuration = 300; // 5 minutes (300 seconds) per month
        const framesPerSecond = 60;
        const frameTime = 1000 / framesPerSecond;
        const framesPerMonth = monthDuration * framesPerSecond;
        let currentMonthTimer = 0;

        // Monthly counters to limit obstacle and powerup appearances
        let monthlyObstacleCounter = {
            person: 0,
            ad: 0,
            food: 0
        };

        let monthlyPowerupCounter = {
            money: 0,
            earlyRise: 0,
            earlySleep: 0,
            healthyFood: 0,
            exercise: 0,
            companion: 0
        };
      
        // Power-up variables
        const maxPowerUpTime = 900; // 15 seconds at 60fps
        let gameMessage = '';
        let gameMessageTime = 0;
        
        // Player variables
        const player = {
            x: canvas.width * 0.2,
            y: canvas.height * 0.7,
            width: 50,
            height: 80,
            baseSpeed: 5, // Base speed
            currentSpeed: 5, // Current speed affected by player condition
            powerUp: false,
            powerUpTime: 0,
            powerUpType: '',
            companion: false,
            weight: 1, // Increases with unhealthy food, affects speed
            mentalStrength: 1 // Decreases with negative mental effects, affects speed
        };
        
        // Ground variables
        const ground = {
            y: canvas.height * 0.8,
            width: canvas.width,
            height: canvas.height * 0.2
        };
        
        // Current powerup in dialog
        let currentPowerup = null;
        let powerupFollowupQuestions = [];
        let powerupFollowupIndex = 0;
        
        // Arrays for game objects
        let obstacles = [];
        let powerups = [];
        let pendingObstacles = [];  // For delayed creation
        
        // Obstacle dialog variables
        let currentObstacle = null;
        let lastObstacleTime = 0;
        const minObstacleInterval = 5000; // Minimum time between obstacle dialogs (5 seconds)
        let persuasionStage = 0; // Current persuasion stage
        let persuasionTexts = []; // Persuasion texts per obstacle
        
        // Job offer variables
        let jobOfferStage = 0;
        const jobOfferTexts = [
            " 转  砖专爪 转 转 ?",
            "砖专  -25% 转 住爪 砖驻专",
            "转 转驻转转 拽爪注转 砖注转转 转专",
            "注 爪注 砖转 专 转专 砖注转 注"
        ];
        
        // Bonus questions for financial bonus powerup
        const bonusQuestions = [
            { 
                question: " 注转 注   砖注?", 
                positiveEffect: "转 拽转  注专 砖 注住拽",
                negativeEffect: "专 驻注 转转 拽爪注转 砖"
            },
            { 
                question: " 住转 转  砖转 砖 驻 ?", 
                positiveEffect: "注 注  注转 拽爪注转",
                negativeEffect: " 注  驻注转 注专转 爪注 砖"
            },
            { 
                question: " 注专转 注转 注 砖注?", 
                positiveEffect: "注转 爪转  拽转 砖 注专转 注",
                negativeEffect: "砖转祝 驻注  拽 转 注专 砖 专"
            },
            { 
                question: " 转 专注 砖  爪注转 注 注?", 
                positiveEffect: " 爪专转转 转 拽 拽爪注",
                negativeEffect: "驻住转 注  转 驻爪 拽 砖"
            },
            { 
                question: " 砖拽注转  专转 注 拽爪注 砖?", 
                positiveEffect: "转驻转转 砖转  转 注专 砖拽 注",
                negativeEffect: "拽注 拽爪注  转 驻砖专转 注转转 砖"
            }
        ];
        
        // Helper for random number generation
        function getRandomInt(min, max) {
            return Math.floor(Math.random() * (max - min + 1)) + min;
        }
        
        // Display popup message with enhanced visuals
        function showPopupMessage(message, duration = 2000) {
            const popup = document.getElementById('popup-message');
            popup.textContent = message;
            popup.style.opacity = '1';
            popup.style.transform = 'translateX(-50%) translateY(-10px)';
            
            setTimeout(() => {
                popup.style.opacity = '0';
                popup.style.transform = 'translateX(-50%) translateY(0px)';
            }, duration);
        }
        
        // Show financial tip with enhanced styling
        function showFinanceTip() {
            if (financeMessageTimer) {
                clearTimeout(financeMessageTimer);
            }
            
            const tip = document.getElementById('finance-tip');
            const randomTip = financialTips[Math.floor(Math.random() * financialTips.length)];
            tip.textContent = randomTip;
            tip.style.opacity = '1';
            
            // Add subtle animation
            tip.style.transform = 'translateX(-50%) translateY(-5px)';
            setTimeout(() => {
                tip.style.transform = 'translateX(-50%) translateY(0)';
            }, 300);
            
            financeMessageTimer = setTimeout(() => {
                tip.style.opacity = '0';
            }, 8000); // Show for 8 seconds
        }
        
        // Update player's speed based on mental and physical health
        function updatePlayerCondition() {
            // Calculate weight effect (physical health)
            let weightEffect = 1;
            if (stats.physicalHealth < 80) {
                weightEffect = 0.9;
                document.getElementById('status-weight').style.display = 'block';
                document.getElementById('status-weight').textContent = "爪 驻: 专";
            } else if (stats.physicalHealth < 60) {
                weightEffect = 0.7;
                document.getElementById('status-weight').style.display = 'block';
                document.getElementById('status-weight').textContent = "爪 驻: 拽";
            } else if (stats.physicalHealth < 40) {
                weightEffect = 0.5;
                document.getElementById('status-weight').style.display = 'block';
                document.getElementById('status-weight').textContent = "爪 驻: 专";
            } else {
                document.getElementById('status-weight').style.display = 'none';
            }
            
            // Calculate mental effect
            let mentalEffect = 1;
            if (stats.mentalHealth < 80) {
                mentalEffect = 0.9;
                document.getElementById('status-negative').style.display = 'block';
                document.getElementById('status-negative').textContent = "爪 : 专";
            } else if (stats.mentalHealth < 60) {
                mentalEffect = 0.7;
                document.getElementById('status-negative').style.display = 'block';
                document.getElementById('status-negative').textContent = "爪 : 拽";
            } else if (stats.mentalHealth < 40) {
                mentalEffect = 0.5;
                document.getElementById('status-negative').style.display = 'block';
                document.getElementById('status-negative').textContent = "爪 : 专";
            } else {
                document.getElementById('status-negative').style.display = 'none';
            }
            
            // Update player speed
            player.currentSpeed = player.baseSpeed * weightEffect * mentalEffect;
            
            // Update speed indicator with enhanced styling
            const speedIndicator = document.getElementById('speed-indicator');
            if (player.currentSpeed < player.baseSpeed * 0.6) {
                speedIndicator.textContent = '转拽转: 转 ';
                speedIndicator.style.backgroundColor = 'rgba(212, 91, 91, 0.9)';
            } else if (player.currentSpeed < player.baseSpeed * 0.8) {
                speedIndicator.textContent = '转拽转: 转';
                speedIndicator.style.backgroundColor = 'rgba(211, 135, 62, 0.9)';
            } else if (player.currentSpeed < player.baseSpeed * 0.95) {
                speedIndicator.textContent = '转拽转: 转';
                speedIndicator.style.backgroundColor = 'rgba(214, 177, 45, 0.9)';
            } else {
                speedIndicator.textContent = '转拽转: 驻转';
                speedIndicator.style.backgroundColor = 'rgba(50, 50, 50, 0.8)';
            }
            
            // Update health bars with animation
            const physicalFill = document.getElementById('physical-health-fill');
            const mentalFill = document.getElementById('mental-health-fill');
            
            // Save current width for transition
            const currentPhysicalWidth = parseFloat(physicalFill.style.width) || 100;
            const currentMentalWidth = parseFloat(mentalFill.style.width) || 100;
            
            // Apply smooth transition if significant change
            if (Math.abs(currentPhysicalWidth - stats.physicalHealth) > 5) {
                physicalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { physicalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            if (Math.abs(currentMentalWidth - stats.mentalHealth) > 5) {
                mentalFill.style.transition = 'width 0.5s ease';
                setTimeout(() => { mentalFill.style.transition = 'width 0.3s ease'; }, 500);
            }
            
            // Set new values
            physicalFill.style.width = `${stats.physicalHealth}%`;
            mentalFill.style.width = `${stats.mentalHealth}%`;
            
            // Update color based on health level
            if (stats.physicalHealth < 40) {
                physicalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.physicalHealth < 70) {
                physicalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                physicalFill.style.backgroundColor = 'var(--success-color)';
            }
            
            if (stats.mentalHealth < 40) {
                mentalFill.style.backgroundColor = 'var(--danger-color)';
            } else if (stats.mentalHealth < 70) {
                mentalFill.style.backgroundColor = 'var(--warning-color)';
            } else {
                mentalFill.style.backgroundColor = 'var(--primary-color)';
            }
        }
        
        // Create obstacle with improved visuals
        function createObstacle() {
            const types = ['person', 'ad', 'food'];
            // Filter types that already appeared twice this month
            const availableTypes = types.filter(type => monthlyObstacleCounter[type] < 2);
            
            // If no available types, exit function
            if (availableTypes.length === 0) return;
            
            const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
            
            // Update counter for the selected type
            monthlyObstacleCounter[type]++;
            
            let obstacle;
            
            if (type === 'person') {
                const negativeComments = [
                    "拽砖 住 注 砖专转  砖",
                    "转  转爪 注 爪转 驻住转",
                    "专 砖  爪 住",
                    "转 驻住驻住 转  拽爪转 砖",
                    "住  注 住爪-拽 ",
                    "祝 驻注  转注 注 砖 100,000",
                    " 专拽 驻注 转,  转住  住专专"
                ];
                
                // Persuasive texts for negative people
                const persuasiveTexts = [
                    // First stage title and text set separately
                    `拽专 专 砖专 砖  爪 住   `, // Second stage
                    `  注祝 转 住祝 注砖 拽 转 注转  ?`, // Third stage
                    `转 专 注祝,  转注砖 注爪 驻住拽 拽 住` // Fourth stage
                ];
                
                obstacle = {
                    x: canvas.width,
                    y: ground.y - 80,
                    width: 50,
                    height: 80,
                    type: type,
                    speed: 4 + (currentMonth * 0.1),
                    text: negativeComments[getRandomInt(0, negativeComments.length - 1)],
                    value: getRandomInt(500, 1000), // Cost if hit
                    mentalEffect: getRandomInt(5, 15), // How much it will reduce mental health
                    persuasiveTexts: persuasiveTexts,
                    obstacleTitle: "砖驻注 专转转 砖转",
                    initialText: "专 爪注  转专 注 转转 住 砖  转 转专 . 爪 转?",
                    // Visual properties
                    color: "#6c757d",
                    animationOffset: Math.random() * Math.PI * 2, // For bobbing animation
                    bobSpeed: 0.05 + Math.random() * 0.03
                };
            } else if (type === 'ad') {
                const adTexts = [
                    "爪注 注转! 专拽  !",
                    "住 : 转 砖 注 70%!",
                    "砖拽注 专 砖 转注专  拽专专",
                    "驻砖 砖转 转砖 ",
                    "拽专住 砖砖驻专 转 驻爪 住 砖",
                    " 注 专住 砖专 ",
                    "专 砖:    专转!"
                ];
                
                // Persuasive texts for ads
                const persuasiveTexts = [
                    ` 转  驻注转 砖 转专!`,
                    `  爪,  砖拽注 注转 砖`,
                    ` 转 转驻住驻住 转 转  专`
                ];
                
                obstacle = {
                    x: canvas.width,
                    y: ground.y - 70,
                    width: 60,
                    height: 70,
                    type: type,
                    speed: 5 + (currentMonth * 0.15),
                    text: adTexts[getRandomInt(0, adTexts.length - 1)],
                    value: getRandomInt(1000, 3000),
                    persuasiveTexts: persuasiveTexts,
                    obstacleTitle: "爪专  转转",
                    initialText: "砖驻转 爪注 砖拽转 砖驻转 转 爪注 专砖  转转.  转注砖?",
                    // Visual properties
                    color: "#495057",
                    animationOffset: Math.random() * Math.PI * 2,
                    bobSpeed: 0.08 + Math.random() * 0.04, // Ads move more erratically
                    pulseRate: 0.03 + Math.random() * 0.02 // For pulsing effect
                };
            } else if (type === 'food') {
                const foodTypes = [
                    "转 砖  砖 转",
                    "专 拽专 住注",
                    "拽驻 驻  专 注",
                    "拽转 转 拽专 注转 住驻专 ",
                    "专 专 注 拽专",
                    " 专 专 驻拽注"
                ];
                
                // Persuasive texts for food
                const persuasiveTexts = [
                    `转 注 拽砖, 注  转驻拽  驻注`,
                    `转 专转转 砖转  住 住驻`,
                    `驻注 转  转砖 转 爪 驻住 砖`
                ];
                
                obstacle = {
                    x: canvas.width,
                    y: ground.y - 60,
                    width: 50,
                    height: 60,
                    type: type,
                    speed: 3 + (currentMonth * 0.1),
                    text: foodTypes[getRandomInt(0, foodTypes.length - 1)],
                    value: getRandomInt(300, 1200),
                    weightEffect: getRandomInt(5, 15), // How much it will reduce physical health
                    persuasiveTexts: persuasiveTexts,
                    obstacleTitle: "转 爪转 ",
                    initialText: "注转 驻 专  爪  注   驻砖专转 住转 转专.  转专?",
                    // Visual properties
                    color: "#6c757d",
                    animationOffset: Math.random() * Math.PI * 2,
                    bobSpeed: 0.04 + Math.random() * 0.02, // Food moves more slowly
                    rotationSpeed: Math.random() * 0.01 // Slight rotation
                };
            }
            
            obstacles.push(obstacle);
            
            // Show subtle visual cue for obstacle approach
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${obstacle.y}px`;
            flash.style.width = '10px';
            flash.style.height = `${obstacle.height}px`;
            flash.style.backgroundColor = 'rgba(255, 0, 0, 0.3)';
            flash.style.borderRadius = '5px 0 0 5px';
            flash.style.zIndex = '8';
            flash.style.animation = 'flash-warning 0.5s ease forwards';
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes flash-warning {
                    0% { opacity: 0.8; }
                    100% { opacity: 0; right: 10px; }
                }
            `;
            document.head.appendChild(style);
            
            // Remove the flash element after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 500);
        }
        
        // Create powerup with enhanced visuals
        function createPowerup() {
            const types = ['money', 'earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
            // Filter types that already appeared twice this month
            const availableTypes = types.filter(type => monthlyPowerupCounter[type] < 2);
            
            // If no available types, exit function
            if (availableTypes.length === 0) return;
            
            const type = availableTypes[getRandomInt(0, availableTypes.length - 1)];
            
            // Update counter for the selected type
            monthlyPowerupCounter[type]++;
            
            let text = '';
            let width = 40;
            let height = 40;
            let value = 1000;
            let color = '';
            
            switch(type) {
                case 'money':
                    text = "住 住驻";
                    value = getRandomInt(1000, 3000);
                    color = "#2a6496"; // Blue
                    break;
                case 'earlyRise':
                    text = "拽 拽转";
                    color = "#3a7a5f"; // Green
                    break;
                case 'earlySleep':
                    text = "砖 拽转";
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "转 专";
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "驻注转 驻转";
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
                x: canvas.width,
                y: getRandomInt(ground.y - 150, ground.y - 60),
                width: width,
                height: height,
                type: type,
                speed: 4, // Slower speed for longer game
                text: text,
                value: value,
                healthEffect: type === 'healthyFood' || type === 'exercise' ? 10 : 0, // Improve physical health
                mentalEffect: type === 'earlySleep' || type === 'earlyRise' ? 10 : 0, // Improve mental health
                color: color,
                animationOffset: Math.random() * Math.PI * 2, // For floating animation
                floatSpeed: 0.03 + Math.random() * 0.02,
                floatRange: 10 + Math.random() * 5, // How far it floats up/down
                glowing: true, // Add glow effect
                originalY: 0 // Store original Y for floating animation
            };
            
            // Store original Y for floating animation
            powerup.originalY = powerup.y;
            
            powerups.push(powerup);
            
            // Show subtle visual cue for powerup approach
            const flash = document.createElement('div');
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '10px';
            flash.style.height = `${powerup.height}px`;
            flash.style.backgroundColor = 'rgba(0, 255, 0, 0.3)';
            flash.style.borderRadius = '5px 0 0 5px';
            flash.style.zIndex = '8';
            flash.style.animation = 'flash-powerup 0.5s ease forwards';
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define the animation keyframes if not already defined
            if (!document.getElementById('powerup-flash-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-flash-style';
                style.textContent = `
                    @keyframes flash-powerup {
                        0% { opacity: 0.8; }
                        100% { opacity: 0; right: 10px; }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the flash element after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
            }, 500);
        }
        // Create companion with enhanced visuals
        function createCompanion() {
            // Check if companion already appeared twice this month
            if (monthlyPowerupCounter.companion >= 2) return;
            
            // Update companion counter
            monthlyPowerupCounter.companion++;
            
            const companion = {
                x: canvas.width,
                y: ground.y - 70,
                width: 40,
                height: 70,
                speed: 4,
                type: 'companion',
                text: "转 专转转 专 驻住转",
                color: "#2a6496", // Blue
                animationOffset: Math.random() * Math.PI * 2,
                floatSpeed: 0.02,
                floatRange: 5,
                originalY: ground.y - 70,
                glowing: true,
                emitParticles: true // Special effect for companions
            };
            
            powerups.push(companion);
            showPopupMessage("转 专转转 转拽专转!", 2000);
            
            // Add sound or visual cue for companion
            const companionAlert = document.createElement('div');
            companionAlert.style.position = 'absolute';
            companionAlert.style.top = '50%';
            companionAlert.style.left = '50%';
            companionAlert.style.transform = 'translate(-50%, -50%)';
            companionAlert.style.color = 'white';
            companionAlert.style.fontSize = '24px';
            companionAlert.style.padding = '15px 30px';
            companionAlert.style.borderRadius = '8px';
            companionAlert.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
            companionAlert.style.zIndex = '50';
            companionAlert.style.animation = 'companion-alert 1.5s forwards';
            companionAlert.textContent = ' 转 专转转 转拽专转!';
            
            document.getElementById('game-container').appendChild(companionAlert);
            
            // Add animation style if not already present
            if (!document.getElementById('companion-alert-style')) {
                const style = document.createElement('style');
                style.id = 'companion-alert-style';
                style.textContent = `
                    @keyframes companion-alert {
                        0% { opacity: 0; transform: translate(-50%, -70%); }
                        20% { opacity: 1; transform: translate(-50%, -50%); }
                        80% { opacity: 1; transform: translate(-50%, -50%); }
                        100% { opacity: 0; transform: translate(-50%, -30%); }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Remove the alert element after animation
            setTimeout(() => {
                if (companionAlert.parentNode) {
                    companionAlert.parentNode.removeChild(companionAlert);
                }
            }, 1500);
        }
        
        // Show powerup dialog with enhanced animation
        function showPowerupDialog(powerup) {
            gamePaused = true;
            currentPowerup = powerup;
            powerupFollowupIndex = 0;
            
            // Set question based on powerup type
            let question = "";
            const powerupTitle = document.getElementById('powerup-title');
            
            switch(powerup.type) {
                case 'exercise':
                    powerupTitle.textContent = "转 砖驻专 专转";
                    question = " 注砖转 驻注转 驻转 ?";
                    powerupFollowupQuestions = [];
                    break;
                case 'healthyFood':
                    powerupTitle.textContent = " 转";
                    question = " 拽驻转 注 转 专 ?";
                    powerupFollowupQuestions = [];
                    break;
                case 'earlyRise':
                    powerupTitle.textContent = "  注";
                    question = " 拽转 拽 ?";
                    powerupFollowupQuestions = [];
                    break;
                case 'earlySleep':
                    powerupTitle.textContent = "专 砖";
                    question = " 转 砖 住驻拽 砖注转 转?";
                    powerupFollowupQuestions = [];
                    break;
                case 'money':
                    powerupTitle.textContent = "注专转 爪注 转注住拽转转";
                    question = " 转转 住 砖  砖 转转  住 住驻?";
                    // Set followup questions for bonus
                    powerupFollowupQuestions = [...bonusQuestions];
                    // Shuffle the questions to get random ones each time
                    for (let i = powerupFollowupQuestions.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [powerupFollowupQuestions[i], powerupFollowupQuestions[j]] = 
                        [powerupFollowupQuestions[j], powerupFollowupQuestions[i]];
                    }
                    // Limit to 3 random questions
                    powerupFollowupQuestions = powerupFollowupQuestions.slice(0, 3);
                    break;
                case 'companion':
                    powerupTitle.textContent = "转 专转转";
                    question = " 转 驻转 拽 注专 专 转转 驻住转 砖?";
                    powerupFollowupQuestions = [];
                    break;
            }
            
            // Set dialog content with animation
            document.getElementById('powerup-text').textContent = question;
            
            // Add special styling based on powerup type
            const dialogBox = document.getElementById('powerup-dialog');
            
            // Reset any previous custom styling
            dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
            
            // Add type-specific styling
            switch(powerup.type) {
                case 'exercise':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
                    break;
                case 'healthyFood':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(58, 122, 95, 0.3)';
                    break;
                case 'money':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.3)';
                    break;
                case 'companion':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(42, 100, 150, 0.4)';
                    break;
            }
            
            // Show dialog with enhanced animation
            dialogBox.style.display = 'block';
            dialogBox.style.animation = 'powerup-dialog-appear 0.4s ease forwards';
            
            // Add animation style if not already present
            if (!document.getElementById('powerup-dialog-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-dialog-style';
                style.textContent = `
                    @keyframes powerup-dialog-appear {
                        from { 
                            opacity: 0; 
                            transform: translate(-50%, -60%) scale(0.9); 
                        }
                        to { 
                            opacity: 1; 
                            transform: translate(-50%, -50%) scale(1); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
        }
        
        // Handle powerup yes response with enhanced feedback
        function powerupYesResponse() {
            if (!currentPowerup) return;
            
            // If this is a bonus with followup questions
            if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
                // Show positive feedback
                showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].positiveEffect, 2500);
                
                // Show next question with animation
                const questionText = document.getElementById('powerup-text');
                questionText.style.opacity = '0';
                questionText.style.transform = 'translateY(-10px)';
                
                setTimeout(() => {
                    questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
                    questionText.style.opacity = '1';
                    questionText.style.transform = 'translateY(0)';
                }, 300);
                
                powerupFollowupIndex++;
                return;
            }
            
            // Apply the powerup effect based on the type
            stats.powerupsCollected++;
            
            switch(currentPowerup.type) {
                case 'money':
                    let bonusAmount = currentPowerup.value;
                    // If player answered followup questions, provide bigger bonus
                    if (powerupFollowupQuestions.length > 0) {
                        bonusAmount = Math.round(bonusAmount * (1 + 0.2 * powerupFollowupIndex));
                    }
                    
                    score += bonusAmount;
                    stats.income += bonusAmount / 5; // Distribute the bonus over time
                    
                    // Enhance the bonus popup with animation
                    showCoinAnimation(bonusAmount);
                    showPopupMessage(`拽转 住 砖 ${bonusAmount} 砖"!`, 2000);
                    break;
                case 'earlyRise':
                case 'earlySleep':
                    player.powerUp = true;
                    player.powerUpTime = maxPowerUpTime;
                    player.powerUpType = currentPowerup.type;
                    document.getElementById('power-meter').style.display = 'block';
                    
                    // Improve mental health
                    stats.mentalHealth = Math.min(100, stats.mentalHealth + currentPowerup.mentalEffect);
                    
                    // Enhanced visual effect
                    showMentalBoostEffect();
                    showPopupMessage(`拽 驻注: ${currentPowerup.type === 'earlyRise' ? '  注' : '专 砖 '}`, 2000);
                    break;
                case 'healthyFood':
                case 'exercise':
                    player.powerUp = true;
                    player.powerUpTime = maxPowerUpTime;
                    player.powerUpType = currentPowerup.type;
                    document.getElementById('power-meter').style.display = 'block';
                    
                    // Improve physical health
                    stats.physicalHealth = Math.min(100, stats.physicalHealth + currentPowerup.healthEffect);
                    
                    // Enhanced visual effect
                    showPhysicalBoostEffect();
                    showPopupMessage(`拽 驻注: ${currentPowerup.type === 'healthyFood' ? '转 转' : '砖专 驻'}`, 2000);
                    break;
                case 'companion':
                    player.companion = true;
                    player.powerUp = true;
                    player.powerUpTime = maxPowerUpTime * 2; // Companion lasts longer
                    player.powerUpType = 'companion';
                    document.getElementById('power-meter').style.display = 'block';
                    
                    // Companion helps with both mental and physical health
                    stats.mentalHealth = Math.min(100, stats.mentalHealth + 15);
                    stats.physicalHealth = Math.min(100, stats.physicalHealth + 15);
                    
                    // Enhanced visual effect
                    showCompanionJoinEffect();
                    showPopupMessage("转 专转转 拽转 转 住 砖!", 2500);
                    break;
            }
            
            // Close the dialog and continue game with smooth exit animation
            const dialogBox = document.getElementById('powerup-dialog');
            dialogBox.style.animation = 'powerup-dialog-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('powerup-dialog-exit-style')) {
                const style = document.createElement('style');
                style.id = 'powerup-dialog-exit-style';
                style.textContent = `
                    @keyframes powerup-dialog-exit {
                        from { 
                            opacity: 1; 
                            transform: translate(-50%, -50%) scale(1); 
                        }
                        to { 
                            opacity: 0; 
                            transform: translate(-50%, -40%) scale(0.95); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Hide dialog after animation
            setTimeout(() => {
                dialogBox.style.display = 'none';
                currentPowerup = null;
                gamePaused = false;
            }, 300);
            
            // Check achievement
            if (stats.powerupsCollected >= 10 && !achievements.powerCollector.earned) {
                achievements.powerCollector.earned = true;
                addAchievement(achievements.powerCollector.text);
            }
            
            // Update display
            updatePlayerCondition();
            updateDisplay();
        }
        
        // Helper function for coin animation
        function showCoinAnimation(amount) {
            // Create 5-10 animated coins based on amount size
            const coinCount = Math.min(10, Math.max(5, Math.floor(amount / 500)));
            
            for (let i = 0; i < coinCount; i++) {
                const coin = document.createElement('div');
                coin.className = 'animated-coin';
                
                // Style the coin
                coin.style.position = 'absolute';
                coin.style.width = '30px';
                coin.style.height = '30px';
                coin.style.borderRadius = '50%';
                coin.style.backgroundColor = '#FFD700';
                coin.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.7)';
                coin.style.zIndex = '30';
                coin.style.display = 'flex';
                coin.style.justifyContent = 'center';
                coin.style.alignItems = 'center';
                coin.style.color = '#333';
                coin.style.fontWeight = 'bold';
                coin.style.fontSize = '16px';
                coin.textContent = '';
                
                // Position at center of screen initially
                coin.style.top = '50%';
                coin.style.left = '50%';
                
                // Add to game container
                document.getElementById('game-container').appendChild(coin);
                
                // Animate coin
                const randomX = Math.random() * 200 - 100; // -100 to 100
                const randomY = Math.random() * 100 - 150; // -150 to -50 (upward)
                const randomDelay = Math.random() * 200;
                
                // Create dynamic keyframes for each coin
                const keyframes = `
                    @keyframes coin-move-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        10% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 1;
                        }
                        60% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY}px)) scale(1);
                            opacity: 1;
                        }
                        100% {
                            transform: translate(calc(-50% + ${randomX}px), calc(-50% + ${randomY - 50}px)) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific coin
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    coin.style.animation = `coin-move-${i} 1.5s ease-out forwards`;
                }, randomDelay);
                
                // Remove coin after animation
                setTimeout(() => {
                    if (coin.parentNode) {
                        coin.parentNode.removeChild(coin);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, 1800 + randomDelay);
            }
            
            // Show total amount animation
            const totalAmount = document.createElement('div');
            totalAmount.className = 'total-bonus';
            totalAmount.style.position = 'absolute';
            totalAmount.style.top = '40%';
            totalAmount.style.left = '50%';
            totalAmount.style.transform = 'translate(-50%, -50%)';
            totalAmount.style.fontSize = '36px';
            totalAmount.style.fontWeight = 'bold';
            totalAmount.style.color = '#FFD700';
            totalAmount.style.textShadow = '0 0 10px rgba(255, 215, 0, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            totalAmount.style.zIndex = '31';
            totalAmount.style.opacity = '0';
            totalAmount.textContent = `+${amount} `;
            
            document.getElementById('game-container').appendChild(totalAmount);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes total-bonus-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation with delay
            setTimeout(() => {
                totalAmount.style.animation = 'total-bonus-anim 2s ease-out forwards';
            }, 300);
            
            // Remove elements after animation
            setTimeout(() => {
                if (totalAmount.parentNode) {
                    totalAmount.parentNode.removeChild(totalAmount);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
        }
        
        // Mental boost visual effect
        function showMentalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'mental-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(42, 100, 150, 0.3) 0%, rgba(42, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes mental-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'mental-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Physical boost visual effect
        function showPhysicalBoostEffect() {
            const effect = document.createElement('div');
            effect.className = 'physical-boost-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(58, 122, 95, 0.3) 0%, rgba(58, 122, 95, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes physical-boost {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'physical-boost 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Companion join visual effect
        function showCompanionJoinEffect() {
            // Create multiple particles effect
            for (let i = 0; i < 20; i++) {
                const particle = document.createElement('div');
                particle.className = 'companion-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '10px';
                particle.style.height = '10px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = 'rgba(42, 100, 150, 0.8)';
                particle.style.zIndex = '25';
                
                // Position around player
                particle.style.top = `${player.y + player.height / 2}px`;
                particle.style.left = `${player.x + player.width / 2}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create dynamic animation for each particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 100;
                const duration = 0.8 + Math.random() * 0.7;
                const delay = Math.random() * 0.3;
                const size = 5 + Math.random() * 10;
                
                // Update size
                particle.style.width = `${size}px`;
                particle.style.height = `${size}px`;
                
                // Create specific keyframes for this particle
                const keyframes = `
                    @keyframes companion-particle-${i} {
                        0% {
                            transform: translate(-50%, -50%) scale(0.3);
                            opacity: 0;
                        }
                        20% {
                            transform: translate(-50%, -50%) scale(1);
                            opacity: 0.8;
                        }
                        100% {
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5);
                            opacity: 0;
                        }
                    }
                `;
                
                // Add style for this specific particle
                const style = document.createElement('style');
                style.textContent = keyframes;
                document.head.appendChild(style);
                
                // Apply animation with delay
                setTimeout(() => {
                    particle.style.animation = `companion-particle-${i} ${duration}s ease-out forwards`;
                }, delay * 1000);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (style.parentNode) {
                        style.parentNode.removeChild(style);
                    }
                }, (delay + duration + 0.1) * 1000);
            }
            
            // Add companion icon
            const icon = document.createElement('div');
            icon.className = 'companion-icon';
            icon.style.position = 'absolute';
            icon.style.top = `${player.y - 40}px`;
            icon.style.left = `${player.x + player.width / 2}px`;
            icon.style.transform = 'translate(-50%, -50%)';
            icon.style.fontSize = '30px';
            icon.style.opacity = '0';
            icon.style.zIndex = '26';
            icon.textContent = '';
            
            document.getElementById('game-container').appendChild(icon);
            
            // Define animation for icon
            const iconStyle = document.createElement('style');
            iconStyle.textContent = `
                @keyframes companion-icon-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -80px) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -100px) scale(0.8); }
                }
            `;
            document.head.appendChild(iconStyle);
            
            // Apply animation
            icon.style.animation = 'companion-icon-anim 2s ease-out forwards';
            
            // Remove icon after animation
            setTimeout(() => {
                if (icon.parentNode) {
                    icon.parentNode.removeChild(icon);
                }
                if (iconStyle.parentNode) {
                    iconStyle.parentNode.removeChild(iconStyle);
                }
            }, 2000);
        }
        // Handle powerup no response with enhanced feedback
        function powerupNoResponse() {
            if (!currentPowerup) return;
            
            // If this is a bonus with followup questions
            if (currentPowerup.type === 'money' && powerupFollowupQuestions.length > 0 && powerupFollowupIndex < powerupFollowupQuestions.length) {
                // Show negative feedback
                showPopupMessage(powerupFollowupQuestions[powerupFollowupIndex - 1].negativeEffect, 2500);
                
                // Show next question with animation
                const questionText = document.getElementById('powerup-text');
                questionText.style.opacity = '0';
                questionText.style.transform = 'translateY(-10px)';
                
                setTimeout(() => {
                    questionText.textContent = powerupFollowupQuestions[powerupFollowupIndex].question;
                    questionText.style.opacity = '1';
                    questionText.style.transform = 'translateY(0)';
                }, 300);
                
                powerupFollowupIndex++;
                return;
            }
            
            // Apply negative effect based on type
            switch(currentPowerup.type) {
                case 'exercise':
                    // Decrease physical health
                    stats.physicalHealth = Math.max(20, stats.physicalHealth - 10);
                    showPopupMessage("注专 驻注转 驻转 砖驻注 专注 注 专转", 2500);
                    showNegativePhysicalEffect();
                    break;
                case 'healthyFood':
                    // Decrease physical health
                    stats.physicalHealth = Math.max(20, stats.physicalHealth - 10);
                    showPopupMessage("转  转 驻注转 爪 驻", 2500);
                    showNegativePhysicalEffect();
                    break;
                case 'earlyRise':
                case 'earlySleep':
                    // Decrease mental health
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 10);
                    showPopupMessage("  拽 砖驻注 注 爪 ", 2500);
                    showNegativeMentalEffect();
                    break;
                case 'money':
                    // No bonus for poor performance
                    showPopupMessage("驻住驻住转 转 砖驻专 爪 驻住", 2500);
                    // Show subtle negative effect
                    showMissedOpportunityEffect();
                    break;
                case 'companion':
                    stats.mentalHealth = Math.max(20, stats.mentalHealth - 5);
                    showPopupMessage("转 专转转 砖 爪转 驻砖转", 2500);
                    showNegativeMentalEffect();
                    break;
            }
            
            // Close the dialog with smooth exit animation
            const dialogBox = document.getElementById('powerup-dialog');
            dialogBox.style.animation = 'powerup-dialog-exit 0.3s ease forwards';
            
            // Hide dialog after animation
            setTimeout(() => {
                dialogBox.style.display = 'none';
                currentPowerup = null;
                gamePaused = false;
            }, 300);
            
            // Update display
            updatePlayerCondition();
            updateDisplay();
        }
        
        // Visual effect for negative physical impact
        function showNegativePhysicalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-physical-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(212, 91, 91, 0.2) 0%, rgba(212, 91, 91, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-physical {
                    0% { opacity: 0; }
                    50% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-physical 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for negative mental impact
        function showNegativeMentalEffect() {
            const effect = document.createElement('div');
            effect.className = 'negative-mental-effect';
            
            // Style the effect
            effect.style.position = 'absolute';
            effect.style.top = '0';
            effect.style.left = '0';
            effect.style.width = '100%';
            effect.style.height = '100%';
            effect.style.background = 'radial-gradient(circle at center, rgba(100, 100, 150, 0.2) 0%, rgba(100, 100, 150, 0) 70%)';
            effect.style.opacity = '0';
            effect.style.zIndex = '20';
            effect.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes negative-mental {
                    0% { opacity: 0; }
                    30% { opacity: 1; }
                    100% { opacity: 0; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'negative-mental 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Visual effect for missed opportunity
        function showMissedOpportunityEffect() {
            const effect = document.createElement('div');
            effect.className = 'missed-opportunity';
            effect.style.position = 'absolute';
            effect.style.top = '40%';
            effect.style.left = '50%';
            effect.style.transform = 'translate(-50%, -50%)';
            effect.style.color = 'rgba(150, 150, 150, 0.8)';
            effect.style.fontSize = '40px';
            effect.style.fontWeight = 'bold';
            effect.style.zIndex = '25';
            effect.style.opacity = '0';
            effect.style.textShadow = '0 0 10px rgba(150, 150, 150, 0.5)';
            effect.innerHTML = '<span style="text-decoration: line-through;"></span>';
            
            document.getElementById('game-container').appendChild(effect);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes missed-opportunity {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    50% { opacity: 0.8; transform: translate(-50%, -50%) scale(1.2); }
                    100% { opacity: 0; transform: translate(-50%, -50%) scale(0.9); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            effect.style.animation = 'missed-opportunity 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1500);
        }
        
        // Apply powerup effect (when collecting without dialog)
        function applyPowerup(powerup) {
            // For modern gameplay with interaction, show dialog instead of direct application
            showPowerupDialog(powerup);
            return;
        }
        
        // Show obstacle dialog with persuasive text and enhanced visuals
        function showObstacleDialog(obstacle) {
            // Pause the game
            gamePaused = true;
            currentObstacle = obstacle;
            persuasionStage = 0; // Reset persuasion stage
            
            // Set dialog content - initial stage
            document.getElementById('obstacle-title').textContent = obstacle.obstacleTitle;
            document.getElementById('obstacle-text').textContent = obstacle.initialText;
            
            // Change button text to be more professional
            document.getElementById('ignore-btn').textContent = "住专";
            document.getElementById('accept-btn').textContent = "住";
            
            // Enhanced visual styling based on obstacle type
            const dialogBox = document.getElementById('obstacle-dialog');
            
            // Reset any previous custom styling
            dialogBox.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.15)';
            
            // Add type-specific styling
            switch(obstacle.type) {
                case 'person':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(100, 100, 150, 0.3)';
                    break;
                case 'ad':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(73, 80, 87, 0.3)';
                    break;
                case 'food':
                    dialogBox.style.boxShadow = '0 5px 20px rgba(211, 135, 62, 0.3)';
                    break;
            }
            
            // Show dialog with enhanced animation
            dialogBox.style.display = 'block';
            
            // Add a warning overlay effect
            const warningOverlay = document.createElement('div');
            warningOverlay.className = 'warning-overlay';
            warningOverlay.style.position = 'absolute';
            warningOverlay.style.top = '0';
            warningOverlay.style.left = '0';
            warningOverlay.style.width = '100%';
            warningOverlay.style.height = '100%';
            warningOverlay.style.backgroundColor = 'rgba(200, 50, 50, 0.1)';
            warningOverlay.style.opacity = '0';
            warningOverlay.style.transition = 'opacity 0.5s ease';
            warningOverlay.style.zIndex = '15';
            warningOverlay.style.pointerEvents = 'none';
            
            document.getElementById('game-container').appendChild(warningOverlay);
            
            // Fade in the warning overlay
            setTimeout(() => {
                warningOverlay.style.opacity = '1';
            }, 100);
            
            // Store reference to remove later
            currentObstacle.warningOverlay = warningOverlay;
            
            // Add a warning icon animation near the obstacle position
            if (obstacle.x && obstacle.y) {
                const warningIcon = document.createElement('div');
                warningIcon.className = 'warning-icon';
                warningIcon.style.position = 'absolute';
                warningIcon.style.top = `${obstacle.y - 40}px`;
                warningIcon.style.left = `${obstacle.x}px`;
                warningIcon.style.fontSize = '24px';
                warningIcon.style.color = 'red';
                warningIcon.style.zIndex = '16';
                warningIcon.style.opacity = '0.9';
                warningIcon.textContent = '锔';
                warningIcon.style.animation = 'warning-bounce 0.8s infinite alternate';
                
                document.getElementById('game-container').appendChild(warningIcon);
                
                // Add animation style if not already defined
                if (!document.getElementById('warning-animation-style')) {
                    const style = document.createElement('style');
                    style.id = 'warning-animation-style';
                    style.textContent = `
                        @keyframes warning-bounce {
                            from { transform: translateY(0); }
                            to { transform: translateY(-10px); }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Store reference to remove later
                currentObstacle.warningIcon = warningIcon;
            }
        }
        
        // Continue to next persuasion stage with enhanced visuals
        function continuePersuasion() {
            if (!currentObstacle) return;
            
            persuasionStage++;
            
            // Check if we have more persuasive texts
            if (persuasionStage <= currentObstacle.persuasiveTexts.length) {
                // Update text for current stage with animation
                const textElement = document.getElementById('obstacle-text');
                
                // Fade out current text
                textElement.style.transition = 'opacity 0.2s, transform 0.2s';
                textElement.style.opacity = '0';
                textElement.style.transform = 'translateY(-10px)';
                
                // After fade out, update text and fade in
                setTimeout(() => {
                    textElement.textContent = currentObstacle.persuasiveTexts[persuasionStage - 1];
                    
                    // Fade in new text
                    textElement.style.transform = 'translateY(0)';
                    textElement.style.opacity = '1';
                }, 200);
                
                // If this is the last stage, change the ignore button text
                if (persuasionStage === currentObstacle.persuasiveTexts.length) {
                    document.getElementById('ignore-btn').textContent = " 住驻转: 住专";
                    document.getElementById('ignore-btn').style.fontWeight = 'bold';
                    document.getElementById('ignore-btn').style.background = 'var(--success-color)';
                } else {
                    document.getElementById('ignore-btn').textContent = "住专";
                }
                
                // Visual effect on each persuasion stage
                const persuasionEffect = document.createElement('div');
                persuasionEffect.className = 'persuasion-pulse';
                persuasionEffect.style.position = 'absolute';
                persuasionEffect.style.top = '0';
                persuasionEffect.style.left = '0';
                persuasionEffect.style.width = '100%';
                persuasionEffect.style.height = '100%';
                persuasionEffect.style.background = 'radial-gradient(circle at center, rgba(150, 50, 50, 0.1) 0%, rgba(150, 50, 50, 0) 70%)';
                persuasionEffect.style.opacity = '0';
                persuasionEffect.style.zIndex = '14';
                persuasionEffect.style.pointerEvents = 'none';
                
                document.getElementById('game-container').appendChild(persuasionEffect);
                
                // Define animation for persuasion pulse
                const pulseStyle = document.createElement('style');
                pulseStyle.textContent = `
                    @keyframes persuasion-pulse {
                        0% { opacity: 0; }
                        50% { opacity: 1; }
                        100% { opacity: 0; }
                    }
                `;
                document.head.appendChild(pulseStyle);
                
                // Apply animation
                persuasionEffect.style.animation = 'persuasion-pulse 1s ease-out forwards';
                
                // Remove elements after animation
                setTimeout(() => {
                    if (persuasionEffect.parentNode) {
                        persuasionEffect.parentNode.removeChild(persuasionEffect);
                    }
                    if (pulseStyle.parentNode) {
                        pulseStyle.parentNode.removeChild(pulseStyle);
                    }
                }, 1000);
            } else {
                // If no more texts, close the dialog
                hideObstacleDialog();
                stats.obstaclesAvoided++; // Increment obstacle resistance counter
                
                // Small mental boost for fully resisting
                stats.mentalHealth = Math.min(100, stats.mentalHealth + 5);
                updatePlayerCondition();
                
                // Show resistance message
                showPopupMessage("拽转  驻住转 砖转!", 2500);
                
                // Add visual reinforcement for good decision
                showPositiveDecisionEffect();
                
                // Check resistance achievement
                if (stats.obstaclesAvoided >= 20 && !achievements.resistanceMaster.earned) {
                    achievements.resistanceMaster.earned = true;
                    addAchievement(achievements.resistanceMaster.text);
                }
            }
        }
        
        // Visual effect for positive financial decision
        function showPositiveDecisionEffect() {
            // Create shield-like visual around player
            const shield = document.createElement('div');
            shield.className = 'decision-shield';
            shield.style.position = 'absolute';
            shield.style.top = `${player.y + player.height / 2}px`;
            shield.style.left = `${player.x + player.width / 2}px`;
            shield.style.width = '0';
            shield.style.height = '0';
            shield.style.borderRadius = '50%';
            shield.style.background = 'radial-gradient(circle, rgba(58, 122, 95, 0.2) 0%, rgba(58, 122, 95, 0) 70%)';
            shield.style.transform = 'translate(-50%, -50%)';
            shield.style.zIndex = '15';
            
            document.getElementById('game-container').appendChild(shield);
            
            // Define animation for expanding shield
            const shieldStyle = document.createElement('style');
            shieldStyle.textContent = `
                @keyframes shield-expand {
                    0% { width: 0; height: 0; opacity: 0; }
                    50% { width: 200px; height: 200px; opacity: 0.7; }
                    100% { width: 300px; height: 300px; opacity: 0; }
                }
            `;
            document.head.appendChild(shieldStyle);
            
            // Apply animation
            shield.style.animation = 'shield-expand 1.5s ease-out forwards';
            
            // Add checkmark icon
            const checkmark = document.createElement('div');
            checkmark.className = 'decision-checkmark';
            checkmark.style.position = 'absolute';
            checkmark.style.top = `${player.y - 30}px`;
            checkmark.style.left = `${player.x + player.width / 2}px`;
            checkmark.style.transform = 'translate(-50%, -50%)';
            checkmark.style.fontSize = '30px';
            checkmark.style.color = 'rgb(58, 122, 95)';
            checkmark.style.zIndex = '16';
            checkmark.style.opacity = '0';
            checkmark.textContent = '';
            
            document.getElementById('game-container').appendChild(checkmark);
            
            // Define animation for checkmark
            const checkStyle = document.createElement('style');
            checkStyle.textContent = `
                @keyframes checkmark-appear {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    50% { opacity: 1; transform: translate(-50%, -50%) scale(1.5); }
                    100% { opacity: 0; transform: translate(-50%, -130%) scale(1); }
                }
            `;
            document.head.appendChild(checkStyle);
            
            // Apply animation
            checkmark.style.animation = 'checkmark-appear 1.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (shield.parentNode) {
                    shield.parentNode.removeChild(shield);
                }
                if (shieldStyle.parentNode) {
                    shieldStyle.parentNode.removeChild(shieldStyle);
                }
                if (checkmark.parentNode) {
                    checkmark.parentNode.removeChild(checkmark);
                }
                if (checkStyle.parentNode) {
                    checkStyle.parentNode.removeChild(checkStyle);
                }
            }, 1500);
        }
        
        // Handle accepting obstacle with enhanced visuals
        function acceptObstacle() {
            if (!currentObstacle) return;
            
            // Apply the negative effects
            score -= currentObstacle.value;
            stats.expenses += currentObstacle.value;
            
            // Apply specific effects based on obstacle type
            if (currentObstacle.type === 'person') {
                stats.mentalHealth -= currentObstacle.mentalEffect;
                showPopupMessage(`抓 专转 砖驻注 注: -${currentObstacle.mentalEffect} 拽转 住 `, 2500);
                showNegativeMentalEffect();
            } else if (currentObstacle.type === 'food') {
                stats.physicalHealth -= currentObstacle.weightEffect;
                showPopupMessage(` 转转转  转: -${currentObstacle.weightEffect} 拽转 专转`, 2500);
                showNegativePhysicalEffect();
            } else {
                showPopupMessage(`爪 转 转转: ${currentObstacle.value} 砖"`, 2000);
                showMoneyLossEffect(currentObstacle.value);
            }
            
            // Update obstacle interactions counter
            stats.obstaclesFaced++;
            
            // Update player condition
            updatePlayerCondition();
            updateDisplay();
            
            // Reset and continue game
            hideObstacleDialog();
            
            // Check if player is now bankrupt
            if (score < 0) {
                gameOver(` 砖  拽专住 驻住转. 爪转 转专  注 ${currentObstacle.text}`);
                return;
            }
            
            // Check if mental or physical health is too low
            if (stats.mentalHealth <= 20) {
                gameOver("住  砖 驻注 砖注转转.  住 砖.");
                return;
            }
            
            if (stats.physicalHealth <= 20) {
                gameOver("专转 驻转 驻注 驻 专. 拽砖  砖 专.");
                return;
            }
        }
        
        // Visual effect for money loss
        function showMoneyLossEffect(amount) {
            // Create money loss text
            const lossText = document.createElement('div');
            lossText.className = 'money-loss';
            lossText.style.position = 'absolute';
            lossText.style.top = '40%';
            lossText.style.left = '50%';
            lossText.style.transform = 'translate(-50%, -50%)';
            lossText.style.fontSize = '36px';
            lossText.style.fontWeight = 'bold';
            lossText.style.color = '#d45b5b';
            lossText.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            lossText.style.zIndex = '30';
            lossText.style.opacity = '0';
            lossText.textContent = `-${amount} `;
            
            document.getElementById('game-container').appendChild(lossText);
            
            // Define the animation keyframes
            const style = document.createElement('style');
            style.textContent = `
                @keyframes money-loss-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.5); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.2); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, 0) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            lossText.style.animation = 'money-loss-anim 2s ease-out forwards';
            
            // Create falling coins for large amounts
            if (amount > 1000) {
                const coinCount = Math.min(8, Math.floor(amount / 500));
                
                for (let i = 0; i < coinCount; i++) {
                    const coin = document.createElement('div');
                    coin.className = 'falling-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '20px';
                    coin.style.height = '20px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#d45b5b';
                    coin.style.boxShadow = '0 0 5px rgba(212, 91, 91, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '12px';
                    coin.textContent = '';
                    
                    // Position at center of screen initially
                    coin.style.top = '40%';
                    coin.style.left = '50%';
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create dynamic animation for each coin
                    const fallDelay = Math.random() * 0.5;
                    const fallDuration = 1 + Math.random() * 0.5;
                    const horizontalOffset = (Math.random() * 200) - 100; // -100px to 100px
                    
                    // Create specific keyframes for this coin
                    const coinKeyframes = `
                        @keyframes coin-fall-${i} {
                            0% { 
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1); 
                            }
                            100% { 
                                opacity: 0;
                                transform: translate(calc(-50% + ${horizontalOffset}px), calc(-50% + 200px)) scale(0.5) rotate(${Math.random() * 360}deg); 
                            }
                        }
                    `;
                    
                    // Add style for this specific coin
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-fall-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDelay + fallDuration + 0.1) * 1000);
                }
            }
            
            // Remove elements after animation
            setTimeout(() => {
                if (lossText.parentNode) {
                    lossText.parentNode.removeChild(lossText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2000);
        }
        // Hide obstacle dialog and continue game with cleanup
        function hideObstacleDialog() {
            // Hide dialog with fade out animation
            const dialogBox = document.getElementById('obstacle-dialog');
            dialogBox.style.animation = 'obstacle-dialog-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('obstacle-dialog-exit-style')) {
                const style = document.createElement('style');
                style.id = 'obstacle-dialog-exit-style';
                style.textContent = `
                    @keyframes obstacle-dialog-exit {
                        from { 
                            opacity: 1; 
                            transform: translate(-50%, -50%) scale(1); 
                        }
                        to { 
                            opacity: 0; 
                            transform: translate(-50%, -40%) scale(0.95); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Clean up warning elements
            if (currentObstacle && currentObstacle.warningOverlay) {
                currentObstacle.warningOverlay.style.opacity = '0';
                setTimeout(() => {
                    if (currentObstacle.warningOverlay.parentNode) {
                        currentObstacle.warningOverlay.parentNode.removeChild(currentObstacle.warningOverlay);
                    }
                }, 500);
            }
            
            if (currentObstacle && currentObstacle.warningIcon) {
                if (currentObstacle.warningIcon.parentNode) {
                    currentObstacle.warningIcon.parentNode.removeChild(currentObstacle.warningIcon);
                }
            }
            
            // Hide dialog after animation
            setTimeout(() => {
                dialogBox.style.display = 'none';
                currentObstacle = null;
                gamePaused = false;
                persuasionStage = 0;
                
                // Reset ignore button text and style
                document.getElementById('ignore-btn').textContent = "住专";
                document.getElementById('ignore-btn').style.fontWeight = 'normal';
                document.getElementById('ignore-btn').style.background = 'var(--success-color)';
            }, 300);
        }
        
        // Collision detection
        function checkCollision(obj1, obj2) {
            return obj1.x < obj2.x + obj2.width &&
                   obj1.x + obj1.width > obj2.x &&
                   obj1.y < obj2.y + obj2.height &&
                   obj1.y + obj1.height > obj2.y;
        }
        
        // Handle obstacle hit
        function hitObstacle(obstacle) {
            // See if enough time has passed since last obstacle dialog
            const now = Date.now();
            if (now - lastObstacleTime < minObstacleInterval) {
                // Too soon for another obstacle dialog
                return true;
            }
            
            // Show obstacle dialog with enhanced animation
            showObstacleDialog(obstacle);
            lastObstacleTime = now;
            
            return true; // Obstacle is handled (will be removed in the main loop)
        }
        
        // Update game state
        function updateGame() {
            if (!gameRunning || gamePaused) return;
            
            // Update day/night cycle first
            updateDayNightCycle();
            
            // Show financial tip periodically
            if (Math.random() < 0.0003 && !financeMessageTimer) { // Approx every 5-6 minutes
                showFinanceTip();
            }
            
            // Update month timer only if player is moving (pressing screen)
            if (isMoving) {
                // Progress at speed adjusted to player condition
                currentMonthTimer += player.currentSpeed / player.baseSpeed;
                
                // Movement instructions - show after 5 seconds of no movement
                if (moveTimer) {
                    clearTimeout(moveTimer);
                    moveTimer = null;
                    document.getElementById('movement-instruction').style.display = 'none';
                }
            } else {
                // Show movement instructions if player doesn't move for a few seconds - shorter time, more prominent
                if (!moveTimer && !tutorialShown) {
                    moveTimer = setTimeout(() => {
                        document.getElementById('movement-instruction').style.display = 'block';
                        // 住驻转 驻拽  专转 转
                        let blinkCount = 0;
                        const blinkInterval = setInterval(() => {
                            if (blinkCount >= 6 || isMoving) { //  3 驻注 (-拽)  注 砖砖拽 
                                clearInterval(blinkInterval);
                                document.getElementById('movement-instruction').style.opacity = '1';
                                return;
                            }
                            
                            const elem = document.getElementById('movement-instruction');
                            elem.style.opacity = elem.style.opacity === '0.3' ? '1' : '0.3';
                            blinkCount++;
                        }, 500); //   爪 砖
                    }, 2000); // 拽爪专  -2 砖转 拽 5
                }
            }
            
            if (currentMonthTimer >= framesPerMonth) {
                currentMonthTimer = 0;
                currentMonth++;
                stats.monthsPlayed++;
                
                // Add monthly income to score with animation
                score += stats.income;
                showMonthlyIncomeEffect();
                
                // Slightly recover mental and physical health each month
                stats.mentalHealth = Math.min(100, stats.mentalHealth + 2);
                stats.physicalHealth = Math.min(100, stats.physicalHealth + 2);
                updatePlayerCondition();
                
                // Reset monthly counters at the beginning of a new month
                monthlyObstacleCounter = {
                    person: 0,
                    ad: 0,
                    food: 0
                };
                
                monthlyPowerupCounter = {
                    money: 0,
                    earlyRise: 0,
                    earlySleep: 0,
                    healthyFood: 0,
                    exercise: 0,
                    companion: 0
                };
                
                // Check win condition
                if (score >= 100000) {
                    winGame();
                    return;
                }
                
                // Update display
                updateDisplay();
                
                // Show month transition animation
                showMonthTransitionEffect();
                
                // Maybe show job offer (15% chance each month)
                if (Math.random() < 0.15) {
                    showJobOffer();
                }
                
                // Create monthly powerups
                const monthlyTypes = ['money', 'earlyRise', 'earlySleep', 'healthyFood', 'exercise'];
                monthlyTypes.forEach(type => {
                    // Schedule powerups throughout the month
                    setTimeout(() => {
                        createCustomPowerup(type);
                    }, getRandomInt(5, monthDuration * 0.7) * 1000);
                });
                
                // Every 2 months, create a companion powerup
                if (currentMonth % 2 === 0) {
                    setTimeout(() => {
                        createCompanion();
                    }, getRandomInt(10, monthDuration * 0.6) * 1000);
                }
                
                // First month achievement
                if (currentMonth === 1 && !achievements.firstMonth.earned) {
                    achievements.firstMonth.earned = true;
                    addAchievement(achievements.firstMonth.text);
                }
                
                // Check savings achievement
                if (score >= 50000 && !achievements.saveHero.earned) {
                    achievements.saveHero.earned = true;
                    addAchievement(achievements.saveHero.text);
                }
                
                // Check mental strength achievement
                if (stats.mentalHealth >= 90 && currentMonth >= 5 && !achievements.mentalStrength.earned) {
                    achievements.mentalStrength.earned = true;
                    addAchievement(achievements.mentalStrength.text);
                }
            }
            
            // Update powerup status
            if (player.powerUp) {
                player.powerUpTime--;
                
                // Update power meter with smoother animation
                const powerFill = document.getElementById('power-meter-fill');
                const powerPercentage = (player.powerUpTime / maxPowerUpTime) * 100;
                powerFill.style.width = `${Math.min(100, powerPercentage)}%`;
                
                // Change color based on time remaining
                if (powerPercentage < 20) {
                    powerFill.style.backgroundColor = 'var(--danger-color)';
                } else if (powerPercentage < 50) {
                    powerFill.style.backgroundColor = 'var(--warning-color)';
                } else {
                    powerFill.style.backgroundColor = 'var(--success-color)';
                }
                
                if (player.powerUpTime <= 0) {
                    player.powerUp = false;
                    player.companion = false;
                    document.getElementById('power-meter').style.display = 'none';
                    showPopupMessage("砖驻注转 拽 住转", 1500);
                }
            }
            
            // Update obstacles
            for (let i = obstacles.length - 1; i >= 0; i--) {
                const obstacle = obstacles[i];
                
                // Update position only if player is moving
                if (isMoving) {
                    obstacle.x -= obstacle.speed;
                    
                    // Apply any obstacle-specific animations
                    if (obstacle.bobSpeed) {
                        obstacle.y = obstacle.y + Math.sin(Date.now() * obstacle.bobSpeed + obstacle.animationOffset) * 2;
                    }
                    
                    // For ad obstacles, add pulsing effect
                    if (obstacle.type === 'ad' && obstacle.pulseRate) {
                        obstacle.pulseValue = (Math.sin(Date.now() * obstacle.pulseRate) + 1) / 2; // 0 to 1
                    }
                }
                
                // Check for collision
                if (checkCollision(player, obstacle)) {
                    const survived = hitObstacle(obstacle);
                    obstacles.splice(i, 1);
                    
                    if (!survived) return; // Game over
                }
                
                // Remove if off-screen
                if (obstacle.x + obstacle.width < 0) {
                    obstacles.splice(i, 1);
                }
            }
            
            // Update powerups
            for (let i = powerups.length - 1; i >= 0; i--) {
                const powerup = powerups[i];
                
                // Update position only if player is moving
                if (isMoving) {
                    powerup.x -= powerup.speed;
                    
                    // Apply floating animation if available
                    if (powerup.floatSpeed && powerup.originalY) {
                        powerup.y = powerup.originalY + Math.sin(Date.now() * powerup.floatSpeed + powerup.animationOffset) * powerup.floatRange;
                    }
                }
                
                // Check for collision
                if (checkCollision(player, powerup)) {
                    // Apply powerup effect
                    applyPowerup(powerup);
                    powerups.splice(i, 1);
                }
                
                // Remove if off-screen
                if (powerup.x + powerup.width < 0) {
                    powerups.splice(i, 1);
                }
            }
            
            // Maybe create a new obstacle (0.3% chance per frame - slower for longer game)
            if (Math.random() < 0.003 && isMoving) {
                // Ensure there's enough distance from the last obstacle
                let canCreateObstacle = true;
                
                for (let i = 0; i < obstacles.length; i++) {
                    if (obstacles[i].x > canvas.width - 350) { // More space between obstacles
                        canCreateObstacle = false;
                        break;
                    }
                }
                
                if (canCreateObstacle) {
                    createObstacle();
                }
            }
            
            // Maybe create a new powerup (0.1% chance per frame - fewer powerups)
            if (Math.random() < 0.001 && isMoving) {
                // Make sure powerups are spaced out
                let canCreatePowerup = true;
                
                for (let i = 0; i < powerups.length; i++) {
                    if (powerups[i].x > canvas.width - 400) { // More space between powerups
                        canCreatePowerup = false;
                        break;
                    }
                }
                
                if (canCreatePowerup) {
                    createPowerup();
                }
            }
            
            // Process any pending obstacles
            if (pendingObstacles.length > 0 && gameRunning && isMoving) {
                const now = Date.now();
                
                for (let i = pendingObstacles.length - 1; i >= 0; i--) {
                    if (now >= pendingObstacles[i].time) {
                        createObstacle();
                        pendingObstacles.splice(i, 1);
                    }
                }
            }
            
            // Render game
            renderGame();
            
            // Update game message time
            if (gameMessageTime > 0) {
                gameMessageTime--;
                if (gameMessageTime <= 0) {
                    gameMessage = '';
                }
            }
        }
        
        // Monthly income visual effect
        function showMonthlyIncomeEffect() {
            // Create income text effect
            const incomeText = document.createElement('div');
            incomeText.className = 'income-text';
            incomeText.style.position = 'absolute';
            incomeText.style.top = '40%';
            incomeText.style.left = '50%';
            incomeText.style.transform = 'translate(-50%, -50%)';
            incomeText.style.fontSize = '32px';
            incomeText.style.fontWeight = 'bold';
            incomeText.style.color = '#3a7a5f';
            incomeText.style.textShadow = '0 0 10px rgba(58, 122, 95, 0.7), 0 0 5px rgba(0, 0, 0, 0.5)';
            incomeText.style.zIndex = '30';
            incomeText.style.opacity = '0';
            incomeText.textContent = `+${stats.income.toLocaleString()} 砖" 砖专转 砖转`;
            
            document.getElementById('game-container').appendChild(incomeText);
            
            // Define animation
            const style = document.createElement('style');
            style.textContent = `
                @keyframes income-text-anim {
                    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
                    30% { opacity: 1; transform: translate(-50%, -50%) scale(1.1); }
                    70% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
                    100% { opacity: 0; transform: translate(-50%, -100%) scale(1); }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            incomeText.style.animation = 'income-text-anim 2.5s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (incomeText.parentNode) {
                    incomeText.parentNode.removeChild(incomeText);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 2500);
            
            // Show falling money for visual reinforcement
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'income-coin';
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.width = '30px';
                    coin.style.height = '30px';
                    coin.style.borderRadius = '50%';
                    coin.style.backgroundColor = '#3a7a5f';
                    coin.style.boxShadow = '0 0 10px rgba(58, 122, 95, 0.7)';
                    coin.style.zIndex = '29';
                    coin.style.display = 'flex';
                    coin.style.justifyContent = 'center';
                    coin.style.alignItems = 'center';
                    coin.style.color = '#fff';
                    coin.style.fontWeight = 'bold';
                    coin.style.fontSize = '18px';
                    coin.textContent = '';
                    
                    // Position at top of screen
                    const startX = Math.random() * canvas.width;
                    coin.style.top = '-30px';
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation
                    const fallDuration = 1.5 + Math.random();
                    const fallDelay = Math.random() * 0.5;
                    const rotation = Math.random() * 360;
                    const endX = startX + (Math.random() * 200 - 100);
                    
                    const coinKeyframes = `
                        @keyframes coin-income-${i} {
                            0% { 
                                opacity: 1;
                                transform: translateY(0) rotate(0deg); 
                            }
                            80% {
                                opacity: 1;
                            }
                            100% { 
                                opacity: 0;
                                transform: translateY(${canvas.height}px) translateX(${endX - startX}px) rotate(${rotation}deg); 
                            }
                        }
                    `;
                    
                    const coinStyle = document.createElement('style');
                    coinStyle.textContent = coinKeyframes;
                    document.head.appendChild(coinStyle);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `coin-income-${i} ${fallDuration}s ease-in forwards`;
                    }, fallDelay * 1000);
                    
                    // Remove coin after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (coinStyle.parentNode) {
                            coinStyle.parentNode.removeChild(coinStyle);
                        }
                    }, (fallDuration + fallDelay + 0.1) * 1000);
                }, i * 100); // Stagger coin creation
            }
        }
        
        // Month transition effect
        function showMonthTransitionEffect() {
            // Create month transition overlay
            const overlay = document.createElement('div');
            overlay.className = 'month-transition';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            overlay.style.zIndex = '40';
            overlay.style.pointerEvents = 'none';
            overlay.style.display = 'flex';
            overlay.style.justifyContent = 'center';
            overlay.style.alignItems = 'center';
            
            // Create month text
            const monthText = document.createElement('div');
            monthText.style.fontSize = '48px';
            monthText.style.fontWeight = 'bold';
            monthText.style.color = 'rgba(42, 100, 150, 0)';
            monthText.style.textShadow = '0 0 20px rgba(42, 100, 150, 0.5)';
            monthText.style.opacity = '0';
            monthText.style.transform = 'scale(0.8)';
            monthText.style.transition = 'all 0.5s ease';
            monthText.textContent = monthNames[currentMonth];
            
            overlay.appendChild(monthText);
            document.getElementById('game-container').appendChild(overlay);
            
            // Animate the transition
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0.3)';
                monthText.style.opacity = '1';
                monthText.style.color = 'rgba(42, 100, 150, 1)';
                monthText.style.transform = 'scale(1.2)';
            }, 100);
            
            setTimeout(() => {
                monthText.style.opacity = '0';
                monthText.style.transform = 'scale(0.8)';
                overlay.style.backgroundColor = 'rgba(255, 255, 255, 0)';
            }, 1500);
            
            // Remove overlay after animation
            setTimeout(() => {
                if (overlay.parentNode) {
                    overlay.parentNode.removeChild(overlay);
                }
            }, 2000);
        }
        // Create a specific type of powerup with enhanced visuals
        function createCustomPowerup(type) {
            let text = '';
            let width = 40;
            let height = 40;
            let value = 1000;
            let healthEffect = 0;
            let mentalEffect = 0;
            let color = '';
            
            switch(type) {
                case 'money':
                    text = "住 住驻";
                    value = getRandomInt(1000, 3000);
                    color = "#2a6496"; // Blue
                    break;
                case 'earlyRise':
                    text = "拽 拽转";
                    mentalEffect = 10;
                    color = "#3a7a5f"; // Green
                    break;
                case 'earlySleep':
                    text = "砖 拽转";
                    mentalEffect = 15;
                    color = "#5a5a8f"; // Purple
                    break;
                case 'healthyFood':
                    text = "转 专";
                    healthEffect = 15;
                    color = "#3a7a5f"; // Green
                    break;
                case 'exercise':
                    text = "驻注转 驻转";
                    healthEffect = 20;
                    color = "#d3873e"; // Orange
                    break;
            }
            
            const powerup = {
                x: canvas.width,
                y: getRandomInt(ground.y - 150, ground.y - 60),
                width: width,
                height: height,
                type: type,
                speed: 4,
                text: text,
                value: value,
                healthEffect: healthEffect,
                mentalEffect: mentalEffect,
                color: color,
                animationOffset: Math.random() * Math.PI * 2,
                floatSpeed: 0.03 + Math.random() * 0.02,
                floatRange: 10 + Math.random() * 5,
                glowing: true,
                originalY: 0
            };
            
            // Store original Y for floating animation
            powerup.originalY = powerup.y;
            
            powerups.push(powerup);
            
            // Visual cue for powerup arrival
            showPowerupArrivalCue(powerup);
        }
        
        // Visual cue for powerup arrival
        function showPowerupArrivalCue(powerup) {
            // Create a subtle flash at the edge where the powerup will appear
            const flash = document.createElement('div');
            flash.className = 'powerup-arrival-flash';
            flash.style.position = 'absolute';
            flash.style.right = '0';
            flash.style.top = `${powerup.y}px`;
            flash.style.width = '20px';
            flash.style.height = `${powerup.height * 1.5}px`;
            flash.style.borderRadius = '10px 0 0 10px';
            flash.style.zIndex = '9';
            flash.style.opacity = '0';
            
            // Set color based on powerup type
            switch(powerup.type) {
                case 'money':
                    flash.style.backgroundColor = 'rgba(42, 100, 150, 0.6)';
                    break;
                case 'earlyRise':
                case 'healthyFood':
                    flash.style.backgroundColor = 'rgba(58, 122, 95, 0.6)';
                    break;
                case 'earlySleep':
                    flash.style.backgroundColor = 'rgba(90, 90, 143, 0.6)';
                    break;
                case 'exercise':
                    flash.style.backgroundColor = 'rgba(211, 135, 62, 0.6)';
                    break;
                default:
                    flash.style.backgroundColor = 'rgba(100, 100, 100, 0.6)';
            }
            
            document.getElementById('game-container').appendChild(flash);
            
            // Define animation for flash
            const style = document.createElement('style');
            style.textContent = `
                @keyframes powerup-arrival-flash {
                    0% { opacity: 0; width: 5px; }
                    50% { opacity: 0.8; width: 20px; }
                    100% { opacity: 0; width: 5px; }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            flash.style.animation = 'powerup-arrival-flash 1s ease-out forwards';
            
            // Remove elements after animation
            setTimeout(() => {
                if (flash.parentNode) {
                    flash.parentNode.removeChild(flash);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 1000);
        }
        
        // Render game with enhanced visuals
        function renderGame() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw sky with dynamic coloring based on time
            drawDynamicBackground();
            
            // Draw subtle background patterns
            drawBackgroundPatterns();
            
            // Draw ground
            const groundGradient = ctx.createLinearGradient(0, ground.y, 0, canvas.height);
            groundGradient.addColorStop(0, "#adb5bd");
            groundGradient.addColorStop(1, "#6c757d");
            ctx.fillStyle = groundGradient;
            ctx.fillRect(0, ground.y, ground.width, ground.height);
            
            // Draw "stable career path" text on the ground
            ctx.fillStyle = "rgba(255, 255, 255, 0.6)";
            ctx.font = "bold 20px 'Open Sans', Arial";
            ctx.textAlign = "center";
            const text = "转 拽专专 爪";
            
            // Create pattern with the text repeating across the ground
            const textWidth = ctx.measureText(text).width;
            const repetitions = Math.ceil(canvas.width / (textWidth + 100));
            
            for (let i = 0; i < repetitions; i++) {
                ctx.fillText(text, (textWidth + 100) * i + textWidth/2 + 50, ground.y + 40);
            }
            
            ctx.textAlign = "start";
            
            // Draw path edge with enhanced shadow
            const pathGlow = isDayTime ? 'rgba(73, 80, 87, 0.7)' : 'rgba(73, 80, 87, 0.9)';
            ctx.fillStyle = pathGlow;
            ctx.fillRect(0, ground.y, ground.width, 5);
            
            // Add subtle shadow/highlight to path edge based on time of day
            if (!isDayTime) {
                // Night shadow
                ctx.fillStyle = 'rgba(0, 0, 30, 0.3)';
                ctx.fillRect(0, ground.y + 5, ground.width, 3);
            } else {
                // Day highlight
                ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.fillRect(0, ground.y - 1, ground.width, 1);
            }
            
            // Draw player - enhanced style
            drawEnhancedPlayer();
            
            // Draw obstacles with enhanced visuals
            obstacles.forEach(obstacle => {
                switch(obstacle.type) {
                    case 'person':
                        // Draw influencer (negative influence) - more abstract shape with animation
                        ctx.fillStyle = obstacle.color || "#6c757d";
                        
                        // Apply bobbing animation
                        const personY = obstacle.y;
                        
                        // Body as rounded rectangle
                        roundRect(ctx, obstacle.x, personY, obstacle.width, obstacle.height, 10, true, false);
                        
                        // Head
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width/2, personY + obstacle.width/2, obstacle.width/2.5, 0, Math.PI * 2);
                        ctx.fill();
                        
                        // Negative expression (minimalist)
                        ctx.strokeStyle = isDayTime ? "#e9ecef" : "#f8f9fa";
                        ctx.lineWidth = 2;
                        
                        // Eyes - now with animation
                        const blinkState = Math.floor(Date.now() / 1000) % 5 === 0;
                        
                        if (blinkState) {
                            // Closed eyes (blinking)
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + obstacle.width/3 - 4, personY + obstacle.width/2);
                            ctx.lineTo(obstacle.x + obstacle.width/3 + 4, personY + obstacle.width/2);
                            
                            ctx.moveTo(obstacle.x + obstacle.width*2/3 - 4, personY + obstacle.width/2);
                            ctx.lineTo(obstacle.x + obstacle.width*2/3 + 4, personY + obstacle.width/2);
                        } else {
                            // X eyes (not blinking)
                            ctx.beginPath();
                            ctx.moveTo(obstacle.x + obstacle.width/3, personY + obstacle.width/2 - 5);
                            ctx.lineTo(obstacle.x + obstacle.width/3 + 8, personY + obstacle.width/2 + 5);
                            ctx.moveTo(obstacle.x + obstacle.width/3, personY + obstacle.width/2 + 5);
                            ctx.lineTo(obstacle.x + obstacle.width/3 + 8, personY + obstacle.width/2 - 5);
                            
                            ctx.moveTo(obstacle.x + obstacle.width*2/3, personY + obstacle.width/2 - 5);
                            ctx.lineTo(obstacle.x + obstacle.width*2/3 - 8, personY + obstacle.width/2 + 5);
                            ctx.moveTo(obstacle.x + obstacle.width*2/3, personY + obstacle.width/2 + 5);
                            ctx.lineTo(obstacle.x + obstacle.width*2/3 - 8, personY + obstacle.width/2 - 5);
                        }
                        ctx.stroke();
                        
                        // Mouth (animated - sometimes frowning more)
                        const mouthExpression = Math.sin(Date.now() * 0.001) * 3;
                        ctx.beginPath();
                        ctx.arc(obstacle.x + obstacle.width/2, personY + obstacle.width/2 + 15, 
                                obstacle.width/4, Math.PI, Math.PI * 2, true);
                        ctx.stroke();
                        
                        // Speech bubble occasionally
                        if (Math.random() < 0.01) {
                            drawSpeechBubble(ctx, obstacle.x + obstacle.width + 10, 
                                            personY + obstacle.width/2 - 10, 
                                            obstacle.text, 100, 40);
                        }
                        break;
                        
                    case 'ad':
                        // Draw ad - with pulsing effect
                        const pulseScale = obstacle.pulseValue ? 1 + (obstacle.pulseValue * 0.1) : 1;
                        const adWidth = obstacle.width * pulseScale;
                        const adHeight = obstacle.height * pulseScale;
                        const adX = obstacle.x - (adWidth - obstacle.width) / 2;
                        const adY = obstacle.y - (adHeight - obstacle.height) / 2;
                        
                        // Background with gradient
                        const adGradient = ctx.createLinearGradient(adX, adY, adX + adWidth, adY + adHeight);
                        adGradient.addColorStop(0, "#495057");
                        adGradient.addColorStop(1, "#343a40");
                        ctx.fillStyle = adGradient;
                        
                        roundRect(ctx, adX, adY, adWidth, adHeight, 8, true, false);
                        
                        // Add shiny effect
                        ctx.fillStyle = "rgba(255, 255, 255, 0.1)";
                        ctx.beginPath();
                        ctx.moveTo(adX, adY);
                        ctx.lineTo(adX + adWidth, adY);
                        ctx.lineTo(adX, adY + adHeight);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Draw ad icon with animation
                        ctx.fillStyle = "#e9ecef";
                        ctx.textAlign = "center";
                        ctx.font = "16px 'Open Sans', Arial";
                        ctx.fillText("", adX + adWidth/2, adY + adHeight/2 + 5);
                        
                        // Shopping cart icon (animated)
                        ctx.strokeStyle = "#e9ecef";
                        ctx.lineWidth = 1.5;
                        
                        // Animate cart wheels
                        const wheelRotation = Date.now() * 0.01 % (Math.PI * 2);
                        
                        ctx.beginPath();
                        // Cart body
                        ctx.moveTo(adX + adWidth/2 - 10, adY + adHeight/2 + 12);
                        ctx.lineTo(adX + adWidth/2 + 10, adY + adHeight/2 + 12);
                        ctx.lineTo(adX + adWidth/2 + 8, adY + adHeight/2 + 5);
                        ctx.lineTo(adX + adWidth/2 - 8, adY + adHeight/2 + 5);
                        ctx.closePath();
                        ctx.stroke();
                        
                        // Wheels with rotation
                        ctx.beginPath();
                        ctx.arc(adX + adWidth/2 - 5, adY + adHeight/2 + 14, 2, 0 + wheelRotation, Math.PI * 2 + wheelRotation);
                        ctx.arc(adX + adWidth/2 + 5, adY + adHeight/2 + 14, 2, 0 + wheelRotation, Math.PI * 2 + wheelRotation);
                        ctx.fill();
                        
                        // Add sparkle effect on random positions
                        if (Math.random() < 0.1) {
                            const sparkleX = adX + Math.random() * adWidth;
                            const sparkleY = adY + Math.random() * adHeight;
                            
                            ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
                            ctx.beginPath();
                            ctx.arc(sparkleX, sparkleY, 1, 0, Math.PI * 2);
                            ctx.fill();
                        }
                        
                        ctx.textAlign = "start";
                        break;
                        
                    case 'food':
                        // Draw food item - with rotation effect
                        const foodRotation = obstacle.rotationSpeed ? Date.now() * obstacle.rotationSpeed : 0;
                        
                        // Save context for rotation
                        ctx.save();
                        ctx.translate(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2);
                        ctx.rotate(Math.sin(foodRotation) * 0.05); // Subtle rotation
                        ctx.translate(-(obstacle.x + obstacle.width/2), -(obstacle.y + obstacle.height/2));
                        
                        // Draw the food container
                        ctx.fillStyle = obstacle.color || "#6c757d";
                        roundRect(ctx, obstacle.x, obstacle.y, obstacle.width, obstacle.height, 8, true, false);
                        
                        // Steam effect for hot food
                        if (Math.random() < 0.2) {
                            ctx.strokeStyle = "rgba(255, 255, 255, 0.6)";
                            ctx.lineWidth = 1;
                            
                            const steamX = obstacle.x + obstacle.width/2;
                            const steamY = obstacle.y;
                            const steamHeight = 5 + Math.random() * 5;
                            
                            ctx.beginPath();
                            ctx.moveTo(steamX, steamY);
                            ctx.bezierCurveTo(
                                steamX - 5, steamY - steamHeight/2,
                                steamX + 5, steamY - steamHeight,
                                steamX, steamY - steamHeight
                            );
                            ctx.stroke();
                        }
                        
                        // Draw fork and knife icon
                        ctx.strokeStyle = "#e9ecef";
                        ctx.lineWidth = 2;
                        
                        // Fork
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width/3, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width/3, obstacle.y + obstacle.height/4 * 3);
                        ctx.moveTo(obstacle.x + obstacle.width/3 - 5, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width/3 - 5, obstacle.y + obstacle.height/4 * 2);
                        ctx.moveTo(obstacle.x + obstacle.width/3 + 5, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width/3 + 5, obstacle.y + obstacle.height/4 * 2);
                        ctx.stroke();
                        
                        // Knife
                        ctx.beginPath();
                        ctx.moveTo(obstacle.x + obstacle.width*2/3, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width*2/3, obstacle.y + obstacle.height/4 * 3);
                        ctx.moveTo(obstacle.x + obstacle.width*2/3 - 5, obstacle.y + obstacle.height/4);
                        ctx.lineTo(obstacle.x + obstacle.width*2/3 + 5, obstacle.y + obstacle.height/4);
                        ctx.stroke();
                        
                        // Restore context after rotation
                        ctx.restore();
                        break;
                        
                    default:
                        // Default obstacle - minimalist style
                        ctx.fillStyle = obstacle.color || "#6c757d";
                        roundRect(ctx, obstacle.x, obstacle.y, obstacle.width, obstacle.height, 8, true, false);
                        break;
                }
            });
            
            // Draw powerups with enhanced visuals
            powerups.forEach(powerup => {
                let fillColor = powerup.color || "#6c757d";
                
                // Draw the powerup with different shapes based on type
                if (powerup.type === 'money') {
                    // Draw financial bonus - enhanced style
                    
                    // Add glow effect
                    if (powerup.glowing) {
                        ctx.shadowColor = fillColor;
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    ctx.fillStyle = fillColor;
                    roundRect(ctx, powerup.x, powerup.y, powerup.width, powerup.height, 20, true, false);
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Shekel sign with animation
                    ctx.fillStyle = "#e9ecef";
                    ctx.font = "bold 18px 'Open Sans', Arial";
                    ctx.textAlign = "center";
                    
                    // Pulsing animation for the shekel sign
                    const pulseFactor = 1 + Math.sin(Date.now() * 0.005) * 0.2;
                    ctx.font = `bold ${18 * pulseFactor}px 'Open Sans', Arial`;
                    
                    ctx.fillText("", powerup.x + powerup.width/2, powerup.y + powerup.height/2 + 6);
                    ctx.textAlign = "start";
                    
                    // Add sparkle effects
                    if (Math.random() < 0.2) {
                        drawSparkle(powerup.x + powerup.width/2, powerup.y + powerup.height/2, 5, fillColor);
                    }
                } else if (powerup.type === 'companion') {
                    // Draw supportive character - enhanced style
                    
                    // Add glow effect
                    if (powerup.glowing) {
                        ctx.shadowColor = fillColor;
                        ctx.shadowBlur = 10;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    ctx.fillStyle = fillColor;
                    
                    // Body
                    roundRect(ctx, powerup.x, powerup.y + powerup.height/3, powerup.width, powerup.height*2/3, 8, true, false);
                    
                    // Head
                    ctx.beginPath();
                    ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/4, powerup.width/3, 0, Math.PI * 2);
                    ctx.fill();
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Friendly face with animation
                    ctx.strokeStyle = "#e9ecef";
                    ctx.lineWidth = 1.5;
                    
                    // Blinking eyes occasionally
                    const blinkState = Math.floor(Date.now() / 1000) % 4 === 0;
                    
                    if (blinkState) {
                        // Closed eyes (blinking)
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/3 - 2, powerup.y + powerup.height/4);
                        ctx.lineTo(powerup.x + powerup.width/3 + 2, powerup.y + powerup.height/4);
                        
                        ctx.moveTo(powerup.x + powerup.width*2/3 - 2, powerup.y + powerup.height/4);
                        ctx.lineTo(powerup.x + powerup.width*2/3 + 2, powerup.y + powerup.height/4);
                        ctx.stroke();
                    } else {
                        // Open eyes (not blinking)
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/3, powerup.y + powerup.height/4, 2, 0, Math.PI * 2);
                        ctx.arc(powerup.x + powerup.width*2/3, powerup.y + powerup.height/4, 2, 0, Math.PI * 2);
                        ctx.stroke();
                    }
                    
                    // Animated smile
                    const smileWidth = 0.8 + Math.sin(Date.now() * 0.003) * 0.2;
                    ctx.beginPath();
                    ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/4 + 2, powerup.width/5, 0, Math.PI * smileWidth);
                    ctx.stroke();
                    
                    // Emit particles for companion
                    if (powerup.emitParticles && Math.random() < 0.1) {
                        const particleX = powerup.x + powerup.width/2 + (Math.random() * 20 - 10);
                        const particleY = powerup.y + (Math.random() * 10);
                        
                        drawPowerupParticle(particleX, particleY, fillColor);
                    }
                } else {
                    // Draw other powerups - enhanced icons
                    
                    // Add glow effect
                    if (powerup.glowing) {
                        ctx.shadowColor = fillColor;
                        ctx.shadowBlur = 8;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 0;
                    }
                    
                    ctx.fillStyle = fillColor;
                    roundRect(ctx, powerup.x, powerup.y, powerup.width, powerup.height, 8, true, false);
                    
                    // Reset shadow
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                    
                    // Different icons for different powerups
                    ctx.strokeStyle = "#e9ecef";
                    ctx.lineWidth = 2;
                    
                    if (powerup.type === 'earlyRise') {
                        // Animated alarm clock icon
                        const clockTick = Date.now() * 0.01;
                        
                        // Clock face
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/2, powerup.width/3, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Clock hands with animation
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                        ctx.lineTo(
                            powerup.x + powerup.width/2 + Math.cos(clockTick % (Math.PI * 2)) * powerup.width/5,
                            powerup.y + powerup.height/2 + Math.sin(clockTick % (Math.PI * 2)) * powerup.width/5
                        );
                        
                        ctx.moveTo(powerup.x + powerup.width/2, powerup.y + powerup.height/2);
                        ctx.lineTo(
                            powerup.x + powerup.width/2 + Math.cos((clockTick / 12) % (Math.PI * 2)) * powerup.width/8,
                            powerup.y + powerup.height/2 + Math.sin((clockTick / 12) % (Math.PI * 2)) * powerup.width/8
                        );
                        ctx.stroke();
                        
                    } else if (powerup.type === 'earlySleep') {
                        // Animated moon icon
                        const moonPulse = 1 + Math.sin(Date.now() * 0.005) * 0.1;
                        
                        // Moon
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/2, 
                               powerup.width/3 * moonPulse, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Z's for sleep with animation
                        const zOffset = Math.sin(Date.now() * 0.003) * 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/2 + 5, powerup.y + powerup.height/2 - 8 + zOffset);
                        ctx.lineTo(powerup.x + powerup.width/2 - 5, powerup.y + powerup.height/2 - 8 + zOffset);
                        ctx.lineTo(powerup.x + powerup.width/2 + 5, powerup.y + powerup.height/2 + zOffset);
                        ctx.lineTo(powerup.x + powerup.width/2 - 5, powerup.y + powerup.height/2 + zOffset);
                        ctx.stroke();
                        
                    } else if (powerup.type === 'healthyFood') {
                        // Animated apple icon
                        const applePulse = 1 + Math.sin(Date.now() * 0.004) * 0.1;
                        
                        // Apple
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2, powerup.y + powerup.height/2 + 2, 
                               powerup.width/3 * applePulse, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Stem with slight movement
                        const stemSway = Math.sin(Date.now() * 0.002) * 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/2, powerup.y + powerup.height/2 - powerup.height/5);
                        ctx.quadraticCurveTo(
                            powerup.x + powerup.width/2 + stemSway, 
                            powerup.y + powerup.height/2 - powerup.height/4,
                            powerup.x + powerup.width/2, 
                            powerup.y + powerup.height/2 - powerup.height/3
                        );
                        ctx.stroke();
                        
                        // Leaf with animation
                        const leafPulse = 1 + Math.sin(Date.now() * 0.006) * 0.2;
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/2 + 5, 
                               powerup.y + powerup.height/2 - powerup.height/4, 
                               3 * leafPulse, 0, Math.PI * 2);
                        ctx.stroke();
                        
                    } else if (powerup.type === 'exercise') {
                        // Animated dumbbell icon
                        const dumbbellShake = Math.sin(Date.now() * 0.01) * 1;
                        
                        // Left weight with movement
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width/4 + dumbbellShake, 
                               powerup.y + powerup.height/2, 
                               powerup.width/6, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Right weight with movement
                        ctx.beginPath();
                        ctx.arc(powerup.x + powerup.width*3/4 + dumbbellShake, 
                               powerup.y + powerup.height/2, 
                               powerup.width/6, 0, Math.PI * 2);
                        ctx.stroke();
                        
                        // Handle with movement
                        ctx.beginPath();
                        ctx.moveTo(powerup.x + powerup.width/4 + dumbbellShake, powerup.y + powerup.height/2);
                        ctx.lineTo(powerup.x + powerup.width*3/4 + dumbbellShake, powerup.y + powerup.height/2);
                        ctx.stroke();
                    }
                }
            });
            
            // Draw month progress bar with enhanced style
            const progressWidth = 300;
            const progressHeight = 8;
            const progressX = (canvas.width - progressWidth) / 2;
            const progressY = 60;
            
            // Background with rounded corners and shadow
            ctx.shadowColor = 'rgba(0, 0, 0, 0.2)';
            ctx.shadowBlur = 3;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 1;
            
            ctx.fillStyle = "rgba(222, 226, 230, 0.6)";
            roundRect(ctx, progressX, progressY, progressWidth, progressHeight, 4, true, false);
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Progress with gradient and animation
            const progress = currentMonthTimer / framesPerMonth;
            
            if (progress > 0) {
                // Create gradient based on time of day
                const progressGradient = ctx.createLinearGradient(progressX, progressY, progressX + progressWidth * progress, progressY);
                
                if (isDayTime) {
                    progressGradient.addColorStop(0, "rgba(42, 100, 150, 0.9)");
                    progressGradient.addColorStop(1, "rgba(58, 122, 95, 0.8)");
                } else {
                    progressGradient.addColorStop(0, "rgba(90, 90, 143, 0.9)");
                    progressGradient.addColorStop(1, "rgba(42, 100, 150, 0.8)");
                }
                
                ctx.fillStyle = progressGradient;
                roundRect(ctx, progressX, progressY, progressWidth * progress, progressHeight, 4, true, false);
                
                // Add subtle pulse effect at the edge of progress
                if (progress > 0.05 && progress < 0.95) {
                    const pulseSize = 3 + Math.sin(Date.now() * 0.01) * 2;
                    ctx.fillStyle = isDayTime ? "rgba(255, 255, 255, 0.5)" : "rgba(200, 200, 250, 0.5)";
                    ctx.beginPath();
                    ctx.arc(progressX + progressWidth * progress, progressY + progressHeight / 2, pulseSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Draw running animation if player is moving
            if (isMoving) {
                // Draw motion lines behind player - more subtle for mature look
                ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.4)" : "rgba(150, 150, 180, 0.4)";
                ctx.lineWidth = 1.5;
                
                const motionX = player.x - 30;
                
                for (let i = 0; i < 4; i++) {
                    const lineY = player.y + 20 + i * 15;
                    const lineLength = 8 + i * 4;
                    
                    // Animate motion lines length based on player speed
                    const animatedLength = lineLength * (0.8 + Math.sin(Date.now() * 0.01 + i) * 0.2);
                    
                    ctx.beginPath();
                    ctx.moveTo(motionX, lineY);
                    ctx.lineTo(motionX - animatedLength, lineY);
                    ctx.stroke();
                }
                
                // Add dust particles at player's feet when moving
                if (Math.random() < 0.2) {
                    createDustParticle();
                }
            }
            
            // Draw game messages if any
            if (gameMessage && gameMessageTime > 0) {
                const alpha = Math.min(1, gameMessageTime / 100);
                ctx.globalAlpha = alpha;
                ctx.fillStyle = "#495057";
                ctx.font = "18px 'Open Sans', Arial";
                ctx.textAlign = "center";
                ctx.fillText(gameMessage, canvas.width/2, canvas.height/2);
                ctx.textAlign = "start";
                ctx.globalAlpha = 1.0;
            }
            
            // Draw dynamic day/night indicator
            drawDayNightIndicator();
        }
        
        // Draw dynamic background based on time of day
        function drawDynamicBackground() {
            // Sky gradient based on time
            let skyGradient;
            const hour = currentHour + (currentMinute / 60);
            
            skyGradient = ctx.createLinearGradient(0, 0, 0, ground.y);
            
            // Dawn (5-6)
            if (hour >= 5 && hour < 6) {
                const dawnProgress = (hour - 5);
                skyGradient.addColorStop(0, mixColorStrings('#283655', '#FF7F50', dawnProgress));
                skyGradient.addColorStop(1, mixColorStrings('#1a2238', '#FFD700', dawnProgress));
            }
            // Morning (6-10)
            else if (hour >= 6 && hour < 10) {
                skyGradient.addColorStop(0, '#87CEEB');
                skyGradient.addColorStop(1, '#ADD8E6');
            }
            // Day (10-16)
            else if (hour >= 10 && hour < 16) {
                skyGradient.addColorStop(0, '#6CA6CD');
                skyGradient.addColorStop(1, '#87CEEB');
            }
            // Afternoon (16-18)
            else if (hour >= 16 && hour < 18) {
                const afternoonProgress = (hour - 16) / 2;
                skyGradient.addColorStop(0, mixColorStrings('#6CA6CD', '#FF7F50', afternoonProgress));
                skyGradient.addColorStop(1, mixColorStrings('#87CEEB', '#FFD700', afternoonProgress));
            }
            // Sunset (18-19)
            else if (hour >= 18 && hour < 19) {
                const sunsetProgress = (hour - 18);
                skyGradient.addColorStop(0, mixColorStrings('#FF7F50', '#283655', sunsetProgress));
                skyGradient.addColorStop(1, mixColorStrings('#FFD700', '#1a2238', sunsetProgress));
            }
            // Night (19-5)
            else {
                skyGradient.addColorStop(0, '#1a2238');
                skyGradient.addColorStop(1, '#283655');
            }
            
            ctx.fillStyle = skyGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Add stars at night
            if (hour >= 19 || hour < 5) {
                drawStars();
            }
            // Draw sunrise/sunset rays
            else if ((hour >= 5 && hour < 7) || (hour >= 17 && hour < 19)) {
                drawSunrays();
            }
        }
        
        // Draw stars in night sky
        function drawStars() {
            // Use the stars array created in createStars()
            if (stars.length === 0) {
                createStars();
            }
            
            stars.forEach((star, index) => {
                // Twinkle effect
                const twinkle = 0.5 + Math.sin(Date.now() * 0.001 * star.twinkleSpeed) * 0.5;
                const size = star.size * (0.7 + twinkle * 0.3);
                
                // Draw star
                ctx.fillStyle = `rgba(255, 255, 255, ${0.5 + twinkle * 0.5})`;
                ctx.beginPath();
                ctx.arc(star.x, star.y, size, 0, Math.PI * 2);
                ctx.fill();
                
                // Occasional larger star with glow
                if (index % 8 === 0) {
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.5)';
                    ctx.shadowBlur = 4;
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, size * 1.5, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowColor = 'transparent';
                    ctx.shadowBlur = 0;
                }
            });
        }
        
        // Draw sunrise/sunset rays
        function drawSunrays() {
            const hour = currentHour + (currentMinute / 60);
            let rayOpacity, rayColor, sunX, sunY;
            
            // Sunrise (5-7)
            if (hour >= 5 && hour < 7) {
                rayOpacity = (hour - 5) / 2; // 0 to 1 during sunrise
                rayColor = 'rgba(255, 215, 0, '; // Golden
                sunX = canvas.width * 0.2;
                sunY = ground.y * 0.8;
            }
            // Sunset (17-19)
            else {
                rayOpacity = 1 - ((hour - 17) / 2); // 1 to 0 during sunset
                rayColor = 'rgba(255, 127, 80, '; // Coral
                sunX = canvas.width * 0.8;
                sunY = ground.y * 0.8;
            }
            
            // Limit opacity
            rayOpacity = Math.min(0.7, Math.max(0, rayOpacity));
            
            // Draw rays
            ctx.save();
            ctx.translate(sunX, sunY);
            
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const rayLength = 100 + Math.sin(Date.now() * 0.001 + i) * 20;
                
                ctx.rotate(angle);
                ctx.fillStyle = rayColor + rayOpacity + ')';
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(rayLength, 10);
                ctx.lineTo(rayLength, -10);
                ctx.closePath();
                ctx.fill();
                ctx.rotate(-angle);
            }
            
            ctx.restore();
        }
        
        // Draw background patterns - enhanced for day/night
        function drawBackgroundPatterns() {
            ctx.fillStyle = isDayTime ? "rgba(222, 226, 230, 0.2)" : "rgba(100, 100, 150, 0.1)";
            
            // Draw subtle grid pattern
            ctx.beginPath();
            for (let i = 0; i < canvas.width; i += 40) {
                ctx.moveTo(i, 0);
                ctx.lineTo(i, ground.y);
            }
            for (let i = 0; i < ground.y; i += 40) {
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
            }
            ctx.strokeStyle = isDayTime ? "rgba(108, 117, 125, 0.05)" : "rgba(100, 100, 150, 0.05)";
            ctx.lineWidth = 1;
            ctx.stroke();
            
            // Add subtle visual elements representing financial graph
            ctx.strokeStyle = isDayTime ? 
                "rgba(42, 100, 150, 0.1)" : // Day: Blue
                "rgba(100, 100, 150, 0.1)"; // Night: Purple-blue
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            // Draw financial graph line in background
            ctx.moveTo(0, ground.y - 100);
            
            // Use current score to influence the graph height
            const scoreInfluence = Math.min(0.5, score / 100000);
            
            for (let x = 50; x < canvas.width; x += 50) {
                // Base graph with randomness
                let y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20;
                
                // Add upward trend based on score
                y -= scoreInfluence * 100;
                
                ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Add data points to graph
            if (score > 10000) {
                for (let x = 100; x < canvas.width; x += 100) {
                    const y = ground.y - 100 - Math.sin(x / 200) * 50 - Math.random() * 20 - (scoreInfluence * 100);
                    
                    ctx.fillStyle = isDayTime ? "rgba(42, 100, 150, 0.2)" : "rgba(100, 100, 150, 0.2)";
                    ctx.beginPath();
                    ctx.arc(x, y, 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function to create dust particles at player's feet
        function createDustParticle() {
            const particle = document.createElement('div');
            particle.className = 'dust-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '4px';
            particle.style.height = '4px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = isDayTime ? 'rgba(200, 200, 200, 0.6)' : 'rgba(150, 150, 180, 0.6)';
            particle.style.zIndex = '12';
            
            // Position at player's feet
            particle.style.top = `${ground.y}px`;
            particle.style.left = `${player.x + player.width / 2}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.PI + (Math.random() * Math.PI * 0.5);
            const distance = 10 + Math.random() * 20;
            const duration = 0.5 + Math.random() * 0.5;
            
            const particleKeyframes = `
                @keyframes dust-move-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.5);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `dust-move-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw sparkle effect
        function drawSparkle(x, y, size, color) {
            // Draw a simple sparkle star
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(Math.random() * Math.PI * 2);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            
            const innerSize = size * 0.5;
            const outerSize = size;
            
            // Star shape
            ctx.beginPath();
            for (let i = 0; i < 4; i++) {
                const angle = (i / 4) * Math.PI * 2;
                ctx.moveTo(0, 0);
                ctx.lineTo(Math.cos(angle) * outerSize, Math.sin(angle) * outerSize);
            }
            ctx.stroke();
            
            // Inner glow
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.beginPath();
            ctx.arc(0, 0, innerSize, 0, Math.PI * 2);
            ctx.fill();
            
            ctx.restore();
        }
        
        // Draw powerup particle effect
        function drawPowerupParticle(x, y, color) {
            const particle = document.createElement('div');
            particle.className = 'powerup-particle';
            
            // Style the particle
            particle.style.position = 'absolute';
            particle.style.width = '6px';
            particle.style.height = '6px';
            particle.style.borderRadius = '50%';
            particle.style.backgroundColor = color || 'rgba(42, 100, 150, 0.8)';
            particle.style.zIndex = '15';
            
            // Position at source
            particle.style.top = `${y}px`;
            particle.style.left = `${x}px`;
            
            document.getElementById('game-container').appendChild(particle);
            
            // Create animation keyframes
            const angle = Math.random() * Math.PI * 2;
            const distance = 20 + Math.random() * 30;
            const duration = 1 + Math.random() * 1;
            
            const particleKeyframes = `
                @keyframes powerup-particle-${Date.now()} {
                    0% { 
                        opacity: 0.8;
                        transform: translateX(0) translateY(0) scale(1);
                    }
                    100% { 
                        opacity: 0;
                        transform: translateX(${Math.cos(angle) * distance}px) translateY(${Math.sin(angle) * distance}px) scale(0.2);
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = particleKeyframes;
            document.head.appendChild(style);
            
            // Apply animation
            particle.style.animation = `powerup-particle-${Date.now()} ${duration}s ease-out forwards`;
            
            // Remove particle after animation
            setTimeout(() => {
                if (particle.parentNode) {
                    particle.parentNode.removeChild(particle);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, duration * 1000 + 100);
        }
        
        // Draw day/night indicator
        function drawDayNightIndicator() {
            // Small indicator in corner
            const size = 30;
            const margin = 20;
            const x = canvas.width - size - margin;
            const y = margin;
            
            // Draw background circle
            ctx.fillStyle = isDayTime ? 'rgba(255, 255, 255, 0.6)' : 'rgba(50, 50, 80, 0.6)';
            ctx.beginPath();
            ctx.arc(x, y, size/2, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw icon based on time
            if (isDayTime) {
                // Sun icon
                ctx.fillStyle = 'rgba(255, 215, 0, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Sun rays
                ctx.strokeStyle = 'rgba(255, 215, 0, 0.7)';
                ctx.lineWidth = 1.5;
                
                for (let i = 0; i < 8; i++) {
                    const angle = (i / 8) * Math.PI * 2;
                    const innerRadius = size/3 + 2;
                    const outerRadius = size/2 - 2;
                    
                    ctx.beginPath();
                    ctx.moveTo(
                        x + Math.cos(angle) * innerRadius,
                        y + Math.sin(angle) * innerRadius
                    );
                    ctx.lineTo(
                        x + Math.cos(angle) * outerRadius,
                        y + Math.sin(angle) * outerRadius
                    );
                    ctx.stroke();
                }
            } else {
                // Moon icon
                ctx.fillStyle = 'rgba(230, 230, 250, 0.9)';
                ctx.beginPath();
                ctx.arc(x, y, size/3, 0, Math.PI * 2);
                ctx.fill();
                
                // Moon shadow
                ctx.fillStyle = 'rgba(50, 50, 80, 0.6)';
                ctx.beginPath();
                ctx.arc(x + size/8, y - size/8, size/3 - 1, 0, Math.PI * 2);
                ctx.fill();
                
                // Stars
                for (let i = 0; i < 3; i++) {
                    const starX = x + Math.cos(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    const starY = y + Math.sin(i * Math.PI * 2/3 + Math.PI/6) * (size/2 - 5);
                    
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                    ctx.beginPath();
                    ctx.arc(starX, starY, 1, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }
        
        // Helper function for color string mixing
        function mixColorStrings(color1, color2, ratio) {
            // Convert hex to rgb if needed
            const getRGB = (color) => {
                if (color.startsWith('#')) {
                    const r = parseInt(color.slice(1, 3), 16);
                    const g = parseInt(color.slice(3, 5), 16);
                    const b = parseInt(color.slice(5, 7), 16);
                    return [r, g, b];
                } else if (color.startsWith('rgb')) {
                    return color.match(/\d+/g).map(Number);
                }
                return [0, 0, 0]; // Fallback
            };
            
            const rgb1 = getRGB(color1);
            const rgb2 = getRGB(color2);
            
            const r = Math.round(rgb1[0] * (1 - ratio) + rgb2[0] * ratio);
            const g = Math.round(rgb1[1] * (1 - ratio) + rgb2[1] * ratio);
            const b = Math.round(rgb1[2] * (1 - ratio) + rgb2[2] * ratio);
            
            return `rgb(${r}, ${g}, ${b})`;
        }
        // Draw speech bubble for characters
        function drawSpeechBubble(ctx, x, y, text, maxWidth, maxHeight) {
            // Calculate text metrics and bubble size
            ctx.font = "12px 'Open Sans', Arial";
            const words = text.split(' ');
            const lineHeight = 14;
            let lines = [];
            let currentLine = '';
            
            // Break text into lines
            words.forEach(word => {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine !== '') {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // Limit number of lines to fit maxHeight
            if (lines.length * lineHeight > maxHeight) {
                lines = lines.slice(0, Math.floor(maxHeight / lineHeight) - 1);
                lines.push('...');
            }
            
            const bubbleWidth = maxWidth + 20;
            const bubbleHeight = lines.length * lineHeight + 20;
            const bubbleX = x - 10;
            const bubbleY = y - bubbleHeight / 2;
            
            // Draw bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            
            // Rounded rectangle for bubble
            roundRect(ctx, bubbleX, bubbleY, bubbleWidth, bubbleHeight, 8, true, true);
            
            // Draw pointer
            ctx.beginPath();
            ctx.moveTo(bubbleX, bubbleY + bubbleHeight / 2);
            ctx.lineTo(bubbleX - 10, bubbleY + bubbleHeight / 2 + 5);
            ctx.lineTo(bubbleX, bubbleY + bubbleHeight / 2 + 10);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.fill();
            ctx.stroke();
            
            // Draw text
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.textAlign = 'left';
            
            lines.forEach((line, index) => {
                ctx.fillText(line, bubbleX + 10, bubbleY + 20 + (index * lineHeight));
            });
        }
        
        // Draw enhanced player with animations and visual effects
        function drawEnhancedPlayer() {
            // Use health factor to subtly adjust player appearance, not size
            const healthFactor = stats.physicalHealth / 100;
            const mentalFactor = stats.mentalHealth / 100;
            
            // Calculate player color based on health - subtle shift
            const r = Math.floor(73 + (1 - healthFactor) * 40);
            const g = Math.floor(80 + (1 - healthFactor) * 10);
            const b = Math.floor(87 + (healthFactor) * 10);
            const playerColor = `rgb(${r}, ${g}, ${b})`;
            
            // Add subtle bob animation when moving
            let playerY = player.y;
            if (isMoving) {
                playerY += Math.sin(Date.now() * 0.01) * 2;
            }
            
            // Draw shadow beneath player
            ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.beginPath();
            ctx.ellipse(player.x + player.width/2, ground.y, player.width/2, player.width/8, 0, 0, Math.PI * 2);
            ctx.fill();
            
            // Draw player - enhanced style
            ctx.fillStyle = playerColor;
            
            // If player has powerUp, add glow effect
            if (player.powerUp) {
                let glowColor;
                
                switch(player.powerUpType) {
                    case 'earlyRise':
                        glowColor = 'rgba(58, 122, 95, 0.7)'; // Green-blue
                        break;
                    case 'earlySleep':
                        glowColor = 'rgba(90, 90, 143, 0.7)'; // Purple-blue
                        break;
                    case 'healthyFood':
                        glowColor = 'rgba(58, 122, 95, 0.7)'; // Green
                        break;
                    case 'exercise':
                        glowColor = 'rgba(211, 135, 62, 0.7)'; // Orange
                        break;
                    case 'companion':
                        glowColor = 'rgba(42, 100, 150, 0.7)'; // Blue
                        break;
                    default:
                        glowColor = 'rgba(73, 80, 87, 0.7)'; // Default gray
                }
                
                // Add glow with pulsating animation
                const glowSize = 10 + Math.sin(Date.now() * 0.005) * 3;
                ctx.shadowColor = glowColor;
                ctx.shadowBlur = glowSize;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
            }
            
            // Body as simple rounded rectangle with subtle lean forward when moving
            if (isMoving) {
                // Save context for body rotation
                ctx.save();
                ctx.translate(player.x + player.width/2, playerY + player.height/2);
                ctx.rotate(Math.PI * 0.03); // Slight forward lean
                ctx.translate(-(player.x + player.width/2), -(playerY + player.height/2));
            }
            
            roundRect(ctx, player.x, playerY, player.width, player.height, 10, true, false);
            
            if (isMoving) {
                ctx.restore();
            }
            
            // Reset shadow
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
            
            // Head with subtle head bob when moving
            const headY = playerY + player.width/2;
            const headBob = isMoving ? Math.sin(Date.now() * 0.01) * 2 : 0;
            
            ctx.beginPath();
            ctx.arc(player.x + player.width/2, headY + headBob, player.width/2.5, 0, Math.PI * 2);
            ctx.fill();
            
            // Facial expression based on mental health - dynamic style
            ctx.strokeStyle = "#e9ecef";
            ctx.lineWidth = 2;
            
            // Eyes with occasional blinking
            const blinkState = Math.floor(Date.now() / 1000) % 5 === 0;
            
            if (blinkState) {
                // Closed eyes (blinking)
                ctx.beginPath();
                ctx.moveTo(player.x + player.width/2 - 8, headY + headBob);
                ctx.lineTo(player.x + player.width/2 - 2, headY + headBob);
                
                ctx.moveTo(player.x + player.width/2 + 2, headY + headBob);
                ctx.lineTo(player.x + player.width/2 + 8, headY + headBob);
                ctx.stroke();
            } else {
                // Open eyes (not blinking)
                ctx.beginPath();
                ctx.arc(player.x + player.width/2 - 8, headY + headBob - 3, 2, 0, Math.PI * 2);
                ctx.arc(player.x + player.width/2 + 8, headY + headBob - 3, 2, 0, Math.PI * 2);
                ctx.stroke();
            }
            
            // Mouth based on mental state - animated
            const mouthCurveBase = mentalFactor < 0.5 ? -1 : 1; // Sad or happy
            
            // Add slight animation to mouth curve
            const mouthAnimate = isMoving ? 
                Math.sin(Date.now() * 0.01) * 0.3 : // Animate when moving 
                Math.sin(Date.now() * 0.002) * 0.1;  // Subtle animation when idle
            
            const mouthCurve = mouthCurveBase + mouthAnimate;
            
            // Calculate control points for curve
            const mouthWidth = player.width/5;
            const mouthX = player.x + player.width/2;
            const mouthY = headY + headBob + 5;
            
            if (mouthCurve < 0) {
                // Sad expression
                ctx.beginPath();
                ctx.moveTo(mouthX - mouthWidth, mouthY);
                ctx.quadraticCurveTo(mouthX, mouthY + mouthWidth * Math.abs(mouthCurve), mouthX + mouthWidth, mouthY);
                ctx.stroke();
            } else {
                // Happy/neutral expression
                ctx.beginPath();
                ctx.moveTo(mouthX - mouthWidth, mouthY);
                ctx.quadraticCurveTo(mouthX, mouthY - mouthWidth * mouthCurve, mouthX + mouthWidth, mouthY);
                ctx.stroke();
            }
            
            // Draw companion if active - enhanced style
            if (player.companion && player.powerUp) {
                // Calculate companion position with slight offset from player
                const companionX = player.x - 40; 
                const companionY = playerY;
                
                // Add companion animation - follows player with slight delay
                const companionBob = isMoving ? Math.sin((Date.now() - 100) * 0.01) * 2 : 0;
                
                // Add companion shadow
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.beginPath();
                ctx.ellipse(companionX + 15, ground.y, 15, 3, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Companion glow effect
                ctx.shadowColor = 'rgba(42, 100, 150, 0.6)';
                ctx.shadowBlur = 8 + Math.sin(Date.now() * 0.01) * 2;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 0;
                
                // Companion body
                ctx.fillStyle = "#2a6496"; // Blue
                roundRect(ctx, companionX, companionY + companionBob + player.width, 30, player.height - player.width, 8, true, false);
                
                // Companion head
                ctx.beginPath();
                ctx.arc(companionX + 15, companionY + companionBob + player.width/2, player.width/2.5, 0, Math.PI * 2);
                ctx.fill();
                
                // Reset shadow
                ctx.shadowColor = 'transparent';
                ctx.shadowBlur = 0;
                
                // Companion face
                ctx.strokeStyle = "#e9ecef";
                ctx.lineWidth = 1.5;
                
                // Eyes with occasional blink
                const companionBlink = Math.floor(Date.now() / 1000) % 6 === 0;
                
                if (companionBlink) {
                    // Closed eyes
                    ctx.beginPath();
                    ctx.moveTo(companionX + 10, companionY + companionBob + player.width/2 - 3);
                    ctx.lineTo(companionX + 15, companionY + companionBob + player.width/2 - 3);
                    
                    ctx.moveTo(companionX + 15, companionY + companionBob + player.width/2 - 3);
                    ctx.lineTo(companionX + 20, companionY + companionBob + player.width/2 - 3);
                    ctx.stroke();
                } else {
                    // Open eyes
                    ctx.beginPath();
                    ctx.arc(companionX + 10, companionY + companionBob + player.width/2 - 3, 2, 0, Math.PI * 2);
                    ctx.arc(companionX + 20, companionY + companionBob + player.width/2 - 3, 2, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // Smile with animation
                const smileAnimate = Math.sin(Date.now() * 0.003) * 0.2;
                
                ctx.beginPath();
                ctx.arc(companionX + 15, companionY + companionBob + player.width/2 + 5, 5, 0, Math.PI * (1 + smileAnimate));
                ctx.stroke();
                
                // Connection line between player and companion
                ctx.strokeStyle = 'rgba(42, 100, 150, 0.3)';
                ctx.lineWidth = 2;
                ctx.setLineDash([5, 3]);
                
                ctx.beginPath();
                ctx.moveTo(companionX + 30, companionY + companionBob + player.height/2);
                ctx.lineTo(player.x, playerY + player.height/2);
                ctx.stroke();
                
                // Reset line dash
                ctx.setLineDash([]);
                
                // Occasional particles between player and companion
                if (Math.random() < 0.05 && isMoving) {
                    const particleX = companionX + 30 + Math.random() * (player.x - companionX - 30);
                    const particleY = companionY + player.height/2 + (Math.random() * 20 - 10);
                    
                    drawPowerupParticle(particleX, particleY, 'rgba(42, 100, 150, 0.6)');
                }
                
                // Speech bubble from companion occasionally
                if (Math.random() < 0.003) {
                    const encouragement = [
                        "  !",
                        "转 专 !",
                        "转砖 !",
                        " 爪!",
                        "转 注砖 注 专转!"
                    ];
                    
                    drawSpeechBubble(
                        ctx, 
                        companionX, 
                        companionY + companionBob, 
                        encouragement[Math.floor(Math.random() * encouragement.length)],
                        100,
                        40
                    );
                }
            }
            
            // Draw thought bubble occasionally with financial wisdom
            if (Math.random() < 0.001 && !isMoving) {
                const thoughts = [
                    "住 拽注   驻住",
                    "爪转 拽转 爪专转",
                    "砖拽注 注爪  砖拽注  转专",
                    "住转  驻转 爪 驻住转",
                    "转 专砖 住 住祝  专"
                ];
                
                drawThoughtBubble(
                    ctx,
                    player.x + player.width + 10,
                    playerY,
                    thoughts[Math.floor(Math.random() * thoughts.length)],
                    120,
                    60
                );
            }
        }
        
        // Draw thought bubble
        function drawThoughtBubble(ctx, x, y, text, maxWidth, maxHeight) {
            // Calculate text metrics and bubble size
            ctx.font = "12px 'Open Sans', Arial";
            const words = text.split(' ');
            const lineHeight = 14;
            let lines = [];
            let currentLine = '';
            
            // Break text into lines
            words.forEach(word => {
                const testLine = currentLine ? `${currentLine} ${word}` : word;
                const metrics = ctx.measureText(testLine);
                
                if (metrics.width > maxWidth && currentLine !== '') {
                    lines.push(currentLine);
                    currentLine = word;
                } else {
                    currentLine = testLine;
                }
            });
            
            if (currentLine) {
                lines.push(currentLine);
            }
            
            // Limit number of lines to fit maxHeight
            if (lines.length * lineHeight > maxHeight) {
                lines = lines.slice(0, Math.floor(maxHeight / lineHeight) - 1);
                lines.push('...');
            }
            
            const bubbleWidth = maxWidth + 20;
            const bubbleHeight = lines.length * lineHeight + 20;
            const bubbleX = x;
            const bubbleY = y - bubbleHeight / 2;
            
            // Draw main bubble
            ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            
            // Rounded rectangle for bubble with cloud-like edges
            roundRect(ctx, bubbleX, bubbleY, bubbleWidth, bubbleHeight, 12, true, true);
            
            // Draw connecting bubbles
            const bubbleRadius = 8;
            
            // First connecting bubble
            ctx.beginPath();
            ctx.arc(bubbleX - 15, bubbleY + bubbleHeight, bubbleRadius, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Second connecting bubble
            ctx.beginPath();
            ctx.arc(bubbleX - 25, bubbleY + bubbleHeight + 10, bubbleRadius * 0.7, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Third connecting bubble
            ctx.beginPath();
            ctx.arc(bubbleX - 35, bubbleY + bubbleHeight + 15, bubbleRadius * 0.4, 0, Math.PI * 2);
            ctx.fill();
            ctx.stroke();
            
            // Draw text
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.textAlign = 'left';
            
            lines.forEach((line, index) => {
                ctx.fillText(line, bubbleX + 10, bubbleY + 20 + (index * lineHeight));
            });
        }
        
        // Helper function for rounded rectangles
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            if (typeof stroke === 'undefined') {
                stroke = true;
            }
            if (typeof radius === 'undefined') {
                radius = 5;
            }
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }
        
        // Add achievement notification with enhanced animation
        function addAchievement(text) {
            const achievementsDiv = document.getElementById('achievements');
            const achievement = document.createElement('div');
            achievement.className = 'achievement';
            achievement.textContent = text;
            achievementsDiv.appendChild(achievement);
            
            // Show achievements panel with animation
            achievementsDiv.style.display = 'block';
            achievementsDiv.style.animation = 'achievement-panel-appear 0.5s ease forwards';
            
            // Add animation style if not already present
            if (!document.getElementById('achievement-panel-style')) {
                const style = document.createElement('style');
                style.id = 'achievement-panel-style';
                style.textContent = `
                    @keyframes achievement-panel-appear {
                        from { 
                            opacity: 0; 
                            transform: translateX(-50%) translateY(-10px); 
                        }
                        to { 
                            opacity: 1; 
                            transform: translateX(-50%) translateY(0); 
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Display popup message with special styling
            showAchievementPopup(text);
            
            // Add some bonus points
            score += 1000;
            updateDisplay();
            
            // Show coin reward animation
            showCoinAnimation(1000);
            
            // Create achievement-specific particle effect
            createAchievementEffect();
        }
        
        // Special popup for achievements
        function showAchievementPopup(text) {
            const popup = document.createElement('div');
            popup.className = 'achievement-popup';
            popup.style.position = 'absolute';
            popup.style.top = '40%';
            popup.style.left = '50%';
            popup.style.transform = 'translate(-50%, -50%)';
            popup.style.padding = '15px 30px';
            popup.style.background = 'linear-gradient(135deg, rgba(58, 122, 95, 0.9), rgba(42, 100, 150, 0.9))';
            popup.style.color = 'white';
            popup.style.borderRadius = '8px';
            popup.style.boxShadow = '0 5px 20px rgba(0, 0, 0, 0.3)';
            popup.style.textAlign = 'center';
            popup.style.zIndex = '50';
            popup.style.opacity = '0';
            popup.style.minWidth = '250px';
            
            // Add medal icon
            popup.innerHTML = `
                <div style="font-size: 40px; margin-bottom: 10px;"></div>
                <div style="font-weight: bold; font-size: 18px; margin-bottom: 5px;">砖 砖!</div>
                <div>${text}</div>
                <div style="font-size: 14px; margin-top: 10px;">+1,000 砖" 住</div>
            `;
            
            document.getElementById('game-container').appendChild(popup);
            
            // Define animation for popup
            const style = document.createElement('style');
            style.textContent = `
                @keyframes achievement-popup-anim {
                    0% { 
                        opacity: 0; 
                        transform: translate(-50%, -50%) scale(0.8); 
                    }
                    20% { 
                        opacity: 1; 
                        transform: translate(-50%, -50%) scale(1.1); 
                    }
                    30% { 
                        transform: translate(-50%, -50%) scale(1); 
                    }
                    80% { 
                        opacity: 1; 
                        transform: translate(-50%, -50%) scale(1); 
                    }
                    100% { 
                        opacity: 0; 
                        transform: translate(-50%, -50%) scale(0.9); 
                    }
                }
            `;
            document.head.appendChild(style);
            
            // Apply animation
            popup.style.animation = 'achievement-popup-anim 4s ease-out forwards';
            
            // Play achievement sound effect here if available
            
            // Remove popup after animation
            setTimeout(() => {
                if (popup.parentNode) {
                    popup.parentNode.removeChild(popup);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, 4000);
        }
        
        // Create achievement visual effect
        function createAchievementEffect() {
            // Create glowing ring around player
            const ring = document.createElement('div');
            ring.className = 'achievement-ring';
            ring.style.position = 'absolute';
            ring.style.top = `${player.y + player.height / 2}px`;
            ring.style.left = `${player.x + player.width / 2}px`;
            ring.style.width = '0';
            ring.style.height = '0';
            ring.style.borderRadius = '50%';
            ring.style.background = 'radial-gradient(circle, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0) 70%)';
            ring.style.transform = 'translate(-50%, -50%)';
            ring.style.zIndex = '15';
            
            document.getElementById('game-container').appendChild(ring);
            
            // Define animation for ring
            const ringStyle = document.createElement('style');
            ringStyle.textContent = `
                @keyframes achievement-ring-expand {
                    0% { width: 0; height: 0; opacity: 0; }
                    30% { width: 200px; height: 200px; opacity: 0.8; }
                    100% { width: 400px; height: 400px; opacity: 0; }
                }
            `;
            document.head.appendChild(ringStyle);
            
            // Apply animation
            ring.style.animation = 'achievement-ring-expand 2s ease-out forwards';
            
            // Create explosion of particles
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'achievement-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '8px';
                particle.style.height = '8px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = 'rgba(255, 215, 0, 0.8)';
                particle.style.boxShadow = '0 0 10px rgba(255, 215, 0, 0.5)';
                particle.style.zIndex = '16';
                
                // Position at player
                particle.style.top = `${player.y + player.height / 2}px`;
                particle.style.left = `${player.x + player.width / 2}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create specific animation for this particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 200;
                const duration = 1 + Math.random();
                const delay = Math.random() * 0.3;
                
                const particleKeyframes = `
                    @keyframes achievement-particle-${i} {
                        0% { 
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1); 
                        }
                        100% { 
                            opacity: 0;
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5); 
                        }
                    }
                `;
                
                const particleStyle = document.createElement('style');
                particleStyle.textContent = particleKeyframes;
                document.head.appendChild(particleStyle);
                
                // Apply animation with delay
                setTimeout(() => {
                    particle.style.animation = `achievement-particle-${i} ${duration}s ease-out forwards`;
                }, delay * 1000);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (particleStyle.parentNode) {
                        particleStyle.parentNode.removeChild(particleStyle);
                    }
                }, (delay + duration + 0.1) * 1000);
            }
            
            // Remove ring after animation
            setTimeout(() => {
                if (ring.parentNode) {
                    ring.parentNode.removeChild(ring);
                }
                if (ringStyle.parentNode) {
                    ringStyle.parentNode.removeChild(ringStyle);
                }
            }, 2100);
        }
        // Update display with animated transitions
        function updateDisplay() {
            // Update score with smooth animation if significant change
            const scoreDisplay = document.getElementById('score-display');
            const currentScoreText = scoreDisplay.textContent;
            const currentScore = parseInt(currentScoreText.match(/\d+/g).join(''));
            
            if (Math.abs(currentScore - score) > 100) {
                // Animate score change
                animateScoreChange(currentScore, score);
            } else {
                // Small change, just update
                scoreDisplay.textContent = `住 住 驻住: ${score.toLocaleString()} 砖"`;
            }
            
            // Update date display with transition effect
            const dateDisplay = document.getElementById('date-display');
            
            if (dateDisplay.textContent !== monthNames[currentMonth]) {
                // Save original transform
                const originalTransform = dateDisplay.style.transform;
                
                // Fade out
                dateDisplay.style.opacity = '0';
                dateDisplay.style.transform = 'translateY(-5px)';
                
                // After fade out, update text and fade in
                setTimeout(() => {
                    dateDisplay.textContent = monthNames[currentMonth];
                    dateDisplay.style.opacity = '1';
                    dateDisplay.style.transform = originalTransform;
                }, 300);
            }
            
            // Update monthly stats
            document.getElementById('expenses').textContent = stats.expenses.toLocaleString();
            document.getElementById('income').textContent = stats.income.toLocaleString();
            
            // Highlight changes in income or expenses with color flash
            const expensesElem = document.getElementById('expenses');
            const incomeElem = document.getElementById('income');
            
            // Flash expenses if they changed
            if (stats.expenses > parseInt(expensesElem.getAttribute('data-prev-value') || '0')) {
                flashElement(expensesElem, 'rgba(212, 91, 91, 0.2)');
            }
            
            // Flash income if it changed
            if (stats.income > parseInt(incomeElem.getAttribute('data-prev-value') || '0')) {
                flashElement(incomeElem, 'rgba(58, 122, 95, 0.2)');
            }
            
            // Store current values for next comparison
            expensesElem.setAttribute('data-prev-value', stats.expenses);
            incomeElem.setAttribute('data-prev-value', stats.income);
        }
        
        // Animate score change with counting effect
        function animateScoreChange(startScore, endScore) {
            const scoreDisplay = document.getElementById('score-display');
            const duration = 1000; // 1 second animation
            const startTime = Date.now();
            const scoreChange = endScore - startScore;
            
            // Add highlight effect based on score change direction
            if (scoreChange > 0) {
                scoreDisplay.style.color = 'var(--success-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(58, 122, 95, 0.3)';
            } else if (scoreChange < 0) {
                scoreDisplay.style.color = 'var(--danger-color)';
                scoreDisplay.style.textShadow = '0 0 5px rgba(212, 91, 91, 0.3)';
            }
            
            // Animation function
            function animate() {
                const elapsedTime = Date.now() - startTime;
                const progress = Math.min(elapsedTime / duration, 1);
                
                // Easing function for smoother animation
                const easedProgress = progress < 0.5 ? 
                    4 * progress * progress * progress : 
                    1 - Math.pow(-2 * progress + 2, 3) / 2;
                
                // Calculate current value
                const currentValue = Math.round(startScore + scoreChange * easedProgress);
                
                // Update display
                scoreDisplay.textContent = `住 住 驻住: ${currentValue.toLocaleString()} 砖"`;
                
                // Continue animation if not complete
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // Reset style after animation
                    setTimeout(() => {
                        scoreDisplay.style.color = 'var(--primary-color)';
                        scoreDisplay.style.textShadow = 'none';
                    }, 500);
                }
            }
            
            // Start animation
            animate();
        }
        
        // Flash element background color
        function flashElement(element, color) {
            // Save original background
            const originalBg = element.style.backgroundColor;
            const originalTransition = element.style.transition;
            
            // Apply flash
            element.style.transition = 'background-color 0.1s ease-in';
            element.style.backgroundColor = color;
            
            // Remove flash with transition
            setTimeout(() => {
                element.style.transition = 'background-color 0.5s ease-out';
                element.style.backgroundColor = originalBg;
                
                // Reset transition after animation
                setTimeout(() => {
                    element.style.transition = originalTransition;
                }, 500);
            }, 100);
        }
        
        // Show job offer with enhanced visuals
        function showJobOffer() {
            gamePaused = true;
            jobOfferStage = 0;
            
            // Prepare dialog with animation
            const jobOfferDialog = document.getElementById('job-offer');
            jobOfferDialog.style.animation = 'job-offer-appear 0.5s ease forwards';
            
            // Add animation style if not already present
            if (!document.getElementById('job-offer-style')) {
                const style = document.createElement('style');
                style.id = 'job-offer-style';
                style.textContent = `
                    @keyframes job-offer-appear {
                        from {
                            opacity: 0;
                            transform: translate(-50%, -60%) scale(0.9);
                        }
                        to {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // Add subtle background overlay
            const overlay = document.createElement('div');
            overlay.className = 'job-offer-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.3)';
            overlay.style.zIndex = '90';
            overlay.style.opacity = '0';
            overlay.style.transition = 'opacity 0.5s ease';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in overlay
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 100);
            
            // Store overlay reference for cleanup
            jobOfferDialog.dataset.overlay = 'true';
            
            // Show dialog
            jobOfferDialog.style.display = 'block';
            
            // Add career icon animation
            const careerIcon = document.createElement('div');
            careerIcon.className = 'career-icon';
            careerIcon.style.position = 'absolute';
            careerIcon.style.top = '-40px';
            careerIcon.style.left = '50%';
            careerIcon.style.transform = 'translateX(-50%)';
            careerIcon.style.fontSize = '50px';
            careerIcon.style.opacity = '0';
            careerIcon.style.transition = 'all 0.5s ease';
            careerIcon.textContent = '';
            
            jobOfferDialog.appendChild(careerIcon);
            
            // Animate icon
            setTimeout(() => {
                careerIcon.style.opacity = '1';
                careerIcon.style.top = '-60px';
            }, 300);
        }
        
        // Show job offer followup with enhanced visuals
        function showJobOfferFollowup() {
            // Hide job offer dialog
            const jobOfferDialog = document.getElementById('job-offer');
            jobOfferDialog.style.animation = 'job-offer-exit 0.3s ease forwards';
            
            // Add exit animation style if not already present
            if (!document.getElementById('job-offer-exit-style')) {
                const style = document.createElement('style');
                style.id = 'job-offer-exit-style';
                style.textContent = `
                    @keyframes job-offer-exit {
                        from {
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1);
                        }
                        to {
                            opacity: 0;
                            transform: translate(-50%, -60%) scale(0.9);
                        }
                    }
                `;
                document.head.appendChild(style);
            }
            
            // After exit animation, hide dialog and show followup
            setTimeout(() => {
                jobOfferDialog.style.display = 'none';
                
                // Check if there's a career icon to remove
                const careerIcon = jobOfferDialog.querySelector('.career-icon');
                if (careerIcon) {
                    jobOfferDialog.removeChild(careerIcon);
                }
                
                // Set followup text
                document.getElementById('followup-text').textContent = jobOfferTexts[jobOfferStage];
                
                // Show followup dialog with entrance animation
                const followupDialog = document.getElementById('job-offer-followup');
                followupDialog.style.animation = 'job-followup-appear 0.4s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('job-followup-style')) {
                    const style = document.createElement('style');
                    style.id = 'job-followup-style';
                    style.textContent = `
                        @keyframes job-followup-appear {
                            from {
                                opacity: 0;
                                transform: translate(-50%, -40%) scale(0.95);
                            }
                            to {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                followupDialog.style.display = 'block';
                
                // Add persuasion icon based on stage
                let persuasionIcon = ''; // Default money
                
                if (jobOfferStage === 1) persuasionIcon = ''; // Growth
                if (jobOfferStage === 2) persuasionIcon = ''; // Career
                if (jobOfferStage === 3) persuasionIcon = '憋'; // Time/flexibility
                
                const iconElem = document.createElement('div');
                iconElem.className = 'persuasion-icon';
                iconElem.style.position = 'absolute';
                iconElem.style.top = '-40px';
                iconElem.style.left = '50%';
                iconElem.style.transform = 'translateX(-50%)';
                iconElem.style.fontSize = '40px';
                iconElem.style.opacity = '0';
                iconElem.style.transition = 'all 0.5s ease';
                iconElem.textContent = persuasionIcon;
                
                followupDialog.appendChild(iconElem);
                
                // Animate icon
                setTimeout(() => {
                    iconElem.style.opacity = '1';
                    iconElem.style.top = '-50px';
                }, 300);
            }, 300);
        }
        
        // Game over with enhanced visuals
        function gameOver(reason) {
            gameRunning = false;
            
            // Update game stats
            document.getElementById('game-over-reason').textContent = reason;
            document.getElementById('final-score').textContent = score.toLocaleString();
            document.getElementById('months-played').textContent = stats.monthsPlayed;
            document.getElementById('powerups-collected').textContent = stats.powerupsCollected;
            document.getElementById('obstacles-avoided').textContent = stats.obstaclesFaced;
            
            // Create dramatic overlay
            const overlay = document.createElement('div');
            overlay.className = 'game-over-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.backgroundColor = 'rgba(0, 0, 0, 0)';
            overlay.style.transition = 'background-color 1.5s ease';
            overlay.style.zIndex = '90';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in dark overlay
            setTimeout(() => {
                overlay.style.backgroundColor = 'rgba(0, 0, 0, 0.6)';
            }, 100);
            
            // Show game over with enhanced animation
            setTimeout(() => {
                const gameOverScreen = document.getElementById('game-over');
                gameOverScreen.style.display = 'block';
                gameOverScreen.style.animation = 'game-over-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('game-over-style')) {
                    const style = document.createElement('style');
                    style.id = 'game-over-style';
                    style.textContent = `
                        @keyframes game-over-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.05);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
                
                // Add dramatic visual effects
                createGameOverEffect();
            }, 800);
        }
        
        // Create visual effects for game over
        function createGameOverEffect() {
            // Add falling coins/money effect
            for (let i = 0; i < 20; i++) {
                setTimeout(() => {
                    const coin = document.createElement('div');
                    coin.className = 'falling-money';
                    
                    // Randomize coin appearance - dollar, shekel, or coins
                    const coinTypes = ['', '', '', ''];
                    const coinText = coinTypes[Math.floor(Math.random() * coinTypes.length)];
                    
                    // Style the coin
                    coin.style.position = 'absolute';
                    coin.style.fontSize = `${20 + Math.random() * 20}px`;
                    coin.style.opacity = '0.7';
                    coin.style.zIndex = '91';
                    coin.style.color = '#d45b5b';
                    coin.style.textShadow = '0 0 10px rgba(212, 91, 91, 0.5)';
                    coin.textContent = coinText;
                    
                    // Position randomly at top
                    const startX = Math.random() * window.innerWidth;
                    coin.style.top = `-50px`;
                    coin.style.left = `${startX}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(coin);
                    
                    // Create animation for falling
                    const fallDuration = 3 + Math.random() * 2;
                    const rotationSpeed = (Math.random() - 0.5) * 720;
                    const horizontalMovement = (Math.random() - 0.5) * 100;
                    const delay = Math.random() * 2;
                    
                    // Create keyframes for this specific coin
                    const keyframes = `
                        @keyframes fall-${Date.now()}-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0.7;
                            }
                            80% {
                                opacity: 0.7;
                            }
                            100% {
                                transform: translateY(${window.innerHeight + 100}px) 
                                           translateX(${horizontalMovement}px) 
                                           rotate(${rotationSpeed}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    
                    // Add style for this specific animation
                    const style = document.createElement('style');
                    style.textContent = keyframes;
                    document.head.appendChild(style);
                    
                    // Apply animation with delay
                    setTimeout(() => {
                        coin.style.animation = `fall-${Date.now()}-${i} ${fallDuration}s cubic-bezier(0.4, 0, 1, 1) forwards`;
                    }, delay * 1000);
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (coin.parentNode) {
                            coin.parentNode.removeChild(coin);
                        }
                        if (style.parentNode) {
                            style.parentNode.removeChild(style);
                        }
                    }, (fallDuration + delay + 0.5) * 1000);
                }, i * 200); // Stagger coin creation
            }
            
            // Add crack in ground effect
            const crack = document.createElement('div');
            crack.className = 'ground-crack';
            crack.style.position = 'absolute';
            crack.style.top = `${ground.y - 10}px`;
            crack.style.left = '50%';
            crack.style.transform = 'translateX(-50%)';
            crack.style.width = '0';
            crack.style.height = '20px';
            crack.style.backgroundColor = '#333';
            crack.style.boxShadow = '0 0 10px rgba(0, 0, 0, 0.5), 0 0 5px rgba(255, 0, 0, 0.3)';
            crack.style.zIndex = '91';
            
            document.getElementById('game-container').appendChild(crack);
            
            // Create crack animation
            const crackStyle = document.createElement('style');
            crackStyle.textContent = `
                @keyframes crack-grow {
                    0% { width: 0; }
                    60% { width: 60%; }
                    100% { width: 50%; }
                }
            `;
            document.head.appendChild(crackStyle);
            
            // Apply animation
            crack.style.animation = 'crack-grow 1.2s ease-out forwards';
        }
        
        // Win game with enhanced visuals
        function winGame() {
            gameRunning = false;
            
            // Update win stats
            document.getElementById('win-months').textContent = stats.monthsPlayed;
            document.getElementById('win-powerups').textContent = stats.powerupsCollected;
            document.getElementById('win-obstacles').textContent = stats.obstaclesFaced;
            
            // Create celebratory overlay
            const overlay = document.createElement('div');
            overlay.className = 'win-overlay';
            overlay.style.position = 'absolute';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100%';
            overlay.style.height = '100%';
            overlay.style.background = 'radial-gradient(circle, rgba(42, 100, 150, 0) 0%, rgba(42, 100, 150, 0.3) 100%)';
            overlay.style.transition = 'all 1.5s ease';
            overlay.style.zIndex = '90';
            overlay.style.opacity = '0';
            
            document.getElementById('game-container').appendChild(overlay);
            
            // Fade in overlay
            setTimeout(() => {
                overlay.style.opacity = '1';
            }, 100);
            
            // Create celebration effects
            createWinEffects();
            
            // Show win screen with enhanced animation
            setTimeout(() => {
                const winScreen = document.getElementById('win-screen');
                winScreen.style.display = 'block';
                winScreen.style.animation = 'win-screen-appear 1s ease forwards';
                
                // Add animation style if not already present
                if (!document.getElementById('win-screen-style')) {
                    const style = document.createElement('style');
                    style.id = 'win-screen-style';
                    style.textContent = `
                        @keyframes win-screen-appear {
                            0% {
                                opacity: 0;
                                transform: translate(-50%, -50%) scale(0.8);
                            }
                            50% {
                                opacity: 1;
                                transform: translate(-50%, -50%) scale(1.1);
                            }
                            100% {
                                transform: translate(-50%, -50%) scale(1);
                            }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }, 1500);
        }
        
        // Create celebration effects for win
        function createWinEffects() {
            // Create fireworks effect
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    createFirework();
                }, i * 300);
            }
            
            // Create golden rain
            for (let i = 0; i < 30; i++) {
                setTimeout(() => {
                    createGoldenRain();
                }, Math.random() * 2000);
            }
            
            // Create floating achievement icons
            const achievementIcons = ['', '', '', '', '', '', ''];
            
            for (let i = 0; i < 10; i++) {
                setTimeout(() => {
                    const icon = document.createElement('div');
                    icon.className = 'floating-achievement';
                    
                    // Style the icon
                    icon.style.position = 'absolute';
                    icon.style.fontSize = `${30 + Math.random() * 20}px`;
                    icon.style.opacity = '0';
                    icon.style.zIndex = '91';
                    icon.textContent = achievementIcons[Math.floor(Math.random() * achievementIcons.length)];
                    
                    // Position randomly
                    icon.style.top = `${Math.random() * (window.innerHeight * 0.7)}px`;
                    icon.style.left = `${Math.random() * window.innerWidth}px`;
                    
                    // Add to game container
                    document.getElementById('game-container').appendChild(icon);
                    
                    // Define animation
                    const floatDuration = 5 + Math.random() * 3;
                    const floatDistance = 100 + Math.random() * 200;
                    
                    const iconStyle = document.createElement('style');
                    iconStyle.textContent = `
                        @keyframes float-icon-${i} {
                            0% {
                                transform: translateY(0) rotate(0deg);
                                opacity: 0;
                            }
                            10% {
                                opacity: 0.9;
                            }
                            90% {
                                opacity: 0.9;
                            }
                            100% {
                                transform: translateY(-${floatDistance}px) rotate(${Math.random() * 40 - 20}deg);
                                opacity: 0;
                            }
                        }
                    `;
                    document.head.appendChild(iconStyle);
                    
                    // Apply animation
                    icon.style.animation = `float-icon-${i} ${floatDuration}s ease-out forwards`;
                    
                    // Remove elements after animation
                    setTimeout(() => {
                        if (icon.parentNode) {
                            icon.parentNode.removeChild(icon);
                        }
                        if (iconStyle.parentNode) {
                            iconStyle.parentNode.removeChild(iconStyle);
                        }
                    }, floatDuration * 1000 + 100);
                }, i * 500 + Math.random() * 1000);
            }
        }
        
        // Create a firework effect
        function createFirework() {
            // Create firework explosion at random position
            const explosionX = Math.random() * window.innerWidth;
            const explosionY = Math.random() * (window.innerHeight * 0.6);
            
            // Random firework color
            const colors = [
                '255, 215, 0',  // Gold
                '42, 100, 150', // Blue
                '58, 122, 95',  // Green
                '255, 127, 80', // Coral
                '147, 112, 219' // Purple
            ];
            const color = colors[Math.floor(Math.random() * colors.length)];
            
            // Create particles
            for (let i = 0; i < 30; i++) {
                const particle = document.createElement('div');
                particle.className = 'firework-particle';
                
                // Style the particle
                particle.style.position = 'absolute';
                particle.style.width = '4px';
                particle.style.height = '4px';
                particle.style.borderRadius = '50%';
                particle.style.backgroundColor = `rgba(${color}, 0.8)`;
                particle.style.boxShadow = `0 0 6px rgba(${color}, 0.5)`;
                particle.style.zIndex = '92';
                
                // Position at explosion center
                particle.style.top = `${explosionY}px`;
                particle.style.left = `${explosionX}px`;
                
                document.getElementById('game-container').appendChild(particle);
                
                // Create specific animation for this particle
                const angle = Math.random() * Math.PI * 2;
                const distance = 50 + Math.random() * 150;
                const duration = 0.8 + Math.random() * 0.6;
                
                const particleKeyframes = `
                    @keyframes firework-particle-${Date.now()}-${i} {
                        0% { 
                            opacity: 1;
                            transform: translate(-50%, -50%) scale(1.5); 
                        }
                        100% { 
                            opacity: 0;
                            transform: translate(
                                calc(-50% + ${Math.cos(angle) * distance}px), 
                                calc(-50% + ${Math.sin(angle) * distance}px)
                            ) scale(0.5); 
                        }
                    }
                `;
                
                const particleStyle = document.createElement('style');
                particleStyle.textContent = particleKeyframes;
                document.head.appendChild(particleStyle);
                
                // Apply animation
                particle.style.animation = `firework-particle-${Date.now()}-${i} ${duration}s ease-out forwards`;
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                    if (particleStyle.parentNode) {
                        particleStyle.parentNode.removeChild(particleStyle);
                    }
                }, duration * 1000 + 100);
            }
        }
        
        // Create golden rain for win effect
        function createGoldenRain() {
            const coin = document.createElement('div');
            coin.className = 'golden-rain';
            
            // Style coin
            coin.style.position = 'absolute';
            coin.style.fontSize = `${15 + Math.random() * 10}px`;
            coin.style.opacity = '0.9';
            coin.style.zIndex = '91';
            coin.style.color = '#FFD700';
            coin.style.textShadow = '0 0 5px rgba(255, 215, 0, 0.7)';
            coin.textContent = '';
            
            // Position at top with random horizontal placement
            const startX = Math.random() * window.innerWidth;
            coin.style.top = `-20px`;
            coin.style.left = `${startX}px`;
            
            document.getElementById('game-container').appendChild(coin);
            
            // Create animation
            const fallDuration = 3 + Math.random() * 2;
            const swayAmount = 50 + Math.random() * 50;
            const direction = Math.random() > 0.5 ? 1 : -1;
            const rotationAmount = Math.random() * 360;
            
            const keyframes = `
                @keyframes golden-rain-${Date.now()} {
                    0% {
                        transform: translateY(0) rotate(0deg);
                        opacity: 0;
                    }
                    10% {
                        opacity: 0.9;
                    }
                    100% {
                        transform: translateY(${window.innerHeight + 50}px) 
                                   translateX(${swayAmount * direction}px) 
                                   rotate(${rotationAmount}deg);
                        opacity: 0.7;
                    }
                }
            `;
            
            const style = document.createElement('style');
            style.textContent = keyframes;
            document.head.appendChild(style);
            
            // Apply animation
            coin.style.animation = `golden-rain-${Date.now()} ${fallDuration}s ease-in forwards`;
            
            // Remove elements after animation
            setTimeout(() => {
                if (coin.parentNode) {
                    coin.parentNode.removeChild(coin);
                }
                if (style.parentNode) {
                    style.parentNode.removeChild(style);
                }
            }, fallDuration * 1000 + 100);
        }
